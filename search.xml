<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据科学导论复习</title>
      <link href="/2023/12/28/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA%E5%A4%8D%E4%B9%A0/"/>
      <url>/2023/12/28/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这门课知识体系实在很杂，涉及到大数据、sql&amp;nosql、机器学习很多领域，而且深度不一，浅到概念深到算法原理，整理起来实在麻烦。于是秉承着极简的理念整理了这份概念文档，应付考试绰绰有余了，对某个点感兴趣的自行搜索。</p></blockquote><h1 id="第一二讲-引言"><a href="#第一二讲-引言" class="headerlink" title="第一二讲 引言"></a>第一二讲 引言</h1><p>总体上是概论部分，可能考的也就名词解释了，总结如下：</p><h2 id="什么是大数据，大数据的界限，4V"><a href="#什么是大数据，大数据的界限，4V" class="headerlink" title="什么是大数据，大数据的界限，4V"></a>什么是大数据，大数据的界限，4V</h2><p>大数据是一种数据规模大到 在数据的获取管理，存储处理，分析计算都远远超过传统数据库软件工具处理范围的 数据集合。</p><p>大数据的界限是PB</p><p>4V： 体量巨大、速度极快（高实时性）、模态多样、价值密度低（但商业价值高）</p><h2 id="什么是数据科学"><a href="#什么是数据科学" class="headerlink" title="什么是数据科学"></a>什么是数据科学</h2><p> 基于传统的数学，统计学的理论和方法，运用计算机技术进行大规模的数据计算，分析，应用的学科</p><h2 id="数据处理的一般步骤是什么"><a href="#数据处理的一般步骤是什么" class="headerlink" title="数据处理的一般步骤是什么"></a>数据处理的一般步骤是什么</h2><p> 采集，表示与存储，预处理（清洗，集成等），建模分析，可视化，决策</p><h1 id="第四五讲-数据采集与整理"><a href="#第四五讲-数据采集与整理" class="headerlink" title="第四五讲 数据采集与整理"></a>第四五讲 数据采集与整理</h1><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><p>基本方法：数据清理，数据集成，数据变换，数据规约</p><h3 id="why预处理"><a href="#why预处理" class="headerlink" title="why预处理"></a>why预处理</h3><p>因为有<strong>脏数据</strong>，在数据挖掘工作中，脏数据是指不完整、含噪声、不一致的数据</p><p>why脏数据？</p><ul><li>不完整，有些数据属性的值丢失或不确定；缺失必要数据，例：缺失学生成绩</li><li>不准确，属性值错误，例：成绩 &#x3D; -10； 噪声数据：包含孤立（偏离期望）的离群</li><li>不一致，数据结构有较大差异；存在数据重复和信息冗余现象；数据需求改动，例，评价等级:“百分制”与“A, B, C”</li></ul><p>数据错误是不可避免的</p><p>数据质量的含义：正确性，一致性，完整性，可靠性</p><h3 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h3><p>数据缺失或出错（噪声）的原因就很多了：采集出错，反爬虫，加密，存储出错，人为，等等</p><h4 id="处理缺失方法"><a href="#处理缺失方法" class="headerlink" title="处理缺失方法"></a>处理缺失方法</h4><h5 id="数据缺失的类型"><a href="#数据缺失的类型" class="headerlink" title="数据缺失的类型"></a>数据缺失的类型</h5><p>完全随机缺失：不依赖其他属性&#x2F;变量，不影响样本的无偏性</p><p>随机缺失：缺失与其他完全属性&#x2F;变量有关系<br>                “期末成绩”的依赖于“平时表现”<br>                “工资”与“人群背景”的关系</p><p>非随机缺失: 数据缺失与属性&#x2F;变量自身的取值有关 Eg.工资问卷</p><h5 id="数据删除"><a href="#数据删除" class="headerlink" title="数据删除"></a>数据删除</h5><p>（可能丢失信息，或改变分布），但如果数据是完全随机缺失，对结果不产生影响，则可以删除</p><h5 id="数据填充"><a href="#数据填充" class="headerlink" title="数据填充"></a>数据填充</h5><ul><li>特殊值填充<ul><li>空值填充，不同于任何属性值。例，NLP词表补0，DL补mask</li><li>样本&#x2F;属性的均值、中位数、众数填充</li></ul></li><li>使用最可能的数据填充<ul><li>热卡填充（找相似的样本，并就近补齐）</li><li>K最近距离法（KNN，找最近的K个相似的样本，并加权平均估计样本缺失数据）</li><li>利用回归等估计方法（基于数据集建立回归方程模型）</li><li>期望值最大化方法（EM算法）</li></ul></li></ul><h4 id="处理噪声方法"><a href="#处理噪声方法" class="headerlink" title="处理噪声方法"></a>处理噪声方法</h4><p>噪声是测量误差的随机部分</p><ul><li>包括错误值，或偏离期望的孤立点值</li><li>需要对数据进行平滑</li></ul><h5 id="分箱-binning"><a href="#分箱-binning" class="headerlink" title="分箱(binning)"></a>分箱(binning)</h5><p>利用近邻数据对数据进行平滑，步骤如下：</p><ol><li><p>排序数据，并将他们分到等深的箱中</p></li><li><p>按箱平均值平滑、按箱中值平滑、按箱边界平滑等(离散化)</p></li></ol><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/28/658d99474fd46.png"></p><h5 id="回归-Regression"><a href="#回归-Regression" class="headerlink" title="回归(Regression)"></a>回归(Regression)</h5><p>回归模型可以做缺失值填充，也可以做数据平滑，同个道理，把噪声数据用回归模型预测数据替代</p><h5 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/28/658d994739175.png"></p><h4 id="特殊处理"><a href="#特殊处理" class="headerlink" title="特殊处理"></a>特殊处理</h4><p>在特定的应用任务中，根据目标不同，需要特殊的数据清理方法</p><p>比如<strong>冷启动问题</strong>：如何在没有大量用户数据的情况下设计个性化推荐系统并让用户对推荐结果满意而愿意使用推荐系统</p><p>几种推荐系统是否存在冷启动问题</p><ul><li>基于人口统计学的推荐：无冷启动问题</li><li>基于内容的推荐：有冷启动问题</li><li>基于协同过滤的推荐：对新物品和新用户都有冷启动问题</li><li>通用推荐问题（两种协同过滤算法）</li></ul><p>UserCF算法推荐的是那些和目标用户有着共同兴趣爱好的其他用户所喜欢的物品</p><p>ItemCF算法推荐的是那些和目标用户之前喜欢的物品类似的其他物品</p><p>UserCF算法的推荐更偏向于社会化，而ItemCF算法的推荐更偏向于个性化</p><h3 id="数据集成"><a href="#数据集成" class="headerlink" title="数据集成"></a>数据集成</h3><p>将多个数据源的数据整合到一个一致的数据存储中,目标是获得更多更完整的数据，获得更全面的数据画像，如用户画像等</p><p>无序数据：每个数据样本的不同维度是没有顺序关系的</p><p>有序数据：对应的不同维度(如特征)是有顺序要求的</p><h4 id="对于无序数据"><a href="#对于无序数据" class="headerlink" title="对于无序数据"></a>对于无序数据</h4><p>集成数据（库）时，经常出现冗余数据</p><ul><li>冗余属性</li><li>冗余样本</li></ul><h5 id="检测冗余属性"><a href="#检测冗余属性" class="headerlink" title="检测冗余属性"></a>检测冗余属性</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658e494459083.png"></p><p>Pearson相关系数：</p><ul><li>＞0：两项属性可以把一个作为冗余删除</li><li>&#x3D;0：相互独立</li><li>&lt;0：负相关</li></ul><p>卡方检验：值越大，两个变量相关的可能越大</p><h5 id="检测冗余样本"><a href="#检测冗余样本" class="headerlink" title="检测冗余样本"></a>检测冗余样本</h5><h6 id="各种距离"><a href="#各种距离" class="headerlink" title="各种距离"></a>各种距离</h6><p>欧几里得距离（对数据标准化很重要）</p><p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658e4996bd9e4.png"></p><p>上面这几个都不咋用，引出马氏距离<br>它在欧式距离的基础上，考虑到各种特性之间的联系（协方差）<br>马氏距离把方差归一化，使得特征之间的关系更加符合实际情况。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658e49e2b4b5f.png"></p><h6 id="各种相似度"><a href="#各种相似度" class="headerlink" title="各种相似度"></a>各种相似度</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658e4a1c3c4b5.png"></p><p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658e4a153e133.png"></p><p>看一下SMC，Jaccard相关系数，余弦相似度怎么算</p><ul><li>Jaccard相关系数用在集合数据上</li><li>余弦相似度用在文档，图片上</li></ul><h4 id="对于有序数据"><a href="#对于有序数据" class="headerlink" title="对于有序数据"></a>对于有序数据</h4><h5 id="Spearman-Rank相关系数"><a href="#Spearman-Rank相关系数" class="headerlink" title="Spearman Rank相关系数"></a>Spearman Rank相关系数</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658e4a961df8f.png"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658e4a94cb8ef.png"> </p><p>怎么算+用途：信息检索，推荐系统</p><h5 id="NDCG"><a href="#NDCG" class="headerlink" title="NDCG"></a>NDCG</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658e50d1bce8f.png"></p><p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658e50d21628f.png"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658e50d1600db.png"></p><h3 id="数据变换"><a href="#数据变换" class="headerlink" title="数据变换"></a>数据变换</h3><h4 id="数据规范化"><a href="#数据规范化" class="headerlink" title="数据规范化"></a>数据规范化</h4><p>目的：将不同数据（属性）按一定规则进行缩放，使它们具有可比性</p><ul><li>最小-最大规范化（对原始数据进行线性变换。把数据A的观察值v从原始的 区间[minA，maxA]映射到新区间 [new_minA，new_maxA]）【0-1规范化又称为归一化】</li><li>z-score规范化【结果仅用于比较】</li></ul><p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658e518fcb300.png"></p><h4 id="数据离散化【熵的计算】"><a href="#数据离散化【熵的计算】" class="headerlink" title="数据离散化【熵的计算】"></a>数据离散化【熵的计算】</h4><p>连续数据过于细致，数据之间的关系难以分析，划分为离散化的区间，发现数据之间的关联，便于算法处理</p><p>Eg. 把年龄离散化为不同年龄段，把成绩离散化为不同等级，总之就是让他们不连续</p><ul><li><p>非监督离散化（可采用噪声清理方法）【无类别信息】</p><ul><li>分箱</li><li>聚类</li></ul></li><li><p>监督离散化（基于熵的离散化）【有类别信息】</p><ul><li><p>熵的计算</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658e5217f238a.png"></p></li><li><p>根据熵确定分割点</p><p>给原来的数据算一个熵<br>计算分割后数据的总熵</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658e52177c694.png"></p><p>相减，得到信息增益<br>确定分割点就是找信息增益最大点的地方</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658e5217d7e77.png"></p><p>答案应该是第二和第三个数据之间</p></li></ul></li></ul><h3 id="数据规约"><a href="#数据规约" class="headerlink" title="数据规约"></a>数据规约</h3><p>数据清理、数据集成之后，获得多源且质量完好的数据集，但数据规模过大</p><p>目标：缩小数据挖掘所需的数据集规模，缩小后的数据集可以产生几乎相同的分析结果</p><p>用于数据归约的时间不应当超过或“抵消”在归约后的数据上 挖掘节省的时间</p><ul><li><p>维度归约（减少所考虑的随机变量或属性的个数）</p><ul><li><p>PCA（主成分分析）【需要复习计算，行列式计算，求特征值，求特征向量】<br>所有行先减去各自行的平均值<br>求协方差矩阵C<br>对协方差矩阵求特征值，特征向量<br>标准化特征向量（长度为1）【不一定要做】<br>用标准化后的特征向量（按特征值大小排序），取K个组成矩阵P<br>Y&#x3D;XP</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658e593fbb6e3.png"></p><p>缺点：求特征值的计算效率是比较低的；映射得到的维度是不可逆的，且不可解释，没有具体意义</p></li><li><p>特征子集选择</p><ul><li>做法：删除不相关或冗余的属性来减少维度与数据量<br>目标：找到最小属性集，使得数据的概率分布尽可能接近使用所有属 性得到的原分布<br>理解：从全部属性中选取一个特征属性子集，使构造出来的模型更好</li></ul></li><li><p>启发式步骤：建立子集集合，构造评价函数，构建停止准则，验证有效性【决策树】</p></li></ul></li><li><p>数值归约（用较小的数据表示形式替换原始数据）【没咋讲】</p><ul><li><p>参数化方法【只存参数，不存数据】：各种回归模型</p></li><li><p>非参数化方法：直方图，聚类，抽样</p></li></ul></li></ul><h2 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h2><p>从这里开始，就和实际任务密切相关了</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p> 在数据预处理以后（或者数据预处理过程中），如何从数据中提取有效的特征，使这些特征能够尽可能的表达原始数据中的信息，使得后续建立的数据模型能达到更好的效果，就是特征工程所要做的工作。</p><h3 id="设计特征"><a href="#设计特征" class="headerlink" title="设计特征"></a>设计特征</h3><ul><li>独热特征表示：将每个属性表示成一个很长的向量（每维代表一个属性值，如词语）<ul><li>优点：直观，简洁</li><li>缺点：<br>维度灾难：当需要表示的属性非常多的时候，独热特征表示在空间和时间上的开销都是十分巨大的<br>语义鸿沟：每个属性都是完全独立的，无法刻画属性间的联系</li></ul></li><li>TF-IDF（词频-逆文档率）<ul><li>词频：TF &#x3D; 某个词(特征值)在句子(数据)中出现的频率</li><li>逆文档率：lg(语料库(数据库)的句子(数据)总数 &#x2F; 包含该词(特征值)的句子(数据)总数)</li><li>应用：搜索引擎；关键词提取；文本相似性；文本摘要</li></ul></li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658e59d964bbf.png"></p><p>例：假如一篇文件的总词语数是100个，而词语“母牛”出现了3次，那么“母牛”一词在该文件中的词频就是3&#x2F;100&#x3D;0.03。一个计算文件频率 (IDF) 的方法是文件集里包含的文件总数除以测定有多少份文件出现过“母牛”一词。所以，如果“母牛”一词在1,000份文件出现过，而文件总数是10,000,000份的话，其逆向文件频率就是 lg(10,000,000 &#x2F; 1,000)&#x3D;4。最后的TF-IDF的分数为0.03 * 4&#x3D;0.12。</p><p>当词语在所有文件中都没有出现时，IDF的分母要加1</p><h3 id="特征子集挑选"><a href="#特征子集挑选" class="headerlink" title="特征子集挑选"></a>特征子集挑选</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658e5a0c3c372.png"></p><h3 id="特征子集评价"><a href="#特征子集评价" class="headerlink" title="特征子集评价"></a>特征子集评价</h3><p>过滤式仅仅是用信息统计的启发式准则来评价</p><p>封装式是直接用最终分类器性能作为评价标准，比过滤式好的代价是泛化性变差，同时计算开销较高</p><p>嵌入式有两种选择：基于奖惩和基于树模型</p><p>奖惩式新增了特征的权重，现在也往往内嵌在深度学习中</p><p>树模型是在说，决策树，随机森林等本身也是一种特征选择</p><h2 id="传统ML和深度学习区别"><a href="#传统ML和深度学习区别" class="headerlink" title="传统ML和深度学习区别"></a>传统ML和深度学习区别</h2><p>从手动特征提取到自动特征提取</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658e5a4a2dca4.png"></p><h1 id="第六讲-数据存储与管理"><a href="#第六讲-数据存储与管理" class="headerlink" title="第六讲 数据存储与管理"></a>第六讲 数据存储与管理</h1><h2 id="数据分类"><a href="#数据分类" class="headerlink" title="数据分类"></a>数据分类</h2><ul><li><p>结构化数据</p><p>可以使用关系型数据库表示和存储的数据，拥有固定结构，如csv等</p></li><li><p>半结构化数据</p><p>弱结构化，虽然不符合关系型数据模型的要求，但是含有相关的标记(自描述结构)，分割实体及其<br>属性 。如：XML，JSON等</p></li><li><p>非结构化数据</p><p>没有固定数据结构，或很难发现统一数据结构的数据<br>文档，文本，图片，视频，音频等</p></li></ul><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658eaa5300ecb.png"></p><p>常见数据库</p><p>关系型：MySQL，Oracle</p><p>非关系型：Redis，Mongo，Neo4j，Hbase等</p><h2 id="SQL类型"><a href="#SQL类型" class="headerlink" title="SQL类型"></a>SQL类型</h2><p>类别一：Data Definition Language (DDL) 数据定义语言(create,delete等)<br>类别二：Data Manipulation Language (DML) 数据操作语言（增删改查）<br>类别三： Data Control Language（DCL）：数据控制语言，用来定义访问权限和安全级别<br>类别四：Data Query Language（DQL）：数据查询语言，用来查询记录（数据）。【Select】</p><ul><li>create，delete（DDL）</li><li>SELECT会结合连接考【Inner Join &#x3D; Join，Outer Join （左，右，全），自然连接】</li></ul><h2 id="关系型数据库优点"><a href="#关系型数据库优点" class="headerlink" title="关系型数据库优点"></a>关系型数据库优点</h2><ul><li>数据结构化，管理效率高</li><li>存取路径对用户隐蔽，用户只要指出“干什么”，不必详细说明“怎么干”</li></ul><p>实际上，明显的优点应该在对于事务的支持，有高一致性</p><h2 id="why-NoSQL"><a href="#why-NoSQL" class="headerlink" title="why NoSQL"></a>why NoSQL</h2><p>可以从下面几个方面来说，主要看题目怎么问：</p><h3 id="从数据结构化来说"><a href="#从数据结构化来说" class="headerlink" title="从数据结构化来说"></a>从数据结构化来说</h3><ul><li>随着大数据时代的降临，我们面对的不仅仅是结构化数据的存储，还有各种半结构化，非结构化的数据</li><li>举例来说，前期需求不明确，非严格事务性的产品，可以使用NoSQL（MongoDB），因为传统RDBMS更改表结构的代价较大，结构不灵活；对于明显面向联系的数据产品来说，使用Neo4J很可能是个不错的选择，因为RDBMS对联系的查询代价比较大</li></ul><h3 id="从高并发读写来说（Web-2-0）"><a href="#从高并发读写来说（Web-2-0）" class="headerlink" title="从高并发读写来说（Web 2.0）"></a>从高并发读写来说（Web 2.0）</h3><ul><li>传统RDBMS几乎所有操作都要过磁盘，这是为了保证事务特性带来的巨大开销；但这种开销在新的Web 2.0中可能是不必要的，起码对于博客系统来说，两个用户短时间内看到的内容不完全一致不会带来很大影响，所以NoSQL一个重要的思路就是降低一定的一致性【降低支持的事务等级】，从而获得更高的读写效率，获得更高的可用性和分区容错</li><li>传统RDBMS是不分区的，意味着不支持横向拓展，这会导致硬件上的IO瓶颈；分布式是应对高并发的重要方案，NoSQL往往都对此提供了强大支持，有自动化分区服务等等</li><li>使用内存做缓存可以改善这一情形，内存式KV数据库—Redis</li></ul><h3 id="从海量数据下的查询（读写）来说"><a href="#从海量数据下的查询（读写）来说" class="headerlink" title="从海量数据下的查询（读写）来说"></a>从海量数据下的查询（读写）来说</h3><ul><li><p>传统RDBMS是行式的，在条件查询下会带来更高的成本；不妨尝试列式存储，该类型也常常应用在大规模的数据分析上</p></li><li><p>集合运算在Redis上很轻松【内存式，结构简单，很快】，但传统就不好说了</p></li><li><p>分布式…</p></li></ul><h2 id="几种NoSQL的应用场景"><a href="#几种NoSQL的应用场景" class="headerlink" title="几种NoSQL的应用场景"></a>几种NoSQL的应用场景</h2><p>集合运算—Redis</p><p>社交，推荐系统，数据可视化—Neo4j</p><p>数据分析—列式</p><p>只要不是强事务性的，用Mongo都会带来性能提升</p><p>Redis优点</p><ul><li>支持的数据类型包括string、list、set、zset(有序集合)和hash</li><li>支持push&#x2F;pop、add&#x2F;remove及取交集并集和差集及更丰富的操作，而且操作都是原子性的，支持各种不同方式的排序</li><li>内存式，分布式，轻松应对高并发场景</li><li>对数据结构性要求不高</li><li>可拓展，分布式</li></ul><p>NoSQL比较通用的原因：</p><ul><li>分布式，轻松应对高并发场景，高并发读写性能优异</li><li>分布式，优越的水平拓展性能【图除外】</li><li>海量数据下高效的查询性能</li><li>对数据结构性要求不高，数据结构修改代价小</li></ul><h1 id="第七讲-探索性数据分析"><a href="#第七讲-探索性数据分析" class="headerlink" title="第七讲 探索性数据分析"></a>第七讲 探索性数据分析</h1><h2 id="数据探索性分析【重点】"><a href="#数据探索性分析【重点】" class="headerlink" title="数据探索性分析【重点】"></a>数据探索性分析【重点】</h2><p>指对已有的数据在尽量量少的先验假定情况下进行探索，逐步了解数据的特点</p><p>作用：利用人机交互技术和数据可视化技术，通过不断揭示数据的规律和数据间的关联，引导分析人员发现并认识以前不知道的数据模式或规律。对未知的数据模式和规律的探索是其价值所在。</p><p>探索式数据分析的基本方法</p><ol><li>计算一些汇总统计量，了解数据的典型值，还可以通过确定异常值，了解数据的异常情况</li><li>制图和制表，展示变量的分布情况、时间序列数据的变化趋势以及变量之间的关系。</li></ol><p>总体：在每一个特定的大数据分析问题中，问题有关对象（个体）所构成的集合即为待研究问题的总体</p><p>样本：从总体中抽取的若干个个体，具有随机性和独立性</p><h2 id="数据分布"><a href="#数据分布" class="headerlink" title="数据分布"></a>数据分布</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658eac0355f28.png"></p><table><thead><tr><th>集中趋势</th><th>离散程度</th><th>形状变化</th></tr></thead><tbody><tr><td>平均数，中位数，分位数，众数</td><td>方差和标准差，极差和四分位差，异众比率，变异系数</td><td>峰度，偏度</td></tr></tbody></table><p>异众比率：非众数组的频率占总频数的比率</p><p>变异系数：原始数据标准差和原始数据平均数的比，当系数大于15%的时候，数据可能不正常</p><p>峰度：描述总体中所有取值 分布形态陡峭程度or平坦程度</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658eac69b144b.png"></p><p>偏度：描述的是某总体取值分布的对称性</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658eac69b5733.png"></p><h2 id="参数估计（点估计）"><a href="#参数估计（点估计）" class="headerlink" title="参数估计（点估计）"></a>参数估计（点估计）</h2><p>用样本统计量θ的某个取值直接作为总体参数θ的估计值</p><p>简单来说，就是用样本指标直接估计总体指标</p><p>指标为某个特征值：如数学期望、方差和相关系数等</p><h3 id="矩估计"><a href="#矩估计" class="headerlink" title="矩估计"></a>矩估计</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658eacf80d225.png"></p><p>一阶原点矩：期望（平均数）</p><p>二阶中心矩：方差</p><p>三阶中心矩：偏度</p><p>四阶中心矩：峰度</p><h3 id="最小二乘估计（LSE）"><a href="#最小二乘估计（LSE）" class="headerlink" title="最小二乘估计（LSE）"></a>最小二乘估计（LSE）</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658eaef6bc851.png"></p><p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658eaef70c7c7.png"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658eaef70a787.png"> </p><h3 id="极大似然估计（MLE）"><a href="#极大似然估计（MLE）" class="headerlink" title="极大似然估计（MLE）"></a>极大似然估计（MLE）</h3><p>思想：利用已知的样本结果信息，反推最具有可能（最大概率）导致这些样本结果出现的模型参数值</p><p>目标：概率分布函数或者似然函数最大；用似然函数取到最大值时的参数值作为估计值</p><p>过程：</p><ol><li>取一个模型，参数未定</li><li>代入变量</li><li>取对数</li><li>解一个最好的参数使得式子最大</li></ol><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658eb5878ca37.jpg"></p><h3 id="最大后验概率估计（MAP）"><a href="#最大后验概率估计（MAP）" class="headerlink" title="最大后验概率估计（MAP）"></a>最大后验概率估计（MAP）</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658eb54be4fda.png"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658eb54ba91db.png"></p><p>区别：在极大似然（MLE）下新增了先验知识（假设），考虑了先验概率</p><p>当先验分布均匀时，MAP 估计与MLE 相等</p><p>先验分布的选择是重要的，根据先验分布决定先验概率</p><p>优点：</p><ul><li>引入先验知识</li><li>在小数据量下更稳定</li></ul><p>缺点：</p><ul><li>和MLE一样，只返回参数的单值估计</li><li>当用不同的参数去表示同一分布时，MAP会对超参数很敏感</li></ul><h3 id="点估计的数量型指标"><a href="#点估计的数量型指标" class="headerlink" title="点估计的数量型指标"></a>点估计的数量型指标</h3><ul><li>平均绝对误差（MAE）</li><li>均方误差(MSE)</li><li>均方根误差(RMSE)【最常用】</li></ul><h2 id="假设检验"><a href="#假设检验" class="headerlink" title="假设检验"></a>假设检验</h2><h3 id="假设检验与参数估计"><a href="#假设检验与参数估计" class="headerlink" title="假设检验与参数估计"></a>假设检验与参数估计</h3><p>相同：都利用样本对总体进行推断，采用的技术手段相似；<br>不同：推断的出发点不同，结果也不同</p><ul><li>参数估计：用样本的统计来来估计总体参数的推断方法，待估计的总体参数在估计前是未知的</li><li>假设检验：先对待估计的总体参数提出一个假设，再利用样本去检验该假设是否成立【逻辑上是反证法】</li></ul><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>一般有两个假设：</p><p>原假设H0：想要拒绝的假设</p><p>备择假设H1：想要接收的假设</p><p>H0和H1不一定是事件的全集，而与实际研究目的相关，具有主观性</p><p>两类错误：</p><p>第一类错误，弃真α：H0成立时，拒绝了H0</p><p>第二类错误，取伪β：H0错误时(H1成立)，接收了H0</p><p>α 错误的犯错率为置信度，降低置信度就可以降低α 错误的犯错率<br>β错误则是由很多客观因素造成的，难以明确表示</p><p>首先要降低α 错误</p><p>增大样本量可以使得两类错误同时减小</p><h2 id="抽样方法"><a href="#抽样方法" class="headerlink" title="抽样方法"></a>抽样方法</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li><p>非概率抽样<br>抽取样本时不是依据随机原则，而是根据研究目的对数据的要求，采用某种方式从总体中抽出部分单位对其实施调查</p><p>缺点：抽取样本有主观性，使结果有偏差；不可能计算各个元素的入样概率，无法得到可靠的估计值及抽样误差估计值，不能推断总体</p></li><li><p>等概率抽样<br>每一个单元的入样概率均相等；</p><p>常见的有：简单随机抽样，系统抽样，分层抽样，整群抽样等等</p><p>系统抽样是在总样本数过多时，随机取一部分，再进行简单随机抽样</p><p>根据某个特性进行分层，层间差距大，层内差距小，按比例抽取来满足等概率<br>整群抽样是直接一次性抽取所需样本数，但需要满足群内差异大，群外差异小的特性</p></li><li><p>不等概率抽样<br>如果总体单元相差较大，等概率抽样效果不一定好</p><p>eg.估计合肥市商业零售总额，大型商场、中型超市和小型商店的差别非常明显，平等对待显然不合理</p><p>分层抽样：按规模分层，大型抽样比高、小型抽样比低<br>目录抽样：少数大单元普查而大多数小单元进行抽样</p></li></ul><h3 id="大数据why需要抽样"><a href="#大数据why需要抽样" class="headerlink" title="大数据why需要抽样"></a>大数据why需要抽样</h3><ul><li>节省时间和算力，提高效率；因为样本整体的结果有时候是不可得的，或者获取成本太高</li><li>解决样本不均衡问题；通过对大类数据进行欠抽样，小类数据进行过抽样，从而使得数据比例达到实验预期</li><li>在定性工作上往往还是由人力来完成，抽样减少数据量才有可能由人力进行处理</li></ul><h1 id="第八讲-数据分析—机器学习"><a href="#第八讲-数据分析—机器学习" class="headerlink" title="第八讲 数据分析—机器学习"></a>第八讲 数据分析—机器学习</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658eb6a6d8c3a.jpg"></p><p>机器学习是人工智能的子领域，它研究如何教给计算机自我学习的能力，而不是让机器按照固定的程序运行</p><p>机器学习是使用训练数据对模型进行学习，训练，优化的过程，最终利用模型对其他数据进行预测和判断的方法。</p><h2 id="机器学习的基本流程"><a href="#机器学习的基本流程" class="headerlink" title="机器学习的基本流程"></a>机器学习的基本流程</h2><ol><li>业务场景分析<ul><li>对业务场景进行分析，了解业务痛点问题，分析机器学习是否适用于该问题</li><li>把业务需求抽象成机器学习问题，如分类、聚类、回归、降维等应用场景</li></ul></li><li>数据处理<ul><li>进行数据清洗，数据集成，数据变换等操作来获取数据</li><li>特征工程，获取高质量特征</li></ul></li><li>训练机器学习模型和评价<ul><li>切分数据集为训练集和测试集</li><li>根据选择的算法进行训练，得到模型</li><li>使用测试集对模型进行评估</li></ul></li><li>使用机器学习模型<ul><li>使用模型对新遇到的数据样本进行预测</li></ul></li></ol><h2 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h2><ul><li>实体数字化：比如婚否的取值有是、否两种可能，所以它是类别型数据，我们用1、0表示是和否<br>这里可能因为度量单位不同等，需要进行数据变换</li><li>文本数字化：0&#x2F;1表示法（每个词有则1，无则0），计数法（重要的词具有更高的值而不止是1），TF-IDF<br>相似的问题：语义鸿沟——解决：N—Gram技术【不考】</li><li>图的数字化：数据结构：邻接矩阵，邻接链表，边列表</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658eb9fea701c.png"></p><ul><li>图像数字化：RGB</li></ul><h2 id="统计和机器学习"><a href="#统计和机器学习" class="headerlink" title="统计和机器学习"></a>统计和机器学习</h2><p>统计：</p><ul><li>只能刻画总体，而不能刻画细节规律</li><li>坚实的数学理论基础，有严密的逻辑性，其结果能用公式给出，结果精确，可解释性强</li><li>建模技巧性强，对假设依赖强，有时难以满足现实情况</li></ul><p>机器学习</p><ul><li>能刻画系统局部细节特征</li><li>基于归纳推理，无需苛刻的假设【反过来则难以解释，需要进一步验证规则，同时，难以推广到其他业务领域】</li><li>能从中反应发现新的规律，且具有较高实时性【反过来模型时效性强】</li></ul><h2 id="机器学习常用方法"><a href="#机器学习常用方法" class="headerlink" title="机器学习常用方法"></a>机器学习常用方法</h2><h3 id="回归模型"><a href="#回归模型" class="headerlink" title="回归模型"></a>回归模型</h3><ul><li>一元线性回归</li><li>逻辑斯蒂回归模型（sigmoid）</li></ul><p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658ebb2ad1162.jpg"></p><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>用于刻画预测结果的优异程度</p><ul><li>均方误差（mean squared error, MSE）</li><li>平均绝对误差（mean absolute error, MAE）</li></ul><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>目标是最小化&#x2F;最大化目标函数，方法是优化参数</p><ul><li>梯度下降（根据斜率下降）</li></ul><h3 id="分类问题"><a href="#分类问题" class="headerlink" title="分类问题"></a>分类问题</h3><h4 id="SVM向量机"><a href="#SVM向量机" class="headerlink" title="SVM向量机"></a>SVM向量机</h4><p>找一个线性函数，可以把输入分成预期的两类</p><p>SVM的目标是分类间隔最大化</p><p>但不一定在本维度线性可分【why 核函数】</p><p>核函数：将样本映射到高维空间，使其基本线性可分【what|how 核函数】</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658ebb950afa1.png"></p><h4 id="Pre感知机"><a href="#Pre感知机" class="headerlink" title="Pre感知机"></a>Pre感知机</h4><p>现代神经网络的雏形，但没有激活函数，所以感知机是一种线性分类模型，属于判别模型</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658ebbad2ae4a.png"></p><table><thead><tr><th></th><th>SVM向量机</th><th>Pre感知机</th></tr></thead><tbody><tr><td>目标</td><td>分类间隔最大化</td><td>最大程度正确划分，最小化错误</td></tr><tr><td>过拟合</td><td>一定程度上避免</td><td>很容易造成过拟合</td></tr><tr><td>学习策略</td><td>拉格朗日函数</td><td>梯度下降</td></tr></tbody></table><h4 id="逻辑斯蒂回归（sigmoid）"><a href="#逻辑斯蒂回归（sigmoid）" class="headerlink" title="逻辑斯蒂回归（sigmoid）"></a>逻辑斯蒂回归（sigmoid）</h4><p>该函数把样本特征的线性组合映射到了（0，1）上</p><p>函数的值具有特殊的含义，它表示结果取类别1的概率</p><h4 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h4><p>均匀分布时，熵最大为log2C</p><p>确定分布时，熵最小为0</p><p>条件熵就是根据分类比例加权的算法</p><p>找一个点进行分割，算得的条件熵前后比较即可得出信息增益</p><h5 id="决策树优点"><a href="#决策树优点" class="headerlink" title="决策树优点"></a>决策树优点</h5><ul><li>可以接收类别型特征【重要】</li><li>分类效果与其他算法相当</li><li>训练，测试效率高</li></ul><h5 id="决策树构建"><a href="#决策树构建" class="headerlink" title="决策树构建"></a>决策树构建</h5><p>全局最优是一个NP—Hard问题</p><p>所以需要启发式算法进行训练</p><p>一个方法是用贪心算法</p><ul><li>每次分类都选择信息增益最大的特征，对训练数据进行划分【类别型就直接选特征，数值型选特征后需要确定阈值】</li><li>当训练样本都属于一个类别，或者没有更多样本和特征时停止</li></ul><h5 id="过拟合"><a href="#过拟合" class="headerlink" title="过拟合"></a>过拟合</h5><p>机器学习算法拟合噪声数据，而不是数据中的有意义规律</p><p>现象：在训练数据上得到的精度，远大于在测试数据上得到的精度</p><p>原因：</p><ul><li><p>训练数据量太少【数据单一】</p></li><li><p>模型过于复杂，模型参数过多</p></li><li><p>决策树：太深、节点太多</p></li><li><p>解决方案：</p><p>增加训练数据，降低模型复杂度</p><p>决策树：剪枝，减少节点数量</p></li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658ebc4e6fdb7.png"></p><h1 id="第九讲-数据分析—神经网络"><a href="#第九讲-数据分析—神经网络" class="headerlink" title="第九讲 数据分析—神经网络"></a>第九讲 数据分析—神经网络</h1><p>输入层——N个隐藏层——输出层</p><p>隐藏层内有很多神经元，每个神经元都有激活函数如sigmoid，tanh等</p><p>也可以不使用激活函数，但结果就只能是线性的了</p><h2 id="前向传导"><a href="#前向传导" class="headerlink" title="前向传导"></a>前向传导</h2><p>计算输出值的过程，称为前向传导，也叫前向传播，</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658ebcc6ae6db.png"></p><h2 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h2><p>反向传播仅指用于计算梯度的方法</p><p>反向传播是拿来算Loss函数对于每个参数的偏微分的</p><p>然后用结果修正参数表</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658ebd06eac96.jpg"></p><p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658ebd06ec9af.jpg"></p><p>最后修正参数就行了，η是学习率，超参数，越大学习越快，代价是可能难以逼近最低点（梯度下降）</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658ebd06bb260.jpg"></p><h1 id="第十讲-数据可视化"><a href="#第十讲-数据可视化" class="headerlink" title="第十讲 数据可视化"></a>第十讲 数据可视化</h1><h2 id="数据可视化作用"><a href="#数据可视化作用" class="headerlink" title="数据可视化作用"></a>数据可视化作用</h2><ul><li>协助思考</li><li>使用感知代替认知</li><li>作为大量工作记忆的外界辅助</li><li>增强认知能力</li></ul><h2 id="数据可视化方法和技术"><a href="#数据可视化方法和技术" class="headerlink" title="数据可视化方法和技术"></a>数据可视化方法和技术</h2><ul><li><p>图可视化技术</p><ul><li><p>节点链接图</p><p>可以直接反应出网络关系，图的总体结构及其路径</p><p>但对密集图不适用</p></li><li><p>相邻矩阵法</p><p>完全规避边的交叉，非常适用于致密的图，且伸缩性强</p><p>可视化效果比较抽象，难以跟踪路径</p></li></ul></li><li><p>统计图表可视化</p></li><li><p>地理数据可视化</p><ul><li>点数据可视化</li><li>线数据可视化</li><li>区域数据可视化</li></ul></li><li><p>文本可视化</p><p>作用：文本可视化将文本中蕴含的语义特征（词频、逻辑结构、主题聚类、动态演化规律等）直观的展示出来</p></li><li><p>时空数据可视化</p><p>一维二维三维标量场数据可视化</p></li></ul><h2 id="数据可视化工具"><a href="#数据可视化工具" class="headerlink" title="数据可视化工具"></a>数据可视化工具</h2><p>Google Charts，Echarts，D3.js，neo4j bloom，R，Processing 等</p><h1 id="第十一讲-文本处理"><a href="#第十一讲-文本处理" class="headerlink" title="第十一讲 文本处理"></a>第十一讲 文本处理</h1><h2 id="总纲"><a href="#总纲" class="headerlink" title="总纲"></a>总纲</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658ebdc6e4d11.jpg"></p><h2 id="数据获取【网页抓取】"><a href="#数据获取【网页抓取】" class="headerlink" title="数据获取【网页抓取】"></a>数据获取【网页抓取】</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658ebddceae4a.jpg"></p><p>提升性能：异步抓取，DNS预解析</p><p>链接调度：累积式抓取，增量式抓取【搜索引擎的日常抓取】</p><p>重复检测：I-Match算法</p><p>爬虫：robots.txt（友好访问|存放于网站根目录下的ASCII编码的文本文件，它通常告诉网络搜索引擎的漫游器内容是否能被获取）</p><p>恶意爬虫危害：</p><ul><li>增加网站带宽负担</li><li>核心文本被爬取</li><li>注册用户被扫描（一个个验证手机号看是否注册）</li><li>点击欺诈（不知道真实的访问量）</li></ul><h2 id="数据处理【中文分词】"><a href="#数据处理【中文分词】" class="headerlink" title="数据处理【中文分词】"></a>数据处理【中文分词】</h2><p>中文基于单字，中文书面表达方式以汉字作为最小单位的，但词与词之间没有显性的界限标志</p><p>词法分析包含：</p><ol><li>分词</li><li>词性标注（名词，动词，形容词等）</li><li>命名实体识别</li><li>词义消歧</li></ol><p>分词的意义</p><p>正确的机器自动分词是正确的中文信息处理的基础</p><p>分词主要难题</p><ul><li>如何识别未登录词</li><li>如何利用语言学知识</li><li>词语边界歧义处理【分词歧义】</li><li>实时性应用中的效率问题</li></ul><p>分词主要方法</p><table><thead><tr><th></th><th>基于人工规则</th><th>基于统计机器学习</th><th>基于深度学习</th></tr></thead><tbody><tr><td>优点</td><td>简单、可理解、结果可控</td><td>数据驱动，应用广泛</td><td>精度高</td></tr><tr><td>缺点</td><td>规则维护困难，分词精度欠佳</td><td>高质量训练数据获取昂贵，特征工程</td><td>可解释性差，需要海量训练数据</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 大学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据科学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SDU软件学院软件工程考试纲要</title>
      <link href="/2023/12/19/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%80%83%E8%AF%95%E7%BA%B2%E8%A6%81/"/>
      <url>/2023/12/19/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%80%83%E8%AF%95%E7%BA%B2%E8%A6%81/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文档是根据任课老师所给提纲及课件等资料进行整理的，对于名词解释和简答题基本做到了全覆盖。但判断和选择题非常灵活，这份文档就显得不够用了。</p><p>标题后带*号的为次重点</p></blockquote><blockquote><p>复习建议：<br>1.按照老师纲要整理知识点，全文背诵。<br>2.注意对概念的理解，应对选择判断</p></blockquote><h1 id="第一章-软件工程概述"><a href="#第一章-软件工程概述" class="headerlink" title="第一章 软件工程概述"></a>第一章 软件工程概述</h1><h2 id="1-1软件工程（SE）的定义、目的、方法及作用"><a href="#1-1软件工程（SE）的定义、目的、方法及作用" class="headerlink" title="1.1软件工程（SE）的定义、目的、方法及作用"></a>1.1软件工程（SE）的定义、目的、方法及作用</h2><p>定义：在将有关软件开发与应用的概念科学体系化的基础上，研究如何有计划、有效率、 经济地开发和利用能在计算机上正确运行的软件理论和技术工程的方法学，以及一些开发和维护软件的方法、过程、原则等。它是一个系统工程，既有对技术问题的综合分析，也有对开发过程和参与者的管理。</p><p>目的：以计算机科学理论和计算机功能为基础，通过对要解决问题的本质的了解，采用相应的工具和技术，实现设计方案，推出高质量的软件产品。在给定成本、进度的前提下，开发出具有适用性、有效性、可修改性、可靠性、可理解性、可维护性、可重用性、可移植性、可追踪性、可互操作性和满足用户需求的软件产品。追求这些目标有助于提高软件产品的质量和开发效率，减少维护的困难。</p><p>方法：面向对象模式，结构化模式，基于过程的模式等。</p><p>作用：付出较低的开发成本，达到要求的软件功能，取得较好的软件性能，开发的软件易于移植，需要较低的维护费用，能按时完成开发工作，及时交付使用。</p><h2 id="1-2-开发模式"><a href="#1-2-开发模式" class="headerlink" title="1.2*开发模式"></a>1.2*开发模式</h2><p>表示开发软件时特定的方法或哲学。是软件开发的全部过程，活动和任务的结构框架，它能直观的表达的表达软件开发全过程，明确要完成的主要活动，任务和开发策略。</p><h2 id="1-3说明错误、缺陷、失败的含义与联系（并举例）"><a href="#1-3说明错误、缺陷、失败的含义与联系（并举例）" class="headerlink" title="1.3说明错误、缺陷、失败的含义与联系（并举例）"></a>1.3说明错误、缺陷、失败的含义与联系（并举例）</h2><p>错误(error)：是在软件开发过程中人为产生的错误（需求说明中的错误，代码中的错误）。</p><p>缺陷&#x2F;故障(fault)：软件功能实现过程中产生的问题，是错误导致的结果，是软件中一个错误的表现（一个错误可能产生多个故障，静态存在，如代码写错了导致系统无法启动）。</p><p>失效(failure)：相对于系统指定行为的偏离，在运行时系统违背了它应有的行为（在系统交付前或交付后被发现，动态存在，如使用者发现某个计算功能算不出结果）。</p><p>联系：人为原因导致程序错误；该错误编译到系统中导致系统故障；用户使用该系统时，因故障导致失效。故障是系统内部视图，从开发者的角度看待问题；失效是系统外部视图， 从用户角度看到的问题。而且并不是所有的故障会导致失效，只要不执行故障代码，或者不进入某个特定状态，那么故障就不会使代码失效。</p><h2 id="1-4软件质量应从哪几个方面来衡量，论述之"><a href="#1-4软件质量应从哪几个方面来衡量，论述之" class="headerlink" title="1.4软件质量应从哪几个方面来衡量，论述之"></a>1.4软件质量应从哪几个方面来衡量，论述之</h2><p>1.产品(product)的质量</p><p>​用户：从失效的数目和类型等外部特性进行评价，如果软件具有足够的功能，并且易于学习和使用；或者虽然难以学习和使用，但是由于功能值得这些付出，用户就断定软件是高质量的。</p><p>​开发者：从故障的数目和类型等内部特征来作为产品质量的依据。</p><p>2.过程(process)的质量</p><p>​有很多过程都会影响到最终的产品质量，只要有活动出了差错，产品的质量就会受到影响；开发和维护过程的质量与产品的质量是同等重要的。</p><p>3.商业(business)环境背景下的质量</p><p>​（1）技术价值与商业价值的联系与区别：</p><p>​技术价值：技术指标（速度，正确的运行时间，维护成本等）。<br>​商业价值：机构对软件是否与其战略利益相吻合的一种价值评估。<br>​误区：技术质量不会自动转化为商业价值。</p><p>​（2）目标</p><p>​将技术价值和商业价值统一起来，改进过程所带来的商业价值。</p><h2 id="1-5软件系统的系统组成（系统的要素有哪些）"><a href="#1-5软件系统的系统组成（系统的要素有哪些）" class="headerlink" title="1.5软件系统的系统组成（系统的要素有哪些）"></a>1.5软件系统的系统组成（系统的要素有哪些）</h2><p>系统 &#x3D; 对象（实体）+ 活动 + 关系 + 系统边界</p><p>对象：活动中涉及的元素称为对象。</p><p>活动：活动是发生在系统中的某些事情，通常描述为由某个触发器引发的事件，活动通过改变属性把一个事物变成另一个事物。</p><p>关系：是指活动与对象之间的关系。</p><p>系统边界：即系统包含的功能与系统不包含的功能之间的界限。</p><h2 id="1-6现代软件工程大致包含的几个阶段及各个阶段文档"><a href="#1-6现代软件工程大致包含的几个阶段及各个阶段文档" class="headerlink" title="1.6现代软件工程大致包含的几个阶段及各个阶段文档"></a>1.6现代软件工程大致包含的几个阶段及各个阶段文档</h2><ol><li>需求分析：包括问题定义、可行性研究、需求分析【《SRS》即《软件需求规格 说明书》】与复审（所有人）。</li><li>系统设计：包括用户界面的设计【《SAD》即《软件系统结构图》：如何制作软 件】与复审（开发者与客户）。</li><li>程序设计：包括模块功能算法与数据描述设计【相关文档】与复审（开发者）。</li><li>程序实现：包括编程与 debug【源代码和注释】与复审（开发者、码农）。</li><li>单元测试：模块功能测试与性能测试【测试报告】与复审（测试团队）。</li><li>集成测试：按照结构图进行测试【测试报告】与复审（测试团队）。</li><li>系统测试：按《SRS》对系统总体功能进行测试与复审（开发者与客户）。</li><li>系统提交：交付产品【用户手册和操作手册】与复审。</li><li>系统维修：修改软件的过程，为改错或满足新需求【维修报告】与复审（维修团 队）。</li></ol><h2 id="1-7-使现代软件工程实践发生变化的关键因素是什么"><a href="#1-7-使现代软件工程实践发生变化的关键因素是什么" class="headerlink" title="1.7*使现代软件工程实践发生变化的关键因素是什么"></a>1.7*使现代软件工程实践发生变化的关键因素是什么</h2><p>（1）商用产品投入市场时间的紧迫性<br>（2）计算技术在经济中的转变：更低的硬件成本，更高的开发、维护成本<br>（3）功能强大的桌面计算的可用性<br>（4）广泛的局域网和广域网<br>（5）面向对象技术的采用及其有效性<br>（6）使用窗口、图标、菜单和指示器的图形用户界面<br>（7）软件开发瀑布模型的不可预测性</p><h2 id="1-8什么是软件过程？软件过程的重要性是什么？包含几个阶段？"><a href="#1-8什么是软件过程？软件过程的重要性是什么？包含几个阶段？" class="headerlink" title="1.8什么是软件过程？软件过程的重要性是什么？包含几个阶段？"></a>1.8什么是软件过程？软件过程的重要性是什么？包含几个阶段？</h2><p>软件开发活动中的各种组织及规范方法（课件定义）</p><p>软件开发过程描述了软件产品从概念到实现、交付、使用和维护的整个过程，因此，有时把软件开发过程称为软件生命周期。</p><p>（1）它强制活动具有一致性和一定的结构。<br>（2）过程结构允许我们分析、理解、控制和改进组成过程的活动，并以此来指导我们的活动。<br>（3）它使我们获取经验并把经验传授给他人。</p><h2 id="1-9什么是重用、抽象等现代软件工程主要概念？"><a href="#1-9什么是重用、抽象等现代软件工程主要概念？" class="headerlink" title="1.9什么是重用、抽象等现代软件工程主要概念？"></a>1.9什么是重用、抽象等现代软件工程主要概念？</h2><p>抽象(abstraction)：基于某种层次归纳水平的问题描述。它使我们将注意力集中在问题的关键方面而非细节。</p><p>分析、设计方法和符号描述系统：使用标准表示来对程序进行描述。利于交流，利于建模并检查其完整性和一致性，利于 对需求和设计部件进行重用。</p><p>用户界面原型化(prototyping)：建立系统的小型版, 通常具有有限的关键功能,以利于用户评价和选择，证明设计或方法的可行性。</p><p>软件体系结构：定义一组体系结构单元及其相互关系集来描述软件系统。 单元分解的方法</p><p>软件过程：软件开发活动中的各种组织及规范方法。</p><p>重用或复用(reuse)：重复采用以前开发的软件系统中具有共性的部件, 用到新的开发项目中去 (注: 这里的重用绝不仅仅是源代码的重用)。</p><p>测度或度量(measurement)：通用的评价方法和体系，有助于使过程和产品的特定特性更加可见，包括量化描述系统、量化审核系统。</p><p>工具和集成环境：通过框架比较软件工程环境提供的服务，以决定其好坏。工具：由于厂商很少针对整个开发生命周期，因此对于工具的比较集中于小的活动集，例如测试或设计。</p><h1 id="第二章-过程和生命周期的建模"><a href="#第二章-过程和生命周期的建模" class="headerlink" title="第二章 过程和生命周期的建模"></a>第二章 过程和生命周期的建模</h1><h2 id="2-1什么叫过程（生命周期）"><a href="#2-1什么叫过程（生命周期）" class="headerlink" title="2.1什么叫过程（生命周期）"></a>2.1什么叫过程（生命周期）</h2><p>过程是一组有序的任务，它涉及活动、约束和资源使用的一系列步骤，用于产生某种想要的输出。<br>过程不仅仅是步骤，过程是步骤的集合，它将步骤组织起来使人们能够生产满足一系列目标和标准的产品。<br>我们有时也把涉及产品构建的这种过程称为生命周期。软件开发过程描述了软件产品从概念到实现、交付、使用和维护的整个过程，因此，有时把软件开发过程称为软件生命周期。</p><h2 id="2-2什么是软件过程？软件过程的重要性是什么？软件生命周期？"><a href="#2-2什么是软件过程？软件过程的重要性是什么？软件生命周期？" class="headerlink" title="2.2什么是软件过程？软件过程的重要性是什么？软件生命周期？"></a>2.2什么是软件过程？软件过程的重要性是什么？软件生命周期？</h2><p>软件开发活动中产生某种期望结果的一系列有序任务，涉及活动、约束和资源。</p><ol><li><p>通用性，一致性，结构性。一致性和结构性可以使我们知道是否已经做好了工作，还能使别人以同样的方式做工作，因而具有相对通用性。</p></li><li><p>自我指导。总结经验，完善规范，指导新版本</p></li><li><p>过程改进；流程改善 process improvement</p></li></ol><p>软件生命周期：问题定义及规划阶段，需求分析&#x2F;评审阶段，软件设计阶段，软件编码阶段，软件测试阶段，软件运行维护阶段。 1、需求分析2、系统设计3、程序设计4、软件开发5、单元测试6、集成测试7、系统测试8、系统提交9、维护</p><h2 id="2-3瀑布模型及各阶段文档，优缺点"><a href="#2-3瀑布模型及各阶段文档，优缺点" class="headerlink" title="2.3瀑布模型及各阶段文档，优缺点"></a>2.3瀑布模型及各阶段文档，优缺点</h2><p>瀑布模型：瀑布模型线性地安排每一个阶段，将开发阶段描述为从一个开发阶段瀑布般地转换到另外一个阶段，一个开发阶段必须在另一个开发阶段开始之前完成。瀑布模型从一种非常高层的角度描述了开发过程中进行的活动，并且提出了要求开发人员经过的时间序列。</p><p>瀑布模型的各阶段文档：<br>需求分析：《SRS》软件需求规格说明书<br>系统设计：《SAD》系统设计文档<br>程序设计：模块功能算法和数据描述文档<br>编码：源程序和注释<br>单元测试和集成测试：单元测试报告<br>系统测试：系统测试报告<br>验收测试：验收测试报告<br>运行与维护：维护报告</p><p>优点</p><p>（1）它的简单性使得开发人员很容易向不熟悉软件开发的客户作出解释。<br>（2）每一个过程活动都有与其相关联的里程碑和可交付产品，以便于项目经理评估项目 进度。<br>（3）瀑布模型是最基础的模型，很多其他更复杂的模型实际上是在瀑布模型的基础上的润色，如加入反馈循环以及额外的活动。</p><p>缺点</p><p>（1）除了一些理解非常充分的问题之外，实际上软件是通过大量的迭代进行开发的。<br>（2）软件是一个创造的过程, 不是一个制造的过程。软件变动时, 该模型无法处理实际过程中的重复开发问题。<br>（3）文档转换有困难。它说明了每一个活动的产品（例如，需求、设计或代码），但没有揭示一个活动如何把一种制品转化为另外一种制品（例如，从需求文档转化为设计文档）。</p><h2 id="2-4原型的概念与用途"><a href="#2-4原型的概念与用途" class="headerlink" title="2.4原型的概念与用途"></a>2.4原型的概念与用途</h2><p>原型是一种部分开发的产品，用来让用户和开发者共同研究，提出意见，为最终产品定型。原型可以理解为小样，在某一阶段产品定型前先做一些小样，通过对各种样品的评价和分析，并最终为产品定型。</p><p>用途：<br>1.原型化设计可以使开发者更容易地提高软件质量。<br>2.原型化设计可以提供多种解决方案供用户选择。</p><h2 id="2-5论述分阶段（阶段化）开发模型的含义、其基本分类和特点（运行系统和开发系统的概念）"><a href="#2-5论述分阶段（阶段化）开发模型的含义、其基本分类和特点（运行系统和开发系统的概念）" class="headerlink" title="2.5论述分阶段（阶段化）开发模型的含义、其基本分类和特点（运行系统和开发系统的概念）"></a>2.5论述分阶段（阶段化）开发模型的含义、其基本分类和特点（运行系统和开发系统的概念）</h2><p>含义：系统被设计成部分提交, 每次用户只能得到部分功能, 而其他部分处于开发过程中。</p><p>cycle time(循环时间): 软件开发时整理需求文档时间与系统提交时间之差(P55)<br>production system(产品系统): 用户正在使用的版本<br>development system(开发系统): 准备代替现有产品系统的下一个版本</p><p>分类：</p><p>（1）增量开发：系统需求按照功能分成若干子系统，开始建造的版本是规模小的、部分功能的系统，后续版本添加包含新功能的子系统，最后版本是包含全部功能的子系统集。<br>（2）迭代开发：系统开始就提供了整体功能框架，后续版本陆续增强各个子系统，最后版本使各个子系统的功能达到最强。<br>（3）增量式+迭代式结合开发：一个新发布的版本可能包含新功能，并对已有功能做了改进。</p><p>特点：</p><p>（1）即使还缺少某些功能，但在早期的发布中就可以开始培训。<br>（2）可以及早为那些以前从未提供的功能开拓市场。<br>（3）当运行系统出现未预料到的问题时，经常性的发布可以使开发人员能全面、快速地修复这些问题<br>（4）针对不同的发布版本，开发团队将重点放在不同的专业领域技术上。</p><h2 id="2-6螺旋模型的含义、目的、四个象限的任务及四重迭代（四重循环）的含义"><a href="#2-6螺旋模型的含义、目的、四个象限的任务及四重迭代（四重循环）的含义" class="headerlink" title="2.6螺旋模型的含义、目的、四个象限的任务及四重迭代（四重循环）的含义"></a>2.6螺旋模型的含义、目的、四个象限的任务及四重迭代（四重循环）的含义</h2><p>含义：螺旋模型将瀑布模型和快速原型模型结合起来，强调了其他模型所忽视的风险分析，特别适合于大型复杂的系统。</p><p>目的：把开发活动和风险管理结合起来，以将风险减到最小并控制风险。</p><p>螺旋模型每次迭代有四个任务，依次是（四个象限）：计划、目标&#x2F;可选方案、风险评估、开发与测试。</p><p>螺旋模型共有四次迭代，依次是（每个象限的四重循环），依次是操作概念、软件需求、软件设计、开发与测试、系统实现与执行</p><p>每一次迭代都根据需求和约束进行风险分析，以权衡不同选择，并且在确定选择之前，通过原型化验证可行性和期望度。当风险确认之后，项目经理必须决定如何消除或最小化风险。</p><p>&#x2F;&#x2F;在所有的软件开发模型中，你认为哪些过程给予你最大的灵活性以应对需求的变更？<br>阶段开发模型和螺旋模型</p><h2 id="2-7什么是UP，-RUP，进化式迭代等市场流行的过程模型"><a href="#2-7什么是UP，-RUP，进化式迭代等市场流行的过程模型" class="headerlink" title="2.7什么是UP， RUP，进化式迭代等市场流行的过程模型"></a>2.7什么是UP， RUP，进化式迭代等市场流行的过程模型</h2><p>UP模型即统一过程模型，是一种用例驱动的，以基础架构为中心的，迭代式，增量式的软件开发模型。该模型的四个阶段：开始阶段、确立阶段、构建阶段和移交阶段。每个阶段可以进一步划分为多次迭代。该模型的六道核心工序：业务模型工序、需求工序、分析设计工序、实现工序、测试工序和部署工序。</p><p>补充:统一过程（UP）可以用三句话来表达：它是用例驱动的、以基本架构为中心的、迭代式和增量性的软件开发过程框架，它使用对象管理组织（OMG(Object Management Group)）的UML 并与对象管理组织（OMG）的软件过程工程原模型（SPEM（Software Process Engineering Meta-Model ）软件过程工程元模型）等相兼容。</p><p>RUP（Rational Unified Process），是IBM提出的提供支持和包装的UP模型。统一软件开发过程，统一软件过程是一个面向对象且基于网络的程序开发方法论。</p><p>进化式迭代开发（Iterative development）是统一开发过程(RUP)的关键实践。开发被组织成一系列固定的短期小项目。每次迭代都产生经过测试、集成并可执行的局部系统。每次迭代都具有各自的需求分析、设计、实现和测试。随着时间和一次次迭代，系统增量式完善。</p><h1 id="第三章-计划和管理项目"><a href="#第三章-计划和管理项目" class="headerlink" title="第三章 计划和管理项目"></a>第三章 计划和管理项目</h1><h2 id="3-1什么是项目进度？活动？里程碑？项目成本？"><a href="#3-1什么是项目进度？活动？里程碑？项目成本？" class="headerlink" title="3.1什么是项目进度？活动？里程碑？项目成本？"></a>3.1什么是项目进度？活动？里程碑？项目成本？</h2><p>项目进度：名词解释是对特定项目的软件开发周期的刻画。包括对项目阶段、步骤、活动的分解，对各个离散活动的交互关系的描述，以及对各个活动完成时间及整个项目完成时间的初步估算。</p><p>活动：项目的一部分，一般占用项目进度计划中的一段时间</p><p>里程碑（Milestone）指特定的时间点，标志着活动的结束，通常伴随着提交物。（如一般性文档，功能模块的说明，子系统的说明和展示，精确度的说明和展示，可靠性，安全性，性能说明或展示文档）</p><p>项目成本(project costs)：为支持软件开发而购买软件和工具的开支,用于支持需求分析,设计,编码,测试,处理需求变更等等,另外加上工作量开支。</p><h2 id="3-2如何计算软件项目活动图的关键路径？冗余时间？最早和最迟开始时间"><a href="#3-2如何计算软件项目活动图的关键路径？冗余时间？最早和最迟开始时间" class="headerlink" title="3.2如何计算软件项目活动图的关键路径？冗余时间？最早和最迟开始时间"></a>3.2如何计算软件项目活动图的关键路径？冗余时间？最早和最迟开始时间</h2><p>关键路径（Critical Paths）：从起点到终点总花费时间最长的路径，即这个项目的最短完成时间，因为如果这条路径无法完成那么整个项目都不能算完成。所以这条路径上的任务耽误一点都会影响最后项目完 成时间。</p><p>关键路径法（CPM）：时差&#x3D;可用时间-真实时间&#x3D;最晚开始时间-最早开始时间</p><p>冗余时间：在不耽误总体进度的前提下，最早开始工作和最晚开始工作时间的差值。</p><h2 id="3-3-软件团队人员应该具备的能力是什么"><a href="#3-3-软件团队人员应该具备的能力是什么" class="headerlink" title="3.3*软件团队人员应该具备的能力是什么"></a>3.3*软件团队人员应该具备的能力是什么</h2><p>（1）完成工作的能力（2）对工作的兴趣（3）开发类似应用的经验（4）使用类似工具或语言的经验（5）使用类似开发环境的经验（6）使用类似技术的经验（7）培训（8）与其他人交流的能力（9）与其他人共同承担责任的能力（10）管理技能</p><h2 id="3-4软件项目团队组织的基本结构"><a href="#3-4软件项目团队组织的基本结构" class="headerlink" title="3.4软件项目团队组织的基本结构"></a>3.4软件项目团队组织的基本结构</h2><p>主程序员：总体负责系统的设计和开发，其他小组成员向该主程序员汇报，主程序员对每一个决定有最终决策权。主程序员监督所有其他小组成员、设计所有程序、把代码开发分配给其他小组成员。<br>副主程序员（后备程序员）：在必要时替代主程序员。<br>资料员：负责维护所有的项目文档，编译和链接代码，并对提交的所有模块进行初步测试。</p><p>(1) 主程序员负责制（Chief Programmer Team）<br>由一个主程序员负责系统设计和开发，其他的成员向其汇报，主程序员对每一个决定有绝对决策权。<br>优势：使交流最小化迅速做出决定<br>缺点：创造性低；对主程序员要求高，个人主观性强<br>(2) 忘我方法（Egoless Approach）<br>每个成员平等的承担责任，而且过程与个人是分开的；批评是针对产品和结果的，不针 对个人的。<br>一般软件项目的团队组织结构是介于以上两个极端之间的。<br>(3) 项目组织的结构化<br>结构化较强的团队：按时完成任务，单工作比较循规蹈矩，项目普通但是功能完备。适合人员较多，项目稳 定性和一致性高，使用较正规的结构。<br>结构化较弱的团队：不能按时完成任务但是创造性强，涉及大量的不确定性因素时采用较为民主的方法和相关的团队结构</p><h2 id="3-5-专家估算法的大致含义"><a href="#3-5-专家估算法的大致含义" class="headerlink" title="3.5*专家估算法的大致含义"></a>3.5*专家估算法的大致含义</h2><p>很多工作量估算方法依赖于专家的判断。使用专家的知识和经验，对软件项目的工作量进行评估，预测的精确性基于估算者的能力、经验、客观性和洞察力。是对构建整个系统或其子系统所需的工作量做出经验性的猜测。<br>主要有类推法，Delphi技术，Wolwerton模型（该模型受变化和主观性的影响，还受当前数据相关性的影响 ）（x+4y+z）&#x2F;6对个人估算的规范化</p><h2 id="3-6-算式估算法的大致含义"><a href="#3-6-算式估算法的大致含义" class="headerlink" title="3.6*算式估算法的大致含义"></a>3.6*算式估算法的大致含义</h2><p>研究人员已经创建出表示工作量和影响工作量的因素之间关系的模型。这些模型通常用方程式描述，其中工作量是因变量，而其他因素是自变量。大部分模型认为项目规模是方程式中影响最大的因素，表示工作量的方程式是：E &#x3D; (a + bS^c) m(X)<br>其中S是系统规模的估算，而a、b、和c是常量。X是从x1到xn的一个成本因素的向量，m是基于这些因素的一个调整因子。</p><h2 id="3-7试述COCOMO模型的三个阶段基本工作原理或含义"><a href="#3-7试述COCOMO模型的三个阶段基本工作原理或含义" class="headerlink" title="3.7试述COCOMO模型的三个阶段基本工作原理或含义"></a>3.7试述COCOMO模型的三个阶段基本工作原理或含义</h2><p>COCOMO 模型的关键在于针对项目开发的不同阶段来设置工作量的衡量标准，逐步细化， 逐渐准确。E &#x3D; bSc m(X)</p><ul><li>在阶段一，项目通常构建原型以解决包含用户界面、软件和系统交互、性能和技术成熟 性等方面在内的高风险问题。这时，人们对正在创建的最终产品可能的规模知之甚少，因此COCOMOⅡ用应用点来估算规模。</li><li>在阶段二，即早期设计阶段，已经决定将项目开发向前推进，但是设计人员必须研究几种可选的体系结构和操作的概念。同样，仍然没有足够的信息支持准确的工作量和工期估算， 但是远比第一阶段知道的信息要多。在阶段二，COCOMOⅡ使用功能点对规模进行测量。</li><li>在阶段三，即后体系结构阶段，开发已经开始，而且已经知道了更多的信息。在这个阶 段，可以根据功能点或代码行来进行规模估算，而且可以较为轻松地估算很多成本因素。</li></ul><h2 id="3-8什么是软件风险？-了解主要风险管理活动？有几种降低风险的策略？"><a href="#3-8什么是软件风险？-了解主要风险管理活动？有几种降低风险的策略？" class="headerlink" title="3.8什么是软件风险？ 了解主要风险管理活动？有几种降低风险的策略？"></a>3.8什么是软件风险？ 了解主要风险管理活动？有几种降低风险的策略？</h2><p>概念：软件生产过程中不希望看到的，有负面结果的事件。<br>方面：风险损失，风险概率（相乘为风险暴露Risk Exposure)，即数学期望）</p><p>风险管理活动：<br>风险评价：风险识别，风险分析，风险优先级分配<br>风险控制：风险降低，风险管理计划，风险化解。</p><p>降低风险的策略：<br>避免风险（Avoiding the risk）：改变功能和性能需求，使风险没机会发生。比如用 C 语言的程序有内存泄漏的风险改用 Java，避免风险。<br>转移风险（Transferring the risk）：通过把风险分配到其他系统中，或者购买保险以便在风险成为事实时弥补经济上的损失。<br>假设风险（Assuming the risk）：用项目资源，接受并控制风险。比如在开发时主动有意识地进行测试。</p><h2 id="3-9弄懂活动图基本原理，找出关键路径。"><a href="#3-9弄懂活动图基本原理，找出关键路径。" class="headerlink" title="3.9弄懂活动图基本原理，找出关键路径。"></a>3.9弄懂活动图基本原理，找出关键路径。</h2><h1 id="第四章-获取需求"><a href="#第四章-获取需求" class="headerlink" title="第四章 获取需求"></a>第四章 获取需求</h1><h2 id="4-1需求的含义是什么"><a href="#4-1需求的含义是什么" class="headerlink" title="4.1需求的含义是什么"></a>4.1需求的含义是什么</h2><p>需求：对来自用户的关于软件系统的期望行为的综合描述，涉及系统的对象、状态、约束、功能等。</p><h2 id="4-2需求阶段作为一个工程，其确定需求的过程是什么？"><a href="#4-2需求阶段作为一个工程，其确定需求的过程是什么？" class="headerlink" title="4.2需求阶段作为一个工程，其确定需求的过程是什么？"></a>4.2需求阶段作为一个工程，其确定需求的过程是什么？</h2><ol><li>原始需求获取：客户给出的需求</li><li>问题分析：理解需求并通过建模或模型化方式进行描述</li><li>规格说明草稿：利用符号描述系统将定义规范化表示</li><li>需求核准：开发人员与客户进行核准</li><li>软件规格说明（SRS）</li></ol><h2 id="4-3举例说明获取需求时，若有冲突发生时，如何考虑根据优先级进行需求分类"><a href="#4-3举例说明获取需求时，若有冲突发生时，如何考虑根据优先级进行需求分类" class="headerlink" title="4.3举例说明获取需求时，若有冲突发生时，如何考虑根据优先级进行需求分类"></a>4.3举例说明获取需求时，若有冲突发生时，如何考虑根据优先级进行需求分类</h2><p>请求客户对需求进行优先级划分通常是有用的，这可以迫使客户思考提议的服务或特征中哪些是最重要的。<br>一种大致的优先计划分方案可能将需求分为3类：<br>（1）必须要满足的需求<br>（2）非常值得做但是不是必须的需求<br>（3）可选的需求（可做可不做）</p><p>举例：信用卡记账系统必须能够列出最近的费用，将他们加起来并要求在某个日期前支付，这是必须的需求。但是，该记账系统也可能按照购买类型区分费用，以帮助消费者理解购买的模式，这是值得要的需求。最后，记账系统可能要求用黑色来打印贷方账目，用红颜色打印借方账目，这用需求是有用的，但它是可选的需求。</p><p>按照类型对需求进行优先级的分类，能够帮助所有相关人员理解自己到底需要什么。当软件开发项目受到时间或资源的限制时，如果系统的成本太高或者开发的时间太长，就可以去掉可选需求，并对值得要的需求进行分析，考虑是去掉还是延期。还可解决与质量需求之间的矛盾。</p><h2 id="4-4-如何使需求变得可测试"><a href="#4-4-如何使需求变得可测试" class="headerlink" title="4.4*如何使需求变得可测试"></a>4.4*如何使需求变得可测试</h2><p>（1）指定每个副词和形容词的定量描述，这样限定词的含义就清楚、明确了<br>（2）用特定实体的名称替换代名词<br>（3）要确保在需求文档的某个地方，正确地定义每个名词。</p><h2 id="4-5需求文档分为哪两类？"><a href="#4-5需求文档分为哪两类？" class="headerlink" title="4.5需求文档分为哪两类？"></a>4.5需求文档分为哪两类？</h2><p>(1) 需求定义: 完整罗列了客户期望的需求</p><p>(2) 需求规格说明（SRS）: 将需求重述为关于要构建的系统将如何运转的规格说明。</p><h2 id="4-6什么是功能性需求和非功能性需求-质量需求"><a href="#4-6什么是功能性需求和非功能性需求-质量需求" class="headerlink" title="4.6什么是功能性需求和非功能性需求&#x2F;质量需求"></a>4.6什么是功能性需求和非功能性需求&#x2F;质量需求</h2><p>功能需求：描述系统内部功能或系统与外部功能的交互作用，涉及系统输入应对、实体状态变化、输出结果、设计约束、过程约束等。根据要求的活动来描述需求的行为。（功能需求定义问题解决方案空间的边界）</p><p>非功能需求（质量需求）：描述软件方案必须具备的某些质量特征，例如系统性能、安全性、快速的响应时间、易使用性、高可靠性或低维护代价等。</p><h2 id="4-7什么是设计约束和过程约束？如何区分？"><a href="#4-7什么是设计约束和过程约束？如何区分？" class="headerlink" title="4.7什么是设计约束和过程约束？如何区分？"></a>4.7什么是设计约束和过程约束？如何区分？</h2><p>设计约束：已经做出的设计决策或限制问题解决方案集的设计决策。涵盖物理环境、接口、用户等方面。<br>物理环境：对环境或设备的限制等（安装及环境要求等）<br>接口：涉及输入输出的限制或约束条件. (输入格式预定等)<br>用户：使用者的基本情况（限定几种类型的用户）</p><p>过程约束：对用于构建系统的技术和资源的限制，涵盖资源、文档、标准等方面。<br>资源 ：材料、人员技能或其它。<br>文档 ：类型、数量或其它。（涉及其针对性及要求等）<br>标准 ：比如阅读文档时的用户指派标准。<br>其他 ：什么原因会导致从工资单列表中删除某雇员？</p><h2 id="4-8-需求的特征："><a href="#4-8-需求的特征：" class="headerlink" title="4.8*需求的特征："></a>4.8*需求的特征：</h2><p>（1）正确性（2）一致性（3）无二义性（确定性）（4）完备性（5）可行性（6）相关性（7）可测试性（8）可跟踪性</p><h2 id="4-9-在原型化需求方面，什么是抛弃式原型，什么是进化式原型？"><a href="#4-9-在原型化需求方面，什么是抛弃式原型，什么是进化式原型？" class="headerlink" title="4.9*在原型化需求方面，什么是抛弃式原型，什么是进化式原型？"></a>4.9*在原型化需求方面，什么是抛弃式原型，什么是进化式原型？</h2><p>原型化需求的目的：A: 有的需求难以用文字和符号说明,而原型化的过程可帮助我们找到“好的视觉和感觉”B：对非功能性需求，可以评价性能和效率</p><p>抛弃式原型：仅用于了解问题、探索可行性，并不打算用来作为将来实际提交系统的一部分，而是用完扔掉<br>进化式原型：用于了解问题，并作为将来准备提交的系统的一部分<br>这两种技术有时都称为快速原型化，因为它们都是为了回答需求的问题而构建软件。</p><h2 id="4-10了解DFD图-数据流图-的构成及画法。"><a href="#4-10了解DFD图-数据流图-的构成及画法。" class="headerlink" title="4.10了解DFD图 数据流图 的构成及画法。"></a>4.10了解DFD图 数据流图 的构成及画法。</h2><p>数据流图：描述数据进入、转换、离开系统，重点在于数据流，而不是控制流。<br>组成数据流图的四种成分是（源点或终点）、（数据流）、（处理）、（数据存储）<br>描述数据如何流入系统，如何进行转换，以及如何离开系统。<br>加工：○<br>数据流向：→<br>数据集合：&#x3D;<br>外部项：□</p><h1 id="第五章-设计体系结构"><a href="#第五章-设计体系结构" class="headerlink" title="第五章 设计体系结构"></a>第五章 设计体系结构</h1><h2 id="5-1什么是软件体系结构？设计模式？设计公约？设计？"><a href="#5-1什么是软件体系结构？设计模式？设计公约？设计？" class="headerlink" title="5.1什么是软件体系结构？设计模式？设计公约？设计？"></a>5.1什么是软件体系结构？设计模式？设计公约？设计？</h2><p>体系结构 Architecture:一种软件解决方案，用于解释如何将系统分解为单元， 以及单元如何相互关联，还包括这些单元的所有外部特性。</p><p>设计模式 design pattern:一种针对单个软件模块或少量模块而给出的一般性解决方案，它提供较低层次的设计决策。它是一个共同的设计结构的关键方面，包括对象和实例， 角色和协作，责任分配</p><p>设计公约 Design Convention:一系列设计决策和建议的集合，用于提高系统某方面的设计质量。当一种设计公约发展成熟时，将会被封装成设计模式或体系结构风格，最后可 能被内嵌为一种程序语言结构</p><p>设计 Design:将需求中的问题描述转变成软件解决方案的创造性过程。概念设计（告诉客户系统将做什么，软件结构和功能）、技术设计（告诉程序员系统将如何运作，软件功能和接口的实现方法）</p><h2 id="5-2-什么是概念设计？什么是技术设计？"><a href="#5-2-什么是概念设计？什么是技术设计？" class="headerlink" title="5.2*什么是概念设计？什么是技术设计？"></a>5.2*什么是概念设计？什么是技术设计？</h2><p>概念设计：确切地告诉客户系统要做什么<br>技术设计：一旦客户认可概念设计，系统构建人员就将概念设计转换为更为详细的文档，即技术设计，技术设计确切的告诉开发人员系统将如何运转。<br>概念设计强调的是系统功能，而技术设计描述的是系统将要采取的方式。</p><h2 id="5-3软件设计过程模型的几个阶段？"><a href="#5-3软件设计过程模型的几个阶段？" class="headerlink" title="5.3软件设计过程模型的几个阶段？"></a>5.3软件设计过程模型的几个阶段？</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/24/6587e89b393cf.png"></p><p>(1) Modeling 初始建模:尝试可能的分解，根据需求描述的系统的关键特性等确定软件体系结构风格<br>(2) Analysis 分析:分析初步的体系结构，主要关注软件系统的质量属性性能、安全性、可靠性等、各种约束等等。关注系统级别决策<br>(3) Documentation 文档化:确定各个不同的模型视图。<br>(4) Review 复审:检查文档是否满足了所有需求。<br>(5) final output输出文档: SAD:Software Architecture Document 软件体系结构文档， 用来和开发团队中其他人员交流系统级别设计决策的有力工具。</p><h2 id="5-4-三种设计层及其关系"><a href="#5-4-三种设计层及其关系" class="headerlink" title="5.4*三种设计层及其关系"></a>5.4*三种设计层及其关系</h2><p>设计分三层：体系结构、代码设计和可执行设计<br>（1）体系结构将需求格式说明中确定的系统能力与实现这些能力的系统构件关联起来。<br>（2）代码设计包含算法和数据结构<br>（3）可执行设计在比代码设计的层次还要低的静态层次处理代码设计，讨论内存分配、数据格式、位模式等</p><p>关系：自顶向下设计有益的：首先设计体系结构，然后进行代码设计，最后是可执行设计</p><h2 id="5-5-什么是模块化？什么是抽象？"><a href="#5-5-什么是模块化？什么是抽象？" class="headerlink" title="5.5*什么是模块化？什么是抽象？"></a>5.5*什么是模块化？什么是抽象？</h2><p>模块化：在模块化的设计中，构件清晰地定义了输入和输出，设计目标明确，功能独立，可以做独立测试。</p><p>抽象：对细节的隐藏称为抽象，是基于某种归纳水平的问题描述，是我们集中于问题的关系。</p><h2 id="5-6论述设计用户界面应考虑的问题。"><a href="#5-6论述设计用户界面应考虑的问题。" class="headerlink" title="5.6论述设计用户界面应考虑的问题。"></a>5.6论述设计用户界面应考虑的问题。</h2><p>(1)设计界面要注意解决的要素：<br>①隐喻：可识别和学习的基本术语、图像和概念等<br>②思维模型：数据、功能、任务的组织与表示<br>③模型的导航规则：怎样在数据、功能、活动和角色中移动及切换<br>④外观：系统向用户传输信息的外观特征<br>⑤感觉：向用户提供有吸引力的体验的交互技术</p><p>(2) 文化问题：需要考虑使用系统的用户的信仰、价值观、道德规范、传统、风俗和传说。两种解决方法：①使用国际设计&#x2F;无偏见设计，排除特定的文化参考或偏见②采用定制界面，使不同用户看到额界面</p><p>(3) 用户偏爱：为具有不同偏好的人选择备选界面</p><h2 id="5-7—-模块独立性—-耦合与内聚的概念及各个层次划分？"><a href="#5-7—-模块独立性—-耦合与内聚的概念及各个层次划分？" class="headerlink" title="5.7—-模块独立性—-耦合与内聚的概念及各个层次划分？"></a>5.7—-模块独立性—-耦合与内聚的概念及各个层次划分？</h2><p>模块的独立性取决于两个部分：内聚和耦合，我们追求的是高内聚低耦合。<br>内聚是软件内部组成成分的关联程度。<br>耦合指的是两个软件间的关联程度。</p><p><strong>耦合度</strong>是指两个软件之间的相互关联程度，耦合程度取决于模块之间的依赖关系的多少，可以划分为紧密耦合、松散耦合和非耦合。模块之间的依赖关系有：一个模块引用另一个模块、模块间传递数据量、某个模块控制其他模块的数量。为了使模块可以独立设计和修改，应尽可能减少耦合度。模块耦合有六个级别，从高到底依次为：</p><p>(1) 内容耦合 content：一个模块实际上修改了另一个模块，被修改的模块完全依赖于修改他的模块。可能的情况有：一个模块修改另一个模块内部数据项或代码，或分支转移 到另一个模块。如 goto 语句<br>(2) 公共耦合 common：不同模块可以从公共数据存储区来访问和修改数据。<br>(3) 控制耦合 control：一个模块通过传递参数或返回代码来控制另一个模块的活动<br>(4) 标记&#x2F;特征耦合 stamp：使用一个复杂的数据结构进行模块间传递消息，并且传递的是该数据结构本身。比如将一个数组传递给另一个模块，数组仅用于计算而非控制<br>(5) 数据耦合 data：模块间传递的是数据值，这是最受欢迎的一种耦合。如一个数值被当做参数传递给另一个模块，这个数值在另一个模块中只会参与计算而非控制。<br>(6) 非耦合 uncoupled：模块相互之间没有信息传递，如两个毫无关系的方法，但是一般完全没有耦合是不现实的。</p><p><strong>内聚度</strong>是指模块内部各组成成分（如数据、功能、内部模块）的关联程度，内聚度越高， 模块各成分间相互联系越密切，与总目标越相关。内聚分为低内聚和高内聚。</p><p>(1) 偶然内聚 coincidental：模块各部分不相关，只为方便或偶然性原因放入同一模块。比如强行放入一个类中没有任何关系的方法<br>(2) 逻辑内聚 logical：模块中各部分只通过代码的逻辑结构相关联， 会共享程序状态和代码结构，但相对于数据、功能和目标的内聚比较弱。比如因为有相同的某一个计算步骤而放在 一起的两个没有关系的计算。<br>(3) 时间内聚 temporal：部件各部分要求在同一时间完成或被同一任务使用而形成联系。比如初始化模块中需要完成变量赋值、打开某文件等工作。<br>(4) 过程内聚 procedurally：要求必须按照某个确定的顺序执行一系列功能，模块内功能组合在一起只是为了确保这个顺序。其与时间性内聚相比优点在于其功能总是涉及相关 活动和针对相关目标，如写数据-&gt;检查数据-&gt;操作数据这一过程<br>(5) 通讯内聚 communicational：各部分访问和操作同一数据集，如将来自于同一传感器的所有不相干数据取出这一模块<br>(6) 顺序内聚 sequential：各部分有输入输出关系，操作统一数据集，并且操作有顺序<br>(7) 功能内聚 functional：理想情况，各部分组成单一功能，且每个处理元素对功能都是必须的，每个元素执行且只执行设计功能，如一个简单的输出程序<br>(8) 信息内聚 information：功能内聚的基础上调整为数据抽象化和基于对象的设计</p><h2 id="5-8软件过程中复审的概念，设计复审的重要性。"><a href="#5-8软件过程中复审的概念，设计复审的重要性。" class="headerlink" title="5.8软件过程中复审的概念，设计复审的重要性。"></a>5.8软件过程中复审的概念，设计复审的重要性。</h2><p>复审定义：检查文档是否满足所有功能及质量需求。</p><p>两种设计检验的方法：<br>(1) 验证verification：确保设计遵循良好的设计原则，设计文档满足阅读者的需要。验证检查某样东西是否符合之前已定好的标准，就是要用数据证明我们是不是在正确的制造产品。更注重过程正确性，强调做得正确<br>(2)确认validation：确认设计能够满足用户需求。确认检查软件在最终的运行环境上是否达到预期的目标，就是要用数据证明我们是不是制造了正确的产品。更注重结果正确 性，强调做的东西正确。<br>(3)验证更多是从开发商角度来做评审、测试来验证产品需求、架构设计等方面是否和用户要求一致，确认更多是从用户的角度或者可以是模拟用户角度来验证产品是否和自己想 要的一致。</p><p>重要性：<br>(1) 复审中批评和讨论是“忘我”的，能将开发人员更好地团结在一起，提倡并增强了成员之间的交流。<br>(2) 在评审过程中故障的改正还比较容易，成本还不高，在这时候发现故障和问题会使每一个人受益。</p><p>概念设计复审：与客户和用户一起审查概念设计<br>技术设计复审：向开发者介绍技术设计<br>程序设计复审：程序员在实施前获得对其技术设计的反馈<br>重要性：加强和鼓励在项目中使用一种共同的编码风格，发现自动测试发现不了的错误</p><h1 id="第六章-面向对象"><a href="#第六章-面向对象" class="headerlink" title="第六章 面向对象"></a>第六章 面向对象</h1><p>&#x2F;&#x2F;什么是面向对象？<br>面向对象是一种软件开发方法，它将问题和问题的解决方案组织为离散对象的集合，数据结构和行为都包含在对象的表示中。</p><p>&#x2F;&#x2F;面向对象有什么特征？如何使用高级语言实现这些基本&#x2F;&#x2F; 特征？<br>（1）标识（2）抽象（3）分类（4）封装（5）继承（6）多态（7）持久性</p><p>&#x2F;&#x2F; 掌握并使用高级语言的OO基本编程方法和技巧。</p><h2 id="6-1什么是设计模式？"><a href="#6-1什么是设计模式？" class="headerlink" title="6.1什么是设计模式？"></a>6.1什么是设计模式？</h2><p>设计模式是一套被反复使用的（多数人知晓并经过分类编目的）代码设计经验的总结，使用设计模式目的是为了可重用代码、让代码更容易被他人理解并且保证软件质量。<br>（软件开发方法：一种针对软件模块给出的一般性解决方案，提供较低层次的设计决策。）</p><p>面向对象设计模式：简单工厂模式、工厂方法模式、抽象工程模式、观察者模式、单例模式、桥梁模式、责任链模式、适配器模式、代理模式、策略模式</p><h2 id="6-2了解OO设计的基本原则？"><a href="#6-2了解OO设计的基本原则？" class="headerlink" title="6.2了解OO设计的基本原则？"></a>6.2了解OO设计的基本原则？</h2><p>单一职责原则（SRP）、重用原则、开闭原则（OCP）、里氏替换原则（LSP）、依赖倒置原则（DIP）、接口分隔原则（ISP）、迪米特法则</p><h2 id="6-3了解OO开发有何优势？"><a href="#6-3了解OO开发有何优势？" class="headerlink" title="6.3了解OO开发有何优势？"></a>6.3了解OO开发有何优势？</h2><p>（1）语言的一致性。采用相同的语义结构（类、对象、接口、属性、行为）描述问题和解决方案<br>（2）过程的一致性。全开发过程的一致性：从需求分析和定义、高层设计、底层设计到编码和测试等，所有的过程都采用相同的语义结构。</p><h2 id="6-4OO开发过程有几个步骤？"><a href="#6-4OO开发过程有几个步骤？" class="headerlink" title="6.4OO开发过程有几个步骤？"></a>6.4OO开发过程有几个步骤？</h2><p>OO 需求分析和定义+OO 高层设计+OO 底层设计+OOP+OO<br>测试面向对象需求分析、面向对象高层设计、面向对象底层设计、面向对象编程、面向对象测试。</p><h2 id="6-5掌握用例图的组成和画法，用例的几个要素的含义"><a href="#6-5掌握用例图的组成和画法，用例的几个要素的含义" class="headerlink" title="6.5掌握用例图的组成和画法，用例的几个要素的含义"></a>6.5掌握用例图的组成和画法，用例的几个要素的含义</h2><p>用例图：表示一个用户、外部系统或其他实体和在开发系统的关系</p><p>用例：描述系统提供的特定功能，用椭圆表示（画法：○）<br>执行者：和系统交互的实体（用户、设备或其他），用小人表示（画法：小人）<br>包含：对已定义用例的复用，用以提取公共行为，用带箭头的实线表示（画法：→）<br>扩展：对一个用例的扩展使用，以说明一个不同的或更深入的观点（画法：→ 下面加个extends）</p><h2 id="6-6用例图、类图等针对面向对象的项目开发的意义是什么？"><a href="#6-6用例图、类图等针对面向对象的项目开发的意义是什么？" class="headerlink" title="6.6用例图、类图等针对面向对象的项目开发的意义是什么？"></a>6.6用例图、类图等针对面向对象的项目开发的意义是什么？</h2><p>对功能的完整描述；便于用户、设计者、测试者之间的交流；是系统分析中更多正是建模的基础。<br>用例：描述了应该执行或展示的特定功能<br>用例图：通过建立用户、外部项、其他实体的对话模型，而对系统将要完成的功能进行描述或刻画。<br>这些表示法每种都显现了系统的某个方面，因此相应地，这种表达也提供了对于问题或解决方案的详细描述。</p><h2 id="6-7熟悉类图中各个类之间的基本关系分类及其含义。-状态图的含义及用途。"><a href="#6-7熟悉类图中各个类之间的基本关系分类及其含义。-状态图的含义及用途。" class="headerlink" title="6.7熟悉类图中各个类之间的基本关系分类及其含义。 &#x2F;&#x2F;状态图的含义及用途。"></a>6.7熟悉类图中各个类之间的基本关系分类及其含义。 &#x2F;&#x2F;状态图的含义及用途。</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/24/6587ebe080e0f.png"></p><p>泛化：在一个继承关系中，超类泛化子类。<br>关联：两个类一起出现，并且它们之间的关系必须保持一段时间。<br>聚合：一个类是另外一个类的一部分。松散的部分与整体的关系。聚合关系中的成员对象是整体对象的一部分，但是成员对象可以脱离整体对象存在（此时不会影响整体对象的定义，<br>组装：强的部分与整体的关系。组合关系中整体对象可以控制成员对象的生命周期，一旦整体对象不存在，成员对象也将不存在，两者是共生关系。<br>依赖：一个项的定义发生改变，则会引起另外一个项的改变变化。</p><h2 id="6-8熟悉用例图、类图、状态图等的组成和画法"><a href="#6-8熟悉用例图、类图、状态图等的组成和画法" class="headerlink" title="6.8熟悉用例图、类图、状态图等的组成和画法"></a>6.8熟悉用例图、类图、状态图等的组成和画法</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/24/6587ec652511c.png"></p><p>类图的结构<br>类名：定义一个类<br>属性：用名称、类型、初始值来描述它<br>操作：用名称、参数列表、返回类型来描述它</p><p>类图中各个类之间的基本关系以及画法<br>继承：直线 + 空心三角箭头，子类指向超类<br>包含：直线 + 折线箭头，指向被包含的类（可能是双向的甚至指向本身）<br>聚合（成员对象可以脱离整体对象存在）：在包含箭头的尾部加一个空心菱形<br>组合（整体对象不存在时，成员对象也会消失）：在包含箭头的尾部加一个实心菱形<br>依赖（某个类的方法使用另一个类的对象作为参数）：虚线 + 折线箭头<br>接口实现：虚线 + 空心三角，类指向接口</p><h2 id="6-9了解UML其他图示结构的基本用途"><a href="#6-9了解UML其他图示结构的基本用途" class="headerlink" title="6.9了解UML其他图示结构的基本用途"></a>6.9了解UML其他图示结构的基本用途</h2><p>UML 图示结构的基本用途<br>需求过程：<br>工作流程图：建立对象模型——概念类图<br>对象图：解释每一个对象<br>活动图：当一个对象的值发生变化时，显示系统中可能发生的所有活动<br>状态图：显示一个对象可以采取的所有状态<br>顺序图：显示信息如何从一个对象流向另一个对象，使需求中的事件的非正式描述正规化<br>协作图：使用对象和序列信息来显示对象之间的事件流<br>组件图：反映最终的系统模块和相互依存关系<br>状态图：寻找主要的状态、确定状态之间的转换，细化状态内的活动与转换，用复合状态来展开细节。</p><p>用例图：用函数定义类<br>执行者：可能使用这些用例的人或外部程序。<br>用例：对系统提供的功能（或称系统的用途）的一种描述。</p><p>类图：描述了系统中的类及其相互之间的各种关系，其本质反映了系统中包含的各种对 象的类型及对象间的静态关系（关联、子类型等关系）<br>包图：显示类是如何被划分为模型的。包图也存在类图里面的继承、引用等依赖关系，也包含接口，接口与包之间用带 小圆圈的实线相连。<br>序列图：序列图中的对象可以是并发执行的，每一个对象有自己运行的线程控制着。这时，需 要通过激活、异步消息、同步控制和活动对象来表示。序列图有两种，一种是描述特定对象 之间生存期中消息通信的所有情节，称作一般序列图；一种是描述消息通信的个别情节的实 例序列图，如果需要描述所有的情节，则需要多个实例序列图。<br>部署图：部署图描述了系统在运行时的物理结构、配置和关系，涉及处理器、设备、通讯 等硬件单元和软件部件。部署图的描述是基于代表硬件单元的节点之上的。</p><h1 id="第七章-编写程序"><a href="#第七章-编写程序" class="headerlink" title="第七章 编写程序"></a>第七章 编写程序</h1><h2 id="7-1-为什么说编码工作是纷繁复杂甚至令人气馁？"><a href="#7-1-为什么说编码工作是纷繁复杂甚至令人气馁？" class="headerlink" title="7.1*为什么说编码工作是纷繁复杂甚至令人气馁？"></a>7.1*为什么说编码工作是纷繁复杂甚至令人气馁？</h2><p>（1）设计人员可能没有处理平台和编程环境的所有特性。易于用图表描述的结构和关系并不是总能够直截了当的编写成代码<br>（2）我们必须以这样一种方式编写代码：不仅要在再次使用代码进行测试的时候便于自己理解，而且当系统随着时间演化时，也便于他人理解<br>（3）在创建易于复用的代码的同时，还必须利用这些特征：设计的组织结构、数据结构、编程语言的概念。</p><h2 id="7-2一般性的编程原则应该从哪三个方面考虑？"><a href="#7-2一般性的编程原则应该从哪三个方面考虑？" class="headerlink" title="7.2一般性的编程原则应该从哪三个方面考虑？"></a>7.2一般性的编程原则应该从哪三个方面考虑？</h2><p>（1）控制结构（程序如何传递数据）：当设计转变成代码时，我们希望保留组件的控制结构，在隐含调用的面向对象设计中，控制是基于系统状态和变量而变化的。<br>（2）算法（程序如何处理数据）：在编写代码时，程序设计通常会制定一类算法，用于编写组件。<br>（3）数据结构（程序如何储存数据）：编写程序时，应该安排数据的格式并进行存储，这样的数据管理和操作才能简明易懂。</p><h2 id="7-3-论述编码阶段实现某种算法时所涉及的问题。"><a href="#7-3-论述编码阶段实现某种算法时所涉及的问题。" class="headerlink" title="7.3*论述编码阶段实现某种算法时所涉及的问题。"></a>7.3*论述编码阶段实现某种算法时所涉及的问题。</h2><p>（1）编写更快代码的代价。可能会是代码更加复杂，从而要花费更多的时间编写代码<br>（2）测试代码的时间代价。代码的复杂度要求有更多的测试用例或测试数据<br>（3）用户理解代码的时间代价。<br>（4）需要修改代码时，修改代码的时间代价。</p><h2 id="7-4在编写程序内部文档时，除了HCB外，还应添加什么注释信息？注意什么？"><a href="#7-4在编写程序内部文档时，除了HCB外，还应添加什么注释信息？注意什么？" class="headerlink" title="7.4在编写程序内部文档时，除了HCB外，还应添加什么注释信息？注意什么？"></a>7.4在编写程序内部文档时，除了HCB外，还应添加什么注释信息？注意什么？</h2><p>需要添加其他程序注释<br>（1）解释性注释：本段源代码是在做什么的注释。<br>（2）分解性注释：通过注释将代码分解成多个段。<br>（3）版本注释：随着时间进行修改的记录。</p><p>注意的问题：<br>1、分段注释<br>2、注释和代码要一并更改。<br>3、注释要有意义。<br>4、一边写代码一边写注释，不要写完代码回过头来添加注释。</p><p>内部文档：<br>（1）头注释块（header comment block，HCB）<br>将一组注释信息放在每个构件的开始部分，包含构件名，作者，配置在整个系统设计的哪个部分上，何时编写和修改的，为什么要有该构件，构件是如何使用数据结构，算法和控制的。<br>（2）其他程序注释包含：<br>a. 可以对程序正在做什么提供逐行的解释。<br>b. 将代码分解成表示主要活动的段，每个活动再分解成更小的步骤。<br>c. 随着时间进行修改的记录。<br>（3）有意义的变量名和语句标记<br>命名时尽量用有意义的变量名进行命名<br>（4）安排格式以增强理解<br>注意缩进和间隔来反映基本的控制结构。</p><h2 id="7-5敏捷方法的大致思想？"><a href="#7-5敏捷方法的大致思想？" class="headerlink" title="7.5敏捷方法的大致思想？"></a>7.5敏捷方法的大致思想？</h2><p>含义：以人为核心、迭代、循序渐进。在敏捷开发中，软件项目的构建被切分成多个子项目，各个子项目的成果都经过测试，具备集成和可运行的特征。<br>敏捷宣言四条原则：个体和交互的价值胜过过程和工具（个人的卓越创意），可以工作的软件胜过面面俱到的文档（文档非软件），客户合作胜过合同谈判，响应变化胜过遵循计划。<br>上述四条原则反映了敏捷方法的软件过程倾向性<br>特点：（1）规则游戏（2）小的发布（3）隐喻（4）简单设计（5）首先编写测试（6）重构（7）对编程（8）集体所有权（9）持续集成（10）可以忍受的步伐（11）在现场的客户（12）代码标准<br>目标：通过尽可能早地、持续地交付有价值的软件使客户满意。</p><h2 id="7-6什么是极限编程（Extreme-Programming，XP）？"><a href="#7-6什么是极限编程（Extreme-Programming，XP）？" class="headerlink" title="7.6什么是极限编程（Extreme Programming，ＸＰ）？"></a>7.6什么是极限编程（Extreme Programming，ＸＰ）？</h2><p>极限编程是敏捷过程的一种具体形式，提供敏捷方法最一般原则的指导方针。<br>四个变量：成本、时间、质量和范围，通过研究变量之间的相互作用，将项目开发分析的更加透彻，成功讲述一个项目成功的原则<br>XP的支持者强调敏捷方法的4个特性（准则）：交流、简单性、勇气以及反馈。<br>交流是指客户与开发人员之间持续地交换看法；简单性激励开发人员选择最简单的设计或实现来处理客户的需要；勇气体现在今早地和经常交付功能的承诺；在软件开发过程中的各种活动中，都包含反馈循环。例如，程序员一起工作，针对实现设计的最佳方式，相互提供反馈；客户和程序员一起工作时，以完成计划的任务。</p><h2 id="7-7什么是结对编程-Pair-Programming-？"><a href="#7-7什么是结对编程-Pair-Programming-？" class="headerlink" title="7.7什么是结对编程(Pair Programming)？"></a>7.7什么是结对编程(Pair Programming)？</h2><p>结对编程属于主要的敏捷开发方法，开发方式是两个程序员共同开发程序，且角色分工明确：一个负责编写程序，另一个负责复审和测试，两个人定期交换角色。<br>优点：提高生产率和质量，但证据不充分，模棱两可<br>缺点：会抑制问题求解的基本步骤，扰乱对问题的关注</p><h1 id="第八章-测试程序"><a href="#第八章-测试程序" class="headerlink" title="第八章 测试程序"></a>第八章 测试程序</h1><h2 id="8-1了解产生软件缺陷的原因？"><a href="#8-1了解产生软件缺陷的原因？" class="headerlink" title="8.1了解产生软件缺陷的原因？"></a>8.1了解产生软件缺陷的原因？</h2><p>故障：由错误（error）引起的系统内在问题。</p><p>(1)软件本身，系统处理大量的状态，复杂的公式，活动，算法等；<br>(2)客户不清晰的需求；<br>(3)其他原因，如项目的规模，众多的参与者导致的复杂性。</p><h2 id="8-2-将软件缺陷进行分类的理由？"><a href="#8-2-将软件缺陷进行分类的理由？" class="headerlink" title="8.2*将软件缺陷进行分类的理由？"></a>8.2*将软件缺陷进行分类的理由？</h2><p>在编码完程序构件之后，我们通常对代码进行检查，以找出故障并立刻去除它们。当不存在明显的故障时，我们测试程序，通过创造一些条件，是代码不能像计划的那样做出反应，看一看能否发现更多的故障。因此，知道我们正在查找什么类型的故障是很重要的。</p><h2 id="8-3几种主要的缺陷类型"><a href="#8-3几种主要的缺陷类型" class="headerlink" title="8.3几种主要的缺陷类型"></a>8.3几种主要的缺陷类型</h2><p>(1)算法故障(algorithmic fault)：由于处理步骤中的某些错误，使得对于给定的输入，构件的算法或逻辑没有产生适当的输出。<br>(2)计算故障(computation fault)或精度故障(precision fault)：一个公式的实现是错误的，或者计算结果没有达到要求的精度。<br>(3)文档故障(documentation fault)：文档与程序实际做的事情不一致。<br>(4)压力故障(stress fault)或过载故障(overload fault)：对队列长度、缓冲区大小、表的维度等的使用超出了规定的能力。<br>(5)能力故障(capacity fault)或边界故障(boundary fault)：系统活动到达指定的极限时，系统性能会变得不可接受。<br>(6)时序性故障(timing fault)或协调故障(coordination fault)：几个同时执行或仔细定义顺序执行的进程之间细条不适当。<br>(7)吞吐量故障(throughput fault)或性能故障(performance fault)：系统不能以需求规定的速度执行。<br>(8)恢复性故障(recovery fault)：当系统失效时，不能表现得像设计人员希望的或客户要求的那样。<br>(9)硬件和系统软件故障(hardware and system software fault)：当提供的硬件或者系统软件实际上并没有按照文档中的操作条件或步骤运作时。<br>(10)标准和过程故障(standards and procesure fault)：代码没有遵循组织机构的标准和过程。</p><h2 id="8-4什么是正交缺陷分类？"><a href="#8-4什么是正交缺陷分类？" class="headerlink" title="8.4什么是正交缺陷分类？"></a>8.4什么是正交缺陷分类？</h2><p>定义：被分类的任何一项故障都只属于一个类别，则分类方案是正交的。如果一个故障属于不止一个类，则失去了度量的意义。</p><h2 id="8-5测试的各个阶段及其任务？"><a href="#8-5测试的各个阶段及其任务？" class="headerlink" title="8.5测试的各个阶段及其任务？"></a>8.5测试的各个阶段及其任务？</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/24/6587eded31754.png"></p><p>(1)模块测试(module testing)、构件测试(component testing)或单元测试(unit testing)：将每个程序构件与系统中的其他构件隔离，对其本身进行测试。<br>(2)集成测试(integration testing)：验证系统构件是否能够按照系统和程序设计规格说明中描述的那样共同工作的过程。<br>(3)功能测试(function test)：对系统进行评估，以确定集成的系统是否确实执行了需求规格说明中描述的功能，其结果是一个可运转的系统。<br>(4)性能测试(performance test)：测试系统的软硬件性能是否符合需求规格说明文档。其结果是一个确认的系统。<br>(5)验收测试(acceptance test)：确定系统是按照用户的期望运转的。<br>(6)安装测试(installation test)：确保系统在实际环境中按照应有的方式运转。<br>(7)系统测试(system test)：功能测试、性能测试、验收测试和安装测试统称为系统测试。</p><h2 id="8-6-测试的态度问题？（为什么要独立设置测试团队？）"><a href="#8-6-测试的态度问题？（为什么要独立设置测试团队？）" class="headerlink" title="8.6*测试的态度问题？（为什么要独立设置测试团队？）"></a>8.6*测试的态度问题？（为什么要独立设置测试团队？）</h2><p>新程序员不习惯将测试看做是一个发现的过程，可能仅仅将程序视作问题的解决方案，为没有考虑问题本身。但是客户对系统的在某些条件下能够运行并不感兴趣，相反，他们感兴趣的是确保系统在所有条件下都能适当运行。所以，作为一个开发人员，无论故障出现在系统的何处，也无论是谁引起这些故障，你的目标应该是尽可能多地去除故障。<br>为了从测试过程中排除个人情感，通常是用一个独立的测试小组来测试系统，这样就避免了故障的个人责任与可能多地发现故障的需要之间的冲突。</p><h2 id="8-7掌握测试的方法—-黑盒、白盒的概念？"><a href="#8-7掌握测试的方法—-黑盒、白盒的概念？" class="headerlink" title="8.7掌握测试的方法—-黑盒、白盒的概念？"></a>8.7掌握测试的方法—-黑盒、白盒的概念？</h2><p><strong>黑盒</strong>将测试的对象看作是一个不了解其内容的闭盒，我们的测试就是向闭盒提供输入的数据，并记录产生的输出。测试的目标是确保针对每一种输入，观察到的输出与预期的输出相匹配。<br>定义：测试人员在完全不了解程序内部的逻辑结构和内部特性的情况下，只依据程序的需求规格及设计说明，检查程序的功能是否符合它的功能说明。(备注：1、测试时应该考虑让被测模块完成一切应做的事情, 拒绝一切不应做的事情。2、黑盒测试的参考文档是系统需求、主要文档是系统设计和程序设计阶段文档。若是可重用部件，则是类似系统)<br>优点：黑盒测试免于受强加给测试对象内部结构和逻辑的约束。更偏向于功能性的测试。<br>缺点：黑盒法以 SRS 为依据，有一定的盲目性和不确定性，不可能揭示所有的错误。<br>没办法总是使用这种方式进行完备的测试。不容易找到具有代表性的测试用例证明所有情况 下功能都正确。</p><p><strong>白盒</strong>将测试对象看作一个白盒，然后根据测试对象的结构用不同的方式进行测试。例如，可以设计执行构件内所有语句或所有控制路径的测试用例。<br>定义：以测试对象的内部结构为基本依据，手工或自动的展开各种测试。<br>优点：可以测试一个模块的细节。<br>缺点：该法以模块内部逻辑为依据，当内部逻辑过于复杂时，则不能给出好的或合适的 测试用例。有时候，对于大量递归、循环和分支的构件，想要测试完所有的分支也是不现实的。<br>实际测试中，没有必要把黑盒测试和白盒测试严格的区分开来。具体的测试方法的选择收到很多因素的影响。</p><h2 id="8-8什么是单元测试？"><a href="#8-8什么是单元测试？" class="headerlink" title="8.8什么是单元测试？"></a>8.8什么是单元测试？</h2><p>将每个程序构件与系统中的其他构件隔离，对其本身进行测试。<br>首先，通过通读程序对代码进行检查，试着找出算法、数据以及语法中的故障。甚至可以将代码与规格说明进行比较，与设计进行比较，以确保已经考虑了所有相关情况。接着，编译代码，排除任何剩余的语法故障。最后，开发测试用例，以证明是否将输入适当地转换为所期望的输出。</p><h2 id="8-9-什么是走查和检查？"><a href="#8-9-什么是走查和检查？" class="headerlink" title="8.9*什么是走查和检查？"></a>8.9*什么是走查和检查？</h2><p>走查：不正式的的代码评审。<br>检查：正式的代码评审，事先准备问题清单，依据清单比对代码和文档的一致性。</p><h2 id="8-10黑盒白盒方法各自的分类？测试用例的设计和给出方法。"><a href="#8-10黑盒白盒方法各自的分类？测试用例的设计和给出方法。" class="headerlink" title="8.10黑盒白盒方法各自的分类？测试用例的设计和给出方法。"></a>8.10黑盒白盒方法各自的分类？测试用例的设计和给出方法。</h2><p>黑盒测试方法：<br>1、等价分类法：将输入域划分为若干等价类。每一个测试用例都代表了一类与它等价 的其他例子。如果测试用例没有发现错误，那么对应的等价例子也不会发生错误。有效等价 类的测试用例尽量公用，以此来减少测试次数，无效等价类必须每类一个用例，以防止漏掉 可能发现的错误。<br>2、边界值分析法：在等价分类法中，代表一个类的测试数据可以在这个类的允许范围 内任意选择。但如果把测试值选在等价类的边界上，往住有更好的效果，这就是边界值分析 法的主要思想。<br>3、错误猜测法：猜测程序中哪些地方容易出错，并据此设计测试用例。更多的依赖于 测试人员的直觉和经验。<br>4、因果图法：适用于被测试程序有很多输入条件，程序的输出又依赖输入条件的各种 组合的情况。</p><p>白盒测试方法：<br>逻辑覆盖法<br>1、语句覆盖：程序的每条语句都要执行一次。<br>2、判定(分支)覆盖：程序的每个分支都要执行一次。<br>3、条件覆盖：要求判定中的每个条件均按照“真”、“假”两种结果至少执行一次。<br>4、条件组合覆盖：要求所有条件结果的组合都至少出现一次。(比如 A&amp;&amp;B，两个条件，那么就有四种条件的组合)<br>路径测试法</p><h2 id="8-11如何面对一个命题，设计和给出测试用例的问题。"><a href="#8-11如何面对一个命题，设计和给出测试用例的问题。" class="headerlink" title="8.11如何面对一个命题，设计和给出测试用例的问题。"></a>8.11如何面对一个命题，设计和给出测试用例的问题。</h2><p>1.在集成测试及其后的测试阶段，除去很小的程序，都采用黑盒方法。其策略包括: (1)用边值分析法和(或)等价分类法提出基本的测试用例; (2)用猜错法补充新的测试用例; (3)如果在程序的功能说明中含有输入条件的组合，宜在一开始就用因果图法，然后再按以上(1)、(2)两步进行。</p><p>2.单元测试的设计策略稍有不同。因为在为模块设计测试用例时，可以直接参考模块的源程序。所以单元测试的策略，总是把白盒法与黑盒法结合运用。具体的作法又有 两种:<br>(1)先仿照上述步骤用黑盒法提出一组基本的测试用例，然后用白盒法作验证。 如果发现用黑盒法产生的测试用例未能满足所需的覆盖标准，就用白盒法增补新的测 试用例来满足它们覆盖的标准应根据模块的具体情况确定。对可靠性要求较高的模块， 通常应满足条件组合覆盖或路径覆盖标准。<br>(2)先用白盒法分析模块的逻辑结构，提出一批测试用例，然后根据模块的功能 说明用黑盒法进行补充。<br>在一般情况下，小型单元测试应该大多以白盒方法为主。</p><h2 id="8-12集成测试及其主要方法的分类？（驱动模块、桩模块的概念）"><a href="#8-12集成测试及其主要方法的分类？（驱动模块、桩模块的概念）" class="headerlink" title="8.12集成测试及其主要方法的分类？（驱动模块、桩模块的概念）"></a>8.12集成测试及其主要方法的分类？（驱动模块、桩模块的概念）</h2><p>构件驱动程序：在测试最底层的构件时，因为没有现成的已测试的构件调用底层的待测试构件，所以我们需要编写特定的代码来辅助集成。构件驱动程序就是调用特定构件并向其传递测试用例的程序，即代替上级模块传递测试用例的程序。</p><p>桩(stub)：一种专用程序，用于模拟测试时缺少构件时的活动。桩应答调用序列，并传回输出数据，使测试能够正常的进行下去，即代替下级模块的仿真程序。</p><p>分类：<br>1、自底向上集成<br>含义：使用这种测试方法的时候，每一个处于系统层次中最底层的构件先被单独测试，接着测试的是那些调用了前面已测试构件的构件。反复采用这种方法，直到所有的构件测试完毕。<br>先测试系统最底层的模块，接着测试调用这些底层模块的模块，直到测试完毕。<br>2、自顶向下集成<br>含义：顶层构件通常是一个控制构件，是独立进行测试的。然后将被测构件调用的所有构件组合起来，作为一个更大的单元进行测试。重复这样的操作直到所有的构件都被测试。<br>先测试系统最上层的模块，接着测试顶层模块调用的下层模块，直到测试完毕。<br>3、一次性集成<br>先测试每一个模块，之后将所有模块一并集成。<br>先测试每一个构件，然后将所有的构件一次性的集成。只适用于小型系统。<br>4、三明治集成<br>将系统分成三层，目标层处于中间、目标层上有一层，目标层下有一层。在顶层采用自顶向下的方式集成，在较低层采用自底向上的方式集成，测试集中于目标层。</p><h2 id="8-13传统测试和OO测试有何不同？OO测试有何困难？"><a href="#8-13传统测试和OO测试有何不同？OO测试有何困难？" class="headerlink" title="8.13传统测试和OO测试有何不同？OO测试有何困难？"></a>8.13传统测试和OO测试有何不同？OO测试有何困难？</h2><p>(1)测试用例的充分性：对过程语言而言，当系统改变时，我们可以针对改变测试是否正确，并使用原有的测试用例来验证剩余的功能是否同原来一致。但是面向对象的测试中，我们可能需要编写不同的测试用例。<br>(2)面向对象趋向于小粒度，并且平常存在于构件内的复杂性常常转移到构件之间的接口上。这意味着，其单元测试较为容易，但是集成测试涉及面变得更加广泛。<br>(3)传统测试和面向对象的测试主要集中在：需求分析和验证、测试用例生成、源码分析和覆盖。</p><p>困难：<br>A: 需求验证缺乏工具支持。（很多时候依赖人工）<br>B: 测试工具生成的测试用例，处理OO模型中的对象和方法时，其针对性不强。（某些OO关系是测试工具本身搞不清楚其内在逻辑关系的）<br>C: 传统的测试方法（如环路复杂度等）在评价OO系统的规模和复杂性时，还不是很有效。<br>D: 对象的交互是OO系统复杂性的根源，传统的测试方法和根据作用有限。</p><h2 id="8-14-测试计划涉及的几个步骤？"><a href="#8-14-测试计划涉及的几个步骤？" class="headerlink" title="8.14*测试计划涉及的几个步骤？"></a>8.14*测试计划涉及的几个步骤？</h2><p>(1)制定测试目标<br>(2)设计测试计划<br>(3)编写测试用例(4)测试测试用例<br>(5)执行测试<br>(6)评估测试结果</p><h1 id="第九章-测试系统"><a href="#第九章-测试系统" class="headerlink" title="第九章 测试系统"></a>第九章 测试系统</h1><h2 id="9-1系统测试的主要步骤及各自含义？"><a href="#9-1系统测试的主要步骤及各自含义？" class="headerlink" title="9.1系统测试的主要步骤及各自含义？"></a>9.1系统测试的主要步骤及各自含义？</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/24/6587efcc2ea0c.png"></p><p>(1)功能测试——系统功能需求。根据SRS测试系统功能。<br>(2)性能测试——其他软件需求。根据SRS测试系统性能。<br>(3)验收测试——客户需求规格说明书。根据客户的需求定义，由客户和用户一起测试。<br>(4)安装测试——用户环境。在用户环境下进行测试。</p><h2 id="9-2-什么是系统配置？软件配置管理？基线？"><a href="#9-2-什么是系统配置？软件配置管理？基线？" class="headerlink" title="9.2*什么是系统配置？软件配置管理？基线？"></a>9.2*什么是系统配置？软件配置管理？基线？</h2><p>系统配置：向特定客户交付的一组系统构件</p><p>软件配置管理：开发和测试不同的配置需要配置管理。配置管理控制不同系统配置之间的差别，将风险和错误减少到最低程度。</p><p>基线：是指软件文档和其他资料的集合，它们代表了产品在某一时间点的情况(以及其他参考点)。</p><h2 id="9-3什么是回归测试？"><a href="#9-3什么是回归测试？" class="headerlink" title="9.3什么是回归测试？"></a>9.3什么是回归测试？</h2><p>回归测试是用于新的版本或者改进版本的一种测试，以验证与旧版本相比，软件是否仍然以同样的方式执行同样的功能。</p><h2 id="9-4功能测试的含义极其作用？"><a href="#9-4功能测试的含义极其作用？" class="headerlink" title="9.4功能测试的含义极其作用？"></a>9.4功能测试的含义极其作用？</h2><p>含义：测试需求设计（SRS）中提出的功能性需求。<br>作用：有很高的故障检测概率（因为一项功能测试只面向一小组组件）。</p><h2 id="9-5功能测试的基本指导原则？"><a href="#9-5功能测试的基本指导原则？" class="headerlink" title="9.5功能测试的基本指导原则？"></a>9.5功能测试的基本指导原则？</h2><p>(1)高故障检测概率；<br>(2)使用独立于设计人员和程序员的测试小组；<br>(3)了解期望的动作和输出；<br>(4)既要测试合法输入，也要测试不合法输入；<br>(5)制定停止测试的标准；<br>(6)不能修改系统。</p><h2 id="9-6性能测试的含义与作用？"><a href="#9-6性能测试的含义与作用？" class="headerlink" title="9.6性能测试的含义与作用？"></a>9.6性能测试的含义与作用？</h2><p>性能测试与需求的质量有密切的关系，需求文档需要足够完备才能确保性能测试的成功进行。因此需求的质量通常可以反映在性能测试的容易度上。</p><p>含义：测试非功能性需求。</p><p>作用：确保系统的可靠性、可用性和可维护性。</p><p>性能测试由测试小组进行设计和执行并将结果提供给客户。</p><h2 id="9-7性能测试的主要分类？"><a href="#9-7性能测试的主要分类？" class="headerlink" title="9.7性能测试的主要分类？"></a>9.7性能测试的主要分类？</h2><p>压力测试&#x2F;强度测试(短时间内加载极限负荷，验证系统能力)<br>容量测试&#x2F;巨量数据测试(验证系统处理巨量数据的能力)<br>配置测试(构建测试用例对系统软硬件的各种配置(最小到最大)进行测试)<br>兼容性测试(测试接口等。如果它与其他系统交互时)<br>回归测试(如果这个系统要替代一个现有系统时需要进行此测试)<br>安全性测试：确保安全性需求得到满足。<br>计时测试：评估涉及对用户的响应时间和一个功能的执行时间的相关需求。<br>环境测试：考察系统在安装场所的执行能力。<br>质量测试：评估系统的可靠性、可维护性和可用性。<br>恢复测试：强调的是系统对出现故障或丢失数据、电源、设备或服务时的反应。<br>维护测试：为了帮助人们发现问题的根源提供诊断工具和过程的需要。<br>文档测试：确保已经编写了必需的文档。<br>人为因素测试：检查设计系统用户界面的需求。</p><h2 id="9-8-什么是可靠性、可用性和可维护性？"><a href="#9-8-什么是可靠性、可用性和可维护性？" class="headerlink" title="9.8*什么是可靠性、可用性和可维护性？"></a>9.8*什么是可靠性、可用性和可维护性？</h2><p>可靠性：指一个系统对于给定的时间间隔内、在给定的条件下无失效运作的概率。<br>可用性：指在给定的时间点上，一个系统能够按照规格说明正确运作的概率。<br>可维护性：在给定的使用条件下，在规定的时间间隔内，使用规定的过程和资源完成维护活动的概率。</p><h2 id="9-9确认测试概念，确认测试分类？（基准测试和引导测试）"><a href="#9-9确认测试概念，确认测试分类？（基准测试和引导测试）" class="headerlink" title="9.9确认测试概念，确认测试分类？（基准测试和引导测试）"></a>9.9确认测试概念，确认测试分类？（基准测试和引导测试）</h2><p>由用户检查软件系统是否满足了他们的需求的测试。</p><p>(1)基准测试<br>由用户准备典型测试用例，在实际安装后的系统运作并由用户对系统执行情况进行评估。<br>(2)引导测试(课件译)&#x2F;试验性测试(课本译)<br>在假设系统已经永久安装的前提下执行系统。它依赖系统的日常工作进行测试，相对基准测试不是非常的正式与结构化。</p><h2 id="9-10什么是alpha测试？β测试？"><a href="#9-10什么是alpha测试？β测试？" class="headerlink" title="9.10什么是alpha测试？β测试？"></a>9.10什么是alpha测试？β测试？</h2><p>α测试：在向客户发布一个系统之前，先让来自自己组织机构或公司的用户来测试这个系统。在客户进行实际的试验性测试前，先自己组织团队（或者委托其他团队）测试这个系统。</p><p>β测试：客户实际进行测试。</p><h2 id="9-11什么是安装测试？"><a href="#9-11什么是安装测试？" class="headerlink" title="9.11什么是安装测试？"></a>9.11什么是安装测试？</h2><p>在用户环境中配置系统，以测试可能因为开发环境与用户环境的不同而导致的问题。</p>]]></content>
      
      
      <categories>
          
          <category> 大学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网传输层</title>
      <link href="/2023/12/15/%E8%AE%A1%E7%BD%91%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
      <url>/2023/12/15/%E8%AE%A1%E7%BD%91%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<blockquote><p>经过前面对物理层、数据链路层、网络层的学习，我们明白了如何实现点到点的可靠的传输，明白了网络中的一系列路由算法，走进传输层，我们首先要明白这一层实现的是端到端的可靠的传输，是基于不可靠的网络层之上的。</p><p>为什么之前为确保可靠而使用的超时重传和确认机制在这里会导致不可靠呢？这是因为与简单的主线（Bus）相比，我们这里所处于的是网络之中，网络里的节点是具备缓存能力的，由此可能导致分组的滞留，而简单的超时重传等机制产生的重复分组会在网络通信中引发很大的问题。基于这个现状，我们聪慧的前辈们想出利用选号和三次握手机制建立和拆除TCP 连接的方法克服了网络中重复分组引发的问题，在不可靠的IP 层之上实现的可靠的数据传输协议TCP。</p><p>本章还涉及了UDP 协议的相关内容，与TCP 面向连接、可靠的特点相比较，UDP 是一个无连接的、不可靠的传输层协议。</p></blockquote><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/15/657bfab2207bc.png"></p><p>上图为本章考试重点，非原书结构，仅供参考。</p><h1 id="传输协议的要素"><a href="#传输协议的要素" class="headerlink" title="传输协议的要素"></a>传输协议的要素</h1><h2 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/15/657bfb749f304.png"></p><p>图6-1 是正常的三次握手建立连接的过程。（此图中的ack 值为下一次想要接收的第一个字节编号减一所得，下图亦然）。</p><p>图6-2 这种情况是老的CR（Connection Request）重复分组出现了，它虽然引起了主机2 发送相应的分组，但是主机1 根据主机2 发送分组的ack 值可以发现这是异常情况，所以拒绝（REJECT）。</p><p>图6-3 这种情况是老的CR（Connection Request）重复分组和和老的数据重复分组出现的情况。虽然老的CR 重复分组引起了主机2 发送相应的分组，但是主机1 根据主机2发送分组的ack 值可以发现这是异常情况，产生拒绝（REJECT）；对于数据重复分组。主机2 根据分组的ack 值可以发现这是异常情况。</p><h2 id="断开连接"><a href="#断开连接" class="headerlink" title="断开连接"></a>断开连接</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/15/657bfba6b25e0.png"></p><p>图6-4 是正常的三次握手断开连接的过程。</p><p>图6-5 这种情况是最后主机1 发出的ack 丢失的情况，这时候，当主机2 的计时器时后，主机2 就会释放连接。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/15/657bfc3058fde.png"></p><p>图6-6 这种情况是主机2 给主机1 的DR（Disconnection Request）的应答丢失了，这种情况下，当主机1 的计时器超时后，主机1 会重新发送DR。</p><p>图6-7 这种情况是主机2 给主机1 的DR（Disconnection Request）的应答和主机1后续的DR 都丢失了，这种情况下，主机1 经过N 次重传之后，就会放弃，并且释放连接；而主机2 在计时器超时之后也会释放连接。</p><h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><h2 id="UDP-简介"><a href="#UDP-简介" class="headerlink" title="UDP 简介"></a>UDP 简介</h2><p>UDP（User Datagram Protocol），用户数据报协议。它的协议号是17。</p><h2 id="UDP-的一些特点"><a href="#UDP-的一些特点" class="headerlink" title="UDP 的一些特点"></a>UDP 的一些特点</h2><p>第一，UDP 是无连接的，不可靠的。<br>第二，分组头部开销小。TCP 有20 字节的头部开销，UDP 只有8 字节。UDP 头的布局结构如下所示：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/01/06/6598dbb61486f.jpg"></p><p>第三，UDP 尤其适用的一个领域是在客户-服务器的情形下。<br>第四，UDP 的一个应用是DNS（Domain Name System）&lt;程序与DNS 服务器之间&gt;。<br>第五，UDP 不考虑流控制、错误控制，在收到一个坏的数据段之后它也不重传。所有这些工作都留给用户进程。<br>其他UDP 的相关知识大家请见6.4 节。</p><h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><h2 id="TCP-数据段的头"><a href="#TCP-数据段的头" class="headerlink" title="TCP 数据段的头"></a>TCP 数据段的头</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/01/06/6598dbb62a899.jpg"></p><p>上图显示了TCP 数据段的布局结构，每一行为32 位，即4 个字节。<br>第一行是源端口（Source port）和目标端口（Destination port）信息。<br>第二行是序列号（Sequence number），表示此次发送数据的第一个字节的编号<br>第三行是确认号（Acknowledge number），表示下次想要接收数据的第一个字节的编号。<br>第四行由几个部分组成，第一部分是TCP 头长度（TCP header length），它占4 位，单位是“4 字节”，所以我们可以简单计算一下：24*4B&#x3D;64B（其中有20B 是TCP 数据段的头的固定长度，另外44B 是可选项Options）；第二部分是未使用的4 位域；第三部分是8 个1 位标志：CWR 和ECE 用作拥塞控制的信号、URG 置1 表示使用了紧急指针、ACK 置1 表示确认号字段是有效的、PSH 位表示这是带有PUSH 标志的数据、RST 位被用于重置一个已经混乱的连接(一般而言，如果得到的数据段被设置了RST 位，那说明你这一端有了问题)、SYN 被用于建立连接的过程、FIN 被用于释放一个连接；第四部分是窗口大小（Window size），它表示这个TCP 数据段发送方当前可用的缓冲区大小，表示的是这一方的接收能力。<br>第五行由两部分组成：第一部分是校验和（Checksum），它校验的范围包括TCP数据段的头部、数据以及伪TCP 头，下面我们来看看什么是伪TCP</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/01/06/6598dce5c7ec3.png"></p><p>伪TCP 头的第一行是源地址，第二行是目标地址，第三行由三部分组成：8 位0，TCP的协议号（6）以及TCP 数据段（包括TCP 头）的字节计数。第五行的第二部分是紧急指针（Urgent pointer），它指向一段程序，调用后清除内存里的相关内容。<br>第六行可选项（Options）是可选的，前面我们计算过了，它的长度是0B~44B。</p><h2 id="TCP-连接建立（三次握手）"><a href="#TCP-连接建立（三次握手）" class="headerlink" title="TCP 连接建立（三次握手）"></a>TCP 连接建立（三次握手）</h2><p>TCP 是面向连接的，所以有三个重要阶段：建立连接、使用连接和拆除连接，这一部分我们讨论三次握手法建立TCP 连接。</p><p>由于网络中节点的缓存能力的影响，使得分组可能滞留在网络之中，由于超时重传机制等原因产生的重复分组可能会引起严重的问题，于是<br>我们利用选号和三次握手来保证可靠的传输。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/01/06/6598dce5d72ce.png"></p><p>上图是三次握手建立连接的示意图，通常在第三次发送消息的时候，TCP 数据段里已经携带了数据，故将SYN 位置为了0。在这里我仅是列出了最为重要的SYN、ACK标志位的值</p><h2 id="TCP-连接断开（三次握手）"><a href="#TCP-连接断开（三次握手）" class="headerlink" title="TCP 连接断开（三次握手）"></a>TCP 连接断开（三次握手）</h2><p>下面我们来看一看是如何用三次握手法断开TCP 连接的。抽象图示如下：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/01/06/6598dce5c51a1.png"></p><p>在这里我仅是列出了最为重要的FIN 标志位的值。</p><h2 id="拥塞控制与慢启动算法"><a href="#拥塞控制与慢启动算法" class="headerlink" title="拥塞控制与慢启动算法"></a>拥塞控制与慢启动算法</h2><p>网络的拥塞里存在两个方面的问题，对应着每个发送方维护的两个窗口：网络容量（对应拥塞窗口）和接收方的容量（对应接收方准许的窗口）。拥塞控制的本质是降低发送方的发送速率，所以发送方的速率应该取以上两者里的小值。</p><p>拥塞控制实际上是由网络层（RED）和传输层（TCP 慢启动）共同完成的。接下来让我们一起看看什么是TCP 慢启动。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/01/06/6598dbb63038a.jpg"></p><p>以上图示即展示了TCP 慢启动的过程，一开始通过成倍增加（指数级）拥塞窗口的大小不断试探网络连接情况，当到达阈值的时候，开始线性地增长拥塞窗口的大小。当一次超时发生的时候，将阈值设置成为当前拥塞窗口的一半，而拥塞窗口被重置为初始的值。</p><p>拥塞窗口一直增长，直至发生超时或达到接收方准许的窗口大小。<br>让我们再来看看网络层和传输层是如何合作完成拥塞控制，降低发送方的发送速率的。</p><p>当网络中路由器的被使用缓冲区的大小到达路由器的阈值的时候，路由器开始执行RED协议，随意丢弃某些分组，被丢弃的分组的发送方因此会超时，这时通过TCP 慢启动会降低发送方速率。</p>]]></content>
      
      
      <categories>
          
          <category> 大学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程过程和生命周期建模</title>
      <link href="/2023/12/06/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BF%87%E7%A8%8B%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%BB%BA%E6%A8%A1/"/>
      <url>/2023/12/06/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BF%87%E7%A8%8B%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%BB%BA%E6%A8%A1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这一章我们要详细分析软件工程中的各种步骤的组织方式，以便我们协调各种活动。面对的主要问题有如何理解过程模型，如何应对软件开发过程中的种种状况，为此我们首先要解释过程模型的意义，然后为大家介绍各种模型的思想，为了响应变化和规避风险，会涉及到原型化和迭代开发的思想。关键在于思想的理解，模型是固化的，思想运用是灵活的。本章重点在过程与生命周期和过程模型。</p></blockquote><p>章节框架：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/06/6570568b46f1c.jpeg"></p><h1 id="过程与生命周期"><a href="#过程与生命周期" class="headerlink" title="过程与生命周期"></a>过程与生命周期</h1><h2 id="过程的定义"><a href="#过程的定义" class="headerlink" title="过程的定义"></a>过程的定义</h2><p>一组有序的任务，它涉及活动、约束和资源使用的一系列步骤，用于产生某种想要的输出。</p><p>过程不仅仅是步骤，过程是步骤的集合，它将步骤组织起来使人们能够生产满足一系列目标和标准的产品。</p><h2 id="软件生命周期"><a href="#软件生命周期" class="headerlink" title="软件生命周期"></a>软件生命周期</h2><p>软件开发过程描述了软件产品从概念到实现、交付、使用和维护的整个过程，因此，有时把软件开发过程称为软件生命周期。</p><h2 id="过程的重要意义"><a href="#过程的重要意义" class="headerlink" title="过程的重要意义"></a>过程的重要意义</h2><ol><li><p>它强制活动具有一致性和一定的结构。</p></li><li><p>过程结构允许我们分析、理解、控制和改进组成过程的活动，并以此来指导我们的活动。</p></li><li><p>它使我们获取经验并把经验传授给他人。</p></li></ol><h1 id="过程模型"><a href="#过程模型" class="headerlink" title="过程模型"></a>过程模型</h1><h2 id="为何需要为过程建立模型"><a href="#为何需要为过程建立模型" class="headerlink" title="为何需要为过程建立模型:"></a>为何需要为过程建立模型:</h2><ol><li><p>达成共识：开发团队在记录开发过程的描述时，自然的对软件所涉及到的活动,资源,约束等达成共识，这共识就是”模型”。</p></li><li><p>发现缺陷：发现过程层面的缺陷(过程实施时的不一致性、多余部分、缺省部分、不完善部分)，从而让过程更有效。</p></li><li><p>评价与优化：模型应该反映开发的诸多目标，并评价侯选活动的有效性和正确性,以构建高质量软件。</p></li></ol><h2 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h2><p>线性的安排每一个阶段，将开发阶段描述为从一个阶段瀑布般地转换到另一个阶段。一个开发阶段必须在另一个开发阶段开始之前完成。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/06/6570568b700fa.jpeg"></p><h3 id="瀑布模型的优点"><a href="#瀑布模型的优点" class="headerlink" title="瀑布模型的优点"></a>瀑布模型的优点</h3><ol><li><p>它的简单性使得开发人员很容易向不熟悉软件开发的客户作出解释。</p></li><li><p>每一个过程活动都有与其相关联的里程碑和可交付产品，以便于项目经理评估项目进度。</p></li><li><p>瀑布模型是最基础的模型，很多其他更复杂的模型实际上是在瀑布模型的基础上的润色，如加入反馈循环以及额外的活动。</p></li></ol><h3 id="瀑布模型的缺点"><a href="#瀑布模型的缺点" class="headerlink" title="瀑布模型的缺点"></a>瀑布模型的缺点</h3><ol><li><p>除了一些理解非常充分的问题之外，实际上软件是通过大量的迭代进行开发的。软件是一个创造的过程,<br>不是一个制造的过程。软件变动时,<br>该模型无法处理实际过程中的重复开发问题。</p></li><li><p>文档转换有困难。它说明了每一个活动的产品（例如，需求、设计或代码），但没有揭示一个活动如何把一种制品转化为另外一种制品（例如，从需求文档转化为设计文档）。</p></li></ol><h3 id="瀑布模型的优化——原型化的瀑布模型"><a href="#瀑布模型的优化——原型化的瀑布模型" class="headerlink" title="瀑布模型的优化——原型化的瀑布模型"></a>瀑布模型的优化——原型化的瀑布模型</h3><p>我们注意到瀑布模型将过程抽象为线性发展的，这种抽象给它带来了简单、明确和直观的优点，但同时也招致了许多问题。可是实际的开发中每个步骤并不是理想中的线性发展的的状态，比如在设计阶段了解到客户更新了需求，或者在设计阶段的疏漏直到测试时才被发现，以上的情况都需要返回之前的步骤进行修正才能解决。我们需要对瀑布模型进行优化，引入原型化以有助于控制活动之间的往返。</p><h4 id="原型的概念"><a href="#原型的概念" class="headerlink" title="原型的概念"></a>原型的概念</h4><p>一种部分开发的产品，用来让用户和开发者共同研究，提出意见，为最终产品定型。</p><p>原型可以理解为小样，在某一阶段产品定型前先做一些小样，通过对各种样品的评价和分析，并最终为产品定型。</p><p>原型化的瀑布模型如下图所示，在实现代码前的需求和设计阶段引进原型化的概念，在需求分析阶段，通过设计和分析原型以确保需求是一致、可行和符合实际的，避免在测试阶段付出巨大的代价进行修正；在设计阶段，原型化有助于开发人员评价可选的设计策略以及决定哪一种策略是最适合的。为了确保产品符合需要，在测试阶段要进行确认&#x2F;核准（validate）和验证（verify）。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/06/6570568b61fa2.jpeg"></p><h4 id="区分确认和验证"><a href="#区分确认和验证" class="headerlink" title="区分确认和验证"></a>区分确认和验证</h4><p>确认：确保系统实现了所有需求。 </p><p>验证：确保每一项功能都是正确的。</p><p>确认保证开发人员构造的是正确的产品，而验证检查实现的质量。</p><h2 id="V-模型"><a href="#V-模型" class="headerlink" title="V 模型"></a>V 模型</h2><p>V 模型是瀑布模型的变种，它说明测试活动是如何与分析和设计相联系的。</p><p>如下图所示，编码位于 V型的顶点，分析和设计在左边，测试和维护在右边。测试的每个步骤都与分析和设计相对应，如果在验证和确认期间发现了问题，可以重新执行响应的步骤加以修正。验收测试对应需求分析，系统测试对应系统设计，单元测试和集成测试对应程序设计。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/06/6570568b3e495.jpeg"></p><p>V 模型与瀑布模型的区别：</p><ol><li><p>V 模型使得隐藏在瀑布模型中的迭代和重做活动更加明确。</p></li><li><p>瀑布模型关注文档和制品，V 模型关注活动和正确性。</p></li></ol><h2 id="原型化模型——“在工作中学会工作”"><a href="#原型化模型——“在工作中学会工作”" class="headerlink" title="原型化模型——“在工作中学会工作”"></a>原型化模型——“在工作中学会工作”</h2><p>之前在瀑布模型的优化中介绍了原型化的思想，原型化并不依附于瀑布模型，原型化模型本身是有效的过程模型的基础。因为它允许用户以独立的工程模型的方式,<br>每一阶段都基于原型的建立, 以快速构造系统, 逐步完成各阶段任务。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/06/6570568b6f187.jpeg"></p><p>如上图所示，原型化模型并不依赖于明确的需求或设计，在情况不明朗的情况下使用原型化模型，先根据简单的需求和设计构造系统的简单样品以理解或澄清问题，以确保开发人员、用户和客户对产品达成共识。也就是说，要根据对每一阶段样品的反响明确需求和设计的具体内容。原型化设计有助于开发人员和客户达成共识，减少了开发中的风险和不确定性。但是为达成共识可能会需要反复进行原型设计。</p><h2 id="阶段化开发模型"><a href="#阶段化开发模型" class="headerlink" title="阶段化开发模型"></a>阶段化开发模型</h2><p>系统被设计成部分提交, 每次用户只能得到部分功能,而其他部分处于开发过程中。</p><p>循环周期：从软件开发时整理需求文档到系统交付经过的时间。</p><p>理解为何要阶段化开发，我们需要了解现在的商业环境不允许产品长时间拖延，所以我们要缩短循环周期，使用阶段化开发模型使系统能一部分一部分的交付，从而在系统其余部分正在开发的同时，用户已经获得了一部分功能。</p><h3 id="产品系统和开发系统"><a href="#产品系统和开发系统" class="headerlink" title="产品系统和开发系统"></a>产品系统和开发系统</h3><p>因为一边开发一边交付，所以有两个系统在并行运行。</p><p>运行系统&#x2F;产品系统：当前正在被客户和用户使用的系统。</p><p>开发系统：准备代替现行产品系统的下一个版本。</p><p>两者关系如下图所示，开发人员总是在开发 n+1，而与此同时 n 正在运行。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/06/6570568b60e04.jpeg"></p><h3 id="增量开发和迭代开发"><a href="#增量开发和迭代开发" class="headerlink" title="增量开发和迭代开发"></a>增量开发和迭代开发</h3><p>因为有不断发布的开发系统和已经运行的产品系统，我们需要有一种组织两者的方式。增量开发和迭代开发是两种最常用的方式。</p><p>增量开发：系统需求按照功能分成若干子系统，开始建造的版本是规模小的、部分功能的系统，后续版本添加包含新功能的子系统，最后版本是包含全部功能的子系统集。</p><p>迭代开发：系统开始就提供了整体功能框架，后续版本陆续增强各个子系统，最后版本使各个子系统的功能达到最强。</p><h3 id="将增量开发和迭代开发相结合"><a href="#将增量开发和迭代开发相结合" class="headerlink" title="将增量开发和迭代开发相结合"></a>将增量开发和迭代开发相结合</h3><p>一个新发布的版本可能包含新功能，并对已有功能做了改进。</p><p>两种开发方式结合的原因：</p><ol><li>观察用户反馈。</li><li>为新功能开拓市场。</li><li>及时修复问题。</li><li>针对不同版本设置不同专业领域技术的优化。</li></ol><h3 id="进化式迭代开发"><a href="#进化式迭代开发" class="headerlink" title="进化式迭代开发"></a>进化式迭代开发</h3><p>统一过程（UP&#x2F;RUP）：用例驱动的、以基本架构为中心的、迭代式和增量性的软件开发过程框架。它使用对象管理组织（OMG）的 UML并与对象管理组织（OMG）的软件过程工程原模型（SPEM）等相兼容。</p><h4 id="统一过程的特点"><a href="#统一过程的特点" class="headerlink" title="统一过程的特点"></a>统一过程的特点</h4><ul><li>统一过程”将重复一系列生命期，这些生命期构成了一个系统的寿命。每个生命期都以向客户推出一个产品版本而结束。</li><li>每个周期包括四个阶段：开始阶段、确立阶段、构建阶段和移交阶段。每个阶段可以进一步划分为多次迭代。</li></ul><h4 id="三个支持工序和六个核心工序"><a href="#三个支持工序和六个核心工序" class="headerlink" title="三个支持工序和六个核心工序"></a>三个支持工序和六个核心工序</h4><p>支持工序：</p><ol><li>配置变更管理工序，用来管理系统和需求变更的配置。</li><li>项目管理工序，用来管理项目。</li><li>环境配置工序，用来配置项目的环境，包括所涉及到的过程和工具。</li></ol><p>核心工序：</p><ol><li>业务模型工序，通过业务模型获取相关知识以理解需要系统自动完成的业务。</li><li>需求工序，通过用例模型获取相关知识以理解自动完成业务的系统需求。</li><li>分析设计工序，通过分析&#x2F;设计模型以分析需求，设计系统结构。</li><li>实现工序，基于实现模型实现系统。</li><li>测试工序，通过测试模型进行针对需求的系统测试。</li><li>部署工序，通过部署模型部署系统。</li></ol><p>下图展示了统一过程的四个阶段和六个核心工序之间的关系，上面一行表示四个阶段，左边一列表示六个核心工序，二者都包含在软件项目的生命期中。每个阶段都包含六个工序，但是重点不同。开始阶段最关注业务模型，几乎不涉及测试和部署；确立阶段最关心需求和分析；构建阶段最关心实现；移交阶段最关心测试和部署，几乎不涉及业务模型和需求。图中箭头表示六个工序执行顺序，菱形覆盖的面积表示关注程度。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/06/6570568b6c479.jpeg"></p><h3 id="什么是进化式迭代开发"><a href="#什么是进化式迭代开发" class="headerlink" title="什么是进化式迭代开发"></a>什么是进化式迭代开发</h3><ol><li>进化式迭代开发是统一开发过程的关键实践。</li><li>开发被组织成一系列固定的短期小项目。</li><li>每次迭代都产生经过测试、集成并可执行的局部系统。</li><li>每次迭代都具有各自的需求分析、设计、实现和测试。</li><li>随着时间和一次次迭代，系统增量式完善。结合下图理解进化式迭代开发。</li></ol><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/06/6570568b7a4e3.jpeg"></p><h2 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h2><p>此法将开发活动与风险管理结合起来,以降低和控制风险。有些类似于迭代开发模型，结合了迭代的思想，同时也结合了原型化的思想。该模型的适用范围于较大型软件工程项目。</p><p>如下图所示，螺旋模型每次迭代有四个任务，依次是计划、目标&#x2F;可选方案、风险评估、开发与测试。螺旋模型共有四次迭代，依次是操作概念、软件需求、软件设计、开发与测试。]每一次迭代都根据需求和约束进行风险分析，以权衡不同选择，并且在确定选择之前，通过原型化验证可行性和期望度。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/06/6570568b7c85c.jpeg"></p><h2 id="敏捷方法"><a href="#敏捷方法" class="headerlink" title="敏捷方法"></a>敏捷方法</h2><p>之前介绍的几种模型逐渐引入了原型化和迭代开发的思想，使得过程模型变得庞大，而敏捷方法打破了这种局面。</p><p>敏捷方法强调灵活性在快速有效的软件生产中所发挥的作用，是重量级方法的叛逆者。</p><h3 id="敏捷方法的四条原则"><a href="#敏捷方法的四条原则" class="headerlink" title="敏捷方法的四条原则"></a>敏捷方法的四条原则</h3><ol><li>个体和交互的价值胜过过程和工具。</li><li>可以工作的软件胜过面面俱到的文档。</li><li>客户合作胜过合同谈判。</li><li>响应变化胜过遵循计划。</li></ol><p>这四条原则反映了敏捷方法的软件过程倾向性。它强调人与人之间的交互是复杂的，并且其效果从来都是难以预期的，但却是工作中最重要的方面。</p><p>敏捷开发的总体目标：尽可能早的，持续的对有价值的软件的交付活动，以客户满意。</p><h3 id="敏捷开发过程的几种方法"><a href="#敏捷开发过程的几种方法" class="headerlink" title="敏捷开发过程的几种方法"></a>敏捷开发过程的几种方法</h3><ol><li>极限编程(XP)：激发人员创造性，使管理负担最小的一组技术，是敏捷方法中最主要的流派。（稍后有详细介绍）</li><li>Crystal（水晶法）：每一个不同的项目都需要一套不同的策略、约定和方法论。</li><li>SCRUM（并列争球法）：使用迭代的方法，其中把每 30天一次的迭代称为一个”冲刺”，并按需求的优先级别来实现产品。</li><li>Adaptive Software Development(ASD) (自适应软件开发)</li><li>Feature Driven Development(FDD) (特征驱动软件开发)</li></ol><h3 id="极限编程"><a href="#极限编程" class="headerlink" title="极限编程"></a>极限编程</h3><h4 id="四个变量"><a href="#四个变量" class="headerlink" title="四个变量"></a>四个变量</h4><p>成本、时间、质量和范围，通过研究变量之间的相互作用，将项目开发分析的更加透彻，成功讲述一个项目成功的原则。</p><p>不同的任务对这四个变量有不同的要求，分析哪一个变量是项目进展的制约，集中精力解决关键问题。</p><h4 id="四个准则"><a href="#四个准则" class="headerlink" title="四个准则"></a>四个准则</h4><ol><li>沟通: 客户与开发者之间持续的交流意见。</li><li>简单性: 鼓励开发者选择最简单的设计或实现来应对客户的需求。</li><li>反馈: 指在软件开发过程中的各个活动中,包含各种反馈循环工作。</li><li>勇气: 指尽早的和经常性的交付软件功能的承诺。</li></ol><h4 id="十二条原则"><a href="#十二条原则" class="headerlink" title="十二条原则"></a>十二条原则</h4><p>计划游戏、小版本、隐喻、简单设计、测试、重构、结队编程、代码集体所有、持续集成、每周工作40 小时、现场客户、编码标准</p><ul><li><p>小版本：系统设计要支持尽可能早的交付。（测试要简单有效。）</p></li><li><p>简单设计：只处理当前需求，使设计保持简单。（因为假设需求是变化的）</p></li><li><p>编码标准：编码支持其他实践，例如测试和重构等。</p><p>其余每条的介绍详见课本。</p></li></ul><p>例题</p><p>关于小版本(小型发布)的说明：敏捷开发方法中，对计划的发布版本应该（ B）。</p><p>A：按产品特性交付：需要交付的特性都必须交付，必要时要推迟发布时间</p><p>B：按日期交付：按照预定发布时间进行发布，必要时候裁剪部分功能特性。</p><p>C：临时决定：我们会平衡一下，临时根据市场要求和开发进展来确定，可能会同时调整交付时间和特性。</p><p>D：在迭代模式下，没有必要计划版本。每个迭代都应该完成可发布的版本，按照市场需要发布迭代版本即可。</p><p>解析：敏捷方法强调灵活性，”尽可能早的，持续的对有价值的软件的交付活动”是其总体目标。</p><h1 id="过程建模工具和技术"><a href="#过程建模工具和技术" class="headerlink" title="过程建模工具和技术"></a>过程建模工具和技术</h1><p>建模工具与技术是在过程模型之内的具体运用。</p><h2 id="两种主要种类的模型"><a href="#两种主要种类的模型" class="headerlink" title="两种主要种类的模型"></a>两种主要种类的模型</h2><h3 id="静态建模——Lai-表示法"><a href="#静态建模——Lai-表示法" class="headerlink" title="静态建模——Lai 表示法"></a>静态建模——Lai 表示法</h3><p>描述一个过程如何由输入转换为输出。</p><p>综合的过程符号描述系统, 允许人们在任何详细的层次上对任何过程建模,该模型范式中可由人员完成角色,由资源完成活动,最后导致软件工件&#x2F;制品的产生。过程模型可以用角色、活动、加工项(工件)来显示彼此之间的关系，用状态表显示每个加工项(工件)在特定时间的完成情况。</p><p>过程的元素：</p><ol><li>活动：过程中要发生的事件。各种前后关系、触发条件、规则、团队成员等等。也可以理解为子过程。</li><li>序列：活动顺序等等。</li><li>过程模型：小型工程可以认为是开发方式等描述。</li><li>资源：活动所需的各种资源标注。</li><li>控制：针对活动的外部影响等。</li><li>策略：各种指导原则，包括约束等。</li><li>组织：各种层次化结构等描述。包括物理的和软件逻辑的结构。</li></ol><h3 id="动态建模"><a href="#动态建模" class="headerlink" title="动态建模"></a>动态建模</h3><p>推演一个过程，用户和开发人员可以看到中间产品和最终产品如何随着时间的推移进行转换。</p><p>系统动力学：展示资源流(非一般性输入)如何通过活动成为输出。</p><h3 id="在所有的软件开发过程模型中，你认为哪些过程给予你最大的灵活性以应对需求的变更？"><a href="#在所有的软件开发过程模型中，你认为哪些过程给予你最大的灵活性以应对需求的变更？" class="headerlink" title="在所有的软件开发过程模型中，你认为哪些过程给予你最大的灵活性以应对需求的变更？"></a>在所有的软件开发过程模型中，你认为哪些过程给予你最大的灵活性以应对需求的变更？</h3><ol><li>设计对于分析模型应该是可跟踪的：软件的模块可能被映射到多个需求上。</li><li>设计结构应当尽可能的模拟实际问题。</li><li>设计应当表现出一致性。</li><li>不要把设计当成编写代码。</li><li>在创建设计时就应该能够评估质量。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 大学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程概述</title>
      <link href="/2023/12/06/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/12/06/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>当我学到这个跟我专业名字一模一样的课程时，我的心情真是很复杂：<br>一方面不知不觉已经学到了我专业的本命课程，这个大一时看课程计划觉得无比重要的课，倍感岁月不饶人；<br>另一方面，当我们学完这学期再审视这门课，又觉得它像Apple的一句广告：“说简单，也高深”。<br>说它简单，觉得它在一开始复习时恍惚有种背政治的感觉，比起烧脑的程序设计和巧妙计算来说真的很轻松；<br>说它高深，是因为如果让所有就业的软件工程毕业生投票自己最后悔没好好学的课，它一定是champion。</p><p>当你抱着一颗佛系的心看这些知识时，你会觉得它那么教条；但当你真的准备干点大事，带着挚友们开发个软件时，你会觉得它说的是那么针针见血：<br>如果你是负责人，你如何知道你需要什么招什么样的人来组成一个开发团队？你就是有了合适的团队你靠什么告诉客户你会花多长时间多少钱去完成这个项目才让他们放心把项目交给你？你就是拿到了项目你怎么让客户客观理性准确无误地告诉你他们的需求是什么？你就是得到了明确无疑的需求你怎么确定为了实现这个你该怎么设计这些功能？你就是得到了一份巧夺天工的设计你怎么保证你的程序员们能高效合作地把这些设计准确实现出来？你就是有了一批勤恳踏实的程序员写完了这些代码你怎么保证它们功能上没有错误？你就是所有功能都完美实现了你怎么保证它们合在一起还能干活？你就是把功能们合在一起天衣无缝你怎么交付给客户使用这个系统？你就是让客户心甘情愿地收下了这个系统你怎么保证用户用起来出了意外怎么维护？你就是维护好了这个系统你怎么迭代增量开发下一个系统让团队不会沦为临时工？……</p><p>总之，软件工程是整个专业的脉络，它的重要性随着你越来越接触到软件开发的核心而愈发凸显。</p></blockquote><h1 id="软件工程概述"><a href="#软件工程概述" class="headerlink" title="软件工程概述"></a>软件工程概述</h1><p>这一章介绍软件工程的发展历程，其所使用的技术及工具；如何分析问题以及寻求解决方案；软件开发人员们取得的进展以及需要努力的方向；软件开发的涉及人员及Wasserman规范将实践融为一体的八个概念。</p><p>章节框架：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/06/65705366604c6.png"></p><h2 id="什么是软件工程"><a href="#什么是软件工程" class="headerlink" title="什么是软件工程"></a>什么是软件工程</h2><p>软件工程涉及的就是”软件开发的规范”，在规范里面体现出内在的思想与软件工程之规律。</p><h3 id="问题求解"><a href="#问题求解" class="headerlink" title="问题求解"></a>问题求解</h3><ul><li>分析(analysis)：将问题分解成可以理解并能够处理的若干小部分，确定问题的本质含义。</li><li>合成(synthesis)：将每个小问题的解决方案组合成一个大的结构，合成解决方案。工具(tool)：用更好的方式完成某事情的设备或自动化系统。</li><li>过程(produce)：把工具和技术结合起来，共同生产特定产品。</li><li>范型(paradigm)：构造软件的特定方法、途径或哲学（如面向对象开发的模式、结构化开发的模式、基于过程开发的模式、某种订制开发的模式）。</li></ul><h3 id="软件工程师的角色是什么"><a href="#软件工程师的角色是什么" class="headerlink" title="软件工程师的角色是什么"></a>软件工程师的角色是什么</h3><p>以计算机科学理论和计算机功能为基础，通过对要解决问题的本质的了解，采用相应的工具和技术，实现设计方案，推出高质量的软件产品。（将计算机作为问题求解的工具）</p><h3 id="软件工程（SE）的定义、方法、作用"><a href="#软件工程（SE）的定义、方法、作用" class="headerlink" title="软件工程（SE）的定义、方法、作用"></a>软件工程（SE）的定义、方法、作用</h3><ul><li>SE：在将有关软件开发与应用的概念科学体系化的基础上，研究如何有计划、有效率、经济地开发和利用能在计算机上正确运行的软件理论和技术工程的方法学，以及一些开发和维护软件的方法、过程、原则等。它是一个系统工程，既有对技术问题的综合分析，也有对开发过程和参与者的管理。</li><li>SE 的方法：面向对象模式，结构化模式，基于过程的模式等。</li><li>SE的作用：付出较低的开发成本，达到要求的软件功能，取得较好的软件性能，开发的软件易于移植，需要较低的维护费用，能按时完成开发工作，及时交付使用。</li></ul><h3 id="开发模式"><a href="#开发模式" class="headerlink" title="开发模式"></a>开发模式</h3><p>软件开发的全部过程，活动和任务的结构框架，它能直观的表达软件开发全过程，明确要完成的主要活动，任务和开发策略。</p><h2 id="软件工程取得了哪些进展"><a href="#软件工程取得了哪些进展" class="headerlink" title="软件工程取得了哪些进展"></a>软件工程取得了哪些进展</h2><h3 id="故障，错误和失效各自的含义（含举例）及它们之间的联系"><a href="#故障，错误和失效各自的含义（含举例）及它们之间的联系" class="headerlink" title="故障，错误和失效各自的含义（含举例）及它们之间的联系"></a>故障，错误和失效各自的含义（含举例）及它们之间的联系</h3><ul><li>错误(error)：是在软件开发过程中人为产生的错误（需求说明中的错误，代码中的错误）。</li><li>故障(fault)：软件功能实现过程中产生的问题，是错误导致的结果，是软件中一个错误的表现（一个错误可能产生多个故障，静态存在）。</li><li>失效(failure)：系统违背了它应有的行为（在系统交付前或交付后被发现，动态存在）。</li><li>联系：人为原因导致程序[错误]；该[错误]编译到系统中导致系统[故障]；用户使用该系统时，因[故障]导致[失效]。故障是系统内部视图，从开发者的角度看待问题；失效是系统外部视图，从用户角度看到的问题。而且并不是所有的故障会导致失效，只要不执行故障代码，或者不进入某个特定状态，那么故障就不会使代码失效。</li></ul><h3 id="零缺陷软件"><a href="#零缺陷软件" class="headerlink" title="零缺陷软件"></a>零缺陷软件</h3><p>由于市场压力促使软件开发人员快速交付产品，零故障无法实现。</p><h3 id="关于-bug"><a href="#关于-bug" class="headerlink" title="关于 bug"></a>关于 bug</h3><p>改正(fixing)有时比重写(rewriting)整个系统要困难。</p><p>错误修正的越晚，付出的代价越大。</p><p>复审(review)十分重要，是正式团队的行为规范；自己检查能只能找出开发阶段故障的1&#x2F;5，同行评审能够揭示其余 4&#x2F;5 的故障。</p><h2 id="什么是好的软件"><a href="#什么是好的软件" class="headerlink" title="什么是好的软件"></a>什么是好的软件</h2><p>从三个方面考虑软件的质量：产品的质量、生产该产品的过程的质量以及在产品将使用的商业环境背景下的质量。</p><h3 id="产品-product-的质量"><a href="#产品-product-的质量" class="headerlink" title="产品(product)的质量"></a>产品(product)的质量</h3><p>用户：从失效的数目和类型等外部特性进行评价，如果软件具有足够的功能，并且易于学习和使用；或者虽然难以学习和使用，但是由于功能值得这些付出，用户就断定软件是高质量的。</p><p>开发者：从故障的数目和类型等内部特征来作为产品质量的依据。</p><h3 id="过程-process-的质量"><a href="#过程-process-的质量" class="headerlink" title="过程(process)的质量"></a>过程(process)的质量</h3><p>有很多过程都会影响到最终的产品质量，只要有活动出了差错，产品的质量就会受到影响；开发和维护过程的质量与产品的质量是同等重要的。</p><p>几个量化模型：CMM、ISO 9000、SPICE（了解）</p><h3 id="商业-business-环境背景下的质量"><a href="#商业-business-环境背景下的质量" class="headerlink" title="商业(business)环境背景下的质量"></a>商业(business)环境背景下的质量</h3><ul><li><p>技术价值与商业价值的联系与区别：</p><p>技术价值：技术指标（速度，正确的运行时间，维护成本等）。</p><p>商业价值：机构对软件是否与其战略利益相吻合的一种价值评估。误区：技术质量不会自动转化为商业价值。</p></li><li><p>目标：</p><p>将技术价值和商业价值统一起来，改进过程所带来的商业价值。</p></li></ul><h2 id="软件工程涉及的人员"><a href="#软件工程涉及的人员" class="headerlink" title="软件工程涉及的人员"></a>软件工程涉及的人员</h2><ul><li><p>客户(customer)：为将要开发的软件系统支付费用的公司、组织或个人。</p></li><li><p>开发者(developer)：为客户构建软件系统的公司、组织或个人。</p></li><li><p>用户(user)：实际使用系统的人。</p><p>有时，他们可能是同一个人或同一组人。</p></li></ul><h2 id="系统的开发方法"><a href="#系统的开发方法" class="headerlink" title="系统的开发方法"></a>系统的开发方法</h2><p>要开发一个项目，必须知道系统包含哪些对象或活动。</p><p>系统(system)：实体、活动、关系、系统边界的集合。</p><h3 id="软件系统的系统要素（组成）（对象（实体）-活动-关系-系统边界）"><a href="#软件系统的系统要素（组成）（对象（实体）-活动-关系-系统边界）" class="headerlink" title="软件系统的系统要素（组成）（对象（实体）+ 活动 +关系 + 系统边界）"></a>软件系统的系统要素（组成）<em>（对象（实体）+ 活动 +关系 + 系统边界）</em></h3><h4 id="活动和对象"><a href="#活动和对象" class="headerlink" title="活动和对象"></a>活动和对象</h4><p>活动(activity)：活动是发生在系统中的某些事情，通常描述为由某个触发器引发的事件，活动通过改变某一特性把一个事物转变成另一个事物。</p><p>对象(object)或实体(entity)：活动中涉及的元素称为对象或实体（如记录数据的对象）。</p><h4 id="关系和系统边界"><a href="#关系和系统边界" class="headerlink" title="关系和系统边界"></a>关系和系统边界</h4><p>关系(relationship)：对实体和活动间数据项及动作相互关系的描述。</p><p>系统边界(system boundary)：用于描述系统中包含什么，不包含什么。</p><h3 id="相互联系的系统"><a href="#相互联系的系统" class="headerlink" title="相互联系的系统"></a>相互联系的系统</h3><p>内容概述：几乎不存在与其他系统没有关联的系统，因此刻画系统边界十分重要，很容易了解什么在系统内部、什么不在以及什么超出了边界。系统可能存在于另一个系统中。边界定义的详细正确，那么根据较小的部分构建较大的系统是相对容易的。开发可以由内而外,但设计最好得由大到小,这就带来了难度。</p><p>增量式开发方法：包含一系列阶段，其中每一个阶段都使前面的系统不受当前系统约束的限制。系统逐渐地从旧的软件和硬件中脱离开，直到它体现出新系统的设计。</p><h2 id="工程化的方法"><a href="#工程化的方法" class="headerlink" title="工程化的方法"></a>工程化的方法</h2><p>大型软件开发过程中的工程化途径与方法</p><h3 id="构建系统"><a href="#构建系统" class="headerlink" title="构建系统"></a>构建系统</h3><p>现代软件工程大致包含的几个阶段及各个阶段文档：</p><ol><li>需求分析：包括问题定义、可行性研究、需求分析【《SRS》即《软件需求规格说明书》】与复审（所有人）。</li><li>系统设计：包括用户界面的设计【《SAD》即《软件系统结构图》：如何制作软件】与复审（开发者与客户）。</li><li>程序设计：包括模块功能算法与数据描述设计【相关文档】与复审（开发者）。</li><li>程序实现：包括编程与 debug【源代码和注释】与复审（开发者、码农）。</li><li>单元测试：模块功能测试与性能测试【测试报告】与复审（测试团队）。</li><li>集成测试：按照结构图进行测试【测试报告】与复审（测试团队）。</li><li>系统测试：按《SRS》对系统总体功能进行测试与复审（开发者与客户）。</li><li>系统提交：交付产品【用户手册和操作手册】与复审。</li><li>系统维修：修改软件的过程，为改错或满足新需求【维修报告】与复审（维修团队）。</li></ol><blockquote><p>注：圆括号中的为测试人员，方括号为生成的文档。</p></blockquote><p>额外说明（了解）：以上阶段只是大致的划分，软件团队实际执行时比这要复杂，还有若干辅助性过程和阶段，而有些阶段实际是相互重叠、相互影响的。</p><h2 id="开发团队的成员"><a href="#开发团队的成员" class="headerlink" title="开发团队的成员"></a>开发团队的成员</h2><p>需求分析人员、设计人员、程序员、测试人员、培训人员、维护人员、资料管理人员、配置管理人员。</p><p>软件工程各阶段各自的工作：（了解）</p><ul><li>需求设计（分析员、客户）：将客户想要的分解为离散需求。</li><li>系统设计（分析员、设计员）：生成系统层描述（系统要做什么）。程序设计（设计员、程序员）：实现指定需求的代码。</li><li>程序实现（程序员）：编代码。</li><li>单元测试（程序员、测试员）：发现各种错误。集成测试（测试团队）：检查系统功能。</li><li>系统测试（测试员、客户、培训员）：根据《SRS》检查要求。系统交付（培训员）：培训用户。</li><li>系统维修（维修团队）：寻找故障，根据客户需求变化，对系统作出修改。</li><li>资料管理（资料管理员）：维持一个软件的不同版本之间各种文档的对应关系，包括需求规格说明、设计描述、程序文档、培训手册、测试数据进度等。</li><li>配置管理（配置管理员）：维护需求、设计、实现和测试之间的对应关系。</li><li>软件架构师：属于高级程序员，侧重开发过程和模式的选择和论证（在国内和分析员差不多,其工作重点与分析员有所不同，但就开发来说，其工作似乎更重要些，而分析员的工作更偏重于市场与用户需求）。</li></ul><h2 id="软件工程发生了多大的变化"><a href="#软件工程发生了多大的变化" class="headerlink" title="软件工程发生了多大的变化"></a>软件工程发生了多大的变化</h2><h3 id="变化的本质"><a href="#变化的本质" class="headerlink" title="变化的本质"></a>变化的本质</h3><p>早期程序：线性输入，输出为字母数字，系统设计方式分为两种：转换(transformation)：将输入转换为输出；事务(transaction)：由输入决定哪个功能将被执行。因此瀑布模型开发方式可行。</p><p>当今程序：多系统运行，跨平台运行，基础功能：网络控制，安全性，用户界面表示和处理，以及数据或对象管理等。相较于早期变化巨大，瀑布模型不适用。</p><p><strong>使现代软件工程实践发生变化的七个关键因素</strong></p><ol><li><p>商用产品投入市场时间的紧迫性</p></li><li><p>计算技术在经济中的转变：更低的硬件成本，更高的开发、维护成本</p></li><li><p>功能强大的桌面计算的可用性</p></li><li><p>广泛的局域网和广域网</p></li><li><p>面向对象技术的采用及其有效性</p></li><li><p>使用窗口、图标、菜单和指示器的图形用户界面</p></li><li><p>软件开发瀑布模型的不可预测性</p></li></ol><p>说明（了解）：瀑布模型沿袭了传统系统工程的大规模批发制造的理念，假定生产活动为线性，这与现代软件的生产方式相矛盾。不再是有足够的灵活性和适应性来满足并行开发或并行运行这样的商业软件需求，因此不可预测。</p><p>结论（了解）：对一个系统进行划分，以便并行地开发其子系统，需要一个与瀑布模型有很大不同的开发模型。</p><h3 id="软件工程的-Wasserman-规范（或基本概念）"><a href="#软件工程的-Wasserman-规范（或基本概念）" class="headerlink" title="软件工程的 Wasserman 规范（或基本概念）"></a>软件工程的 Wasserman 规范（或基本概念）</h3><ol><li><p>抽象：基于某种层次归纳水平的问题描述。它使我们将注意力集中在问题的关键方面而非细节。</p></li><li><p>分析、设计方法和符号描述系统：</p><p>使用标准表示来对程序进行描述。利于交流，利于建模并检查其完整性和一致性，利于对需求和设计部件进行重用。</p></li><li><p>用户界面原型化(prototyping)：</p><p>建立系统的小型版,<br>通常具有有限的关键功能,以利于用户评价和选择，证明设计或方法的可行性。</p></li><li><p>软件体系结构：</p><p>定义一组体系结构单元及其相互关系集来描述软件系统。单元分解的方法</p><p>（以下了解）</p><ul><li>基于功能的模块化分解: 基于指派到模块的功能。</li><li>基于数据的分解: 基于外部数据结构。</li><li>面向事件的分解：基于系统必须处理的事件。</li><li>由外到内的分解：基于系统用户的输入。</li><li>面向对象的设计：基于标识的对象的类以及它们之间的相互关系。</li></ul></li><li><p>软件过程：软件开发活动中的各种组织及规范方法。</p><p>（以下了解）</p><p>因应用类型和组织文化之间的巨大差异,故难以对软件过程本身进行预先指定,也就是说:使过程本身规范化是不可能的.软件过程不可能以抽象和模块化的方式作为软件工程的基础。</p></li><li><p>重用或复用(reuse)：重复采用以前开发的软件系统中具有共性的部件,用到新的开发项目中去 (注: 这里的重用绝不仅仅是源代码的重用)。</p></li><li><p>测度或度量(measurement)：通用的评价方法和体系，有助于使过程和产品的特定特性更加可见，包括量化描述系统、量化审核系统。</p></li><li><p>工具和集成环境：通过框架比较软件工程环境提供的服务，以决定其好坏。工具：由于厂商很少针对整个开发生命周期，因此对于工具的比较集中于小的活动集，例如测试或设计。</p><p>（以下了解）</p><p>工具集成中必须处理的五个问题：(by Wasserman)</p><p>平台集成、表示继承、过程集成、数据集成、控制集成。</p></li></ol><p>总结：以上八个概念将软件工程作为一门科学学科，也是本书的八个线索。</p><h2 id="章末案例思考"><a href="#章末案例思考" class="headerlink" title="章末案例思考"></a>章末案例思考</h2><p>什么是软件危机？它有哪些典型表现？为什么会出现软件危机？</p><p>​软件危机：落后的软件生产方式无法满足迅速增长的计算机软件需求，从而导致软件开发与维护过程中出现一系列严重问题的现象。</p><p>​典型表现：</p><ol><li><p>对软件开发成本和进度的估计常常很不准确。</p></li><li><p>用户对”已完成”软件系统不满意的现象经常发生。</p></li><li><p>软件产品的质量往往靠不住。</p></li><li><p>软件常常是不可维护的。</p></li><li><p>软件通常没有适当的文档资料。</p></li><li><p>软件成本在计算机系统总成本中所占的比例逐年上升。</p></li><li><p>软件开发生产率提高的速度，远跟不上计算机应用迅速普及深入的趋势。</p></li></ol><p>出现的原因：一方面与软件本身的特点有关，另一方面也和软件开发与维护的方法不正确有关。</p><ol><li>软件缺乏”可见性”，管理和控制软件开发过程相当困难。</li><li>软件规模庞大，而且程序复杂性将随着程序规模的增加而呈指数上升。</li><li>开发时期引入错误，导致软件维护通常意味着改正或修改原来的设计，客观上使得软件较难维护。</li><li>软件专业人员对软件开发和维护中或多或少地采用了错误的方法和技术。</li></ol><h2 id="典型例题"><a href="#典型例题" class="headerlink" title="典型例题"></a>典型例题</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/06/6570536627349.jpeg"></p><p>答案：A</p>]]></content>
      
      
      <categories>
          
          <category> 大学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网网络层</title>
      <link href="/2023/12/05/%E8%AE%A1%E7%BD%91%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
      <url>/2023/12/05/%E8%AE%A1%E7%BD%91%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<blockquote><p>数据链路层保证了数据在相邻节点的可靠传输，网络层关注的是如何将源端数据包经过网络上的节点一路送到接收方。为了实现这个目标，网络层必须知道网络拓补结构，并从中选出适当的路径。本章包含到路由算法、拥塞控制、服务质量、网络互连和IP 协议。</p></blockquote><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/05/656f2b03d055b.png"></p><p>上图为本章考试重点，非原书结构，仅供参考。</p><h1 id="网络层两类服务"><a href="#网络层两类服务" class="headerlink" title="网络层两类服务"></a>网络层两类服务</h1><ul><li><p>无连接服务——数据报网络</p><p>特点：所有的数据包都被独立地注入到网络中，并且每个<strong>数据包独立路由</strong>，不需要提前建立任何设置。在这样的上下文中，数据包通常称为数据报，对应的网络称为数据报网络。</p></li><li><p>面向连接服务——虚电路网络</p><p>特点：发送数据报前，<strong>首先建立一条从源到目标的路径</strong>，每条报文都沿这条路径传送。这个连接称为虛电路，对应的网络称为虚电路网络。</p></li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/05/656f2c4948901.png"></p><h1 id="路由算法——基于最优路径的路由算法"><a href="#路由算法——基于最优路径的路由算法" class="headerlink" title="路由算法——基于最优路径的路由算法"></a>路由算法——基于最优路径的路由算法</h1><h2 id="最优化原则"><a href="#最优化原则" class="headerlink" title="最优化原则"></a>最优化原则</h2><p>遵循最优化原则以破除环路，方便设计路由算法。</p><p>最优化原则：如果J 在从I 到K 的最优路径上，那么从J 到K 的最优路径也必定遵循<br>相同的路由。即最优路径的子路径还是最优路径。</p><p>汇集树：依照最优化原则，从所有的源到一个指定目标的最优路径的集合构成一颗以目<br>标节点为根的树。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/05/656f2e2d8b9cc.png"></p><h2 id="泛洪算法"><a href="#泛洪算法" class="headerlink" title="泛洪算法"></a>泛洪算法</h2><p>泛洪路由的基本想法是源节点将消息以分组的形式发给其相邻的节点，相邻的节点再转发给它们的相邻节点，继续下去，直至分组到达网络中所有的节点。很显然，泛洪法会产生大量的重复数据包，除非采取某些措施来抑制泛洪过程，否则将会产生无限多的数据包。</p><h2 id="距离矢量路由算法DV（RIP-协议）"><a href="#距离矢量路由算法DV（RIP-协议）" class="headerlink" title="距离矢量路由算法DV（RIP 协议）"></a>距离矢量路由算法DV（RIP 协议）</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/06/6570360f20480.png"></p><p>每个路由器维护一张表，表中列出了当前已知的到每个目标的最短距离，以及所使用的线路的下一跳，通过在邻居之间相互交换信息，路由器不断地更新它们的内部表，最终每个路由器都了解到达目的地的最佳链路。届时就可以根据路由表和目的地址，在任意路由上确定下一跳进行跳转。</p><p>路由表的具体维护方式：当前点与所有邻居节点交换的路由表，然后根据这些表计算该点去所有其他点的最优下一跳<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/06/657036bc98270.png"></p><p>如上面的例子所示，当求点J 到点C 的最短距离和下一跳时，分别求出Ji+iC 的最小值，即min{8+25,10+18,12+19,6+36}&#x3D;28，最短路径是经过I，时长28。</p><p>无穷计数问题：“坏消息”传播的很慢，可以从下面的例子进行理解</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/06/65703680457ed.png"></p><p>如图所示，ABC 各自维持自己的路由表，但如果AB 之间的线路突然断开，那么B 和C 在计算各自与A 的距离的时候，就会互为参考，每次路由表更新的时候计算出的与C 的距离只会加1 直到数值趋近于无穷，所以AB 之间的断开很慢被发现。</p><h2 id="链路状态路由算法LSP（OSPF、IS-IS-协议）"><a href="#链路状态路由算法LSP（OSPF、IS-IS-协议）" class="headerlink" title="链路状态路由算法LSP（OSPF、IS_IS 协议）"></a>链路状态路由算法LSP（OSPF、IS_IS 协议）</h2><p>每个节点都将自己的邻居信息表传给所有节点，每个节点都保存所有节点的邻居信息表，并使用Dijkstra 计算出本节点到其他所有节点的最短路。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/06/657038d6bcc43.png"></p><p>上面可以看到，邻居信息表中都包含两个字段：Seq 和Age。</p><p>Seq:由于邻居信息表需要泛洪给所有节点，为了控制泛洪的规模，所以使用Seq 序号。新的链路状态数据包到达一个节点的时候，路由器检查这个新来的数据包的序号和源路由器是否已经出现在自己的列表中。重复则丢弃，源路由器相同而序号过时则拒绝接受。</p><p>Age:在数据包发出时设定初值，然后每一秒都会减一，变为0 则会被丢弃，①可以在泛洪时防止数据包无限生存②及时清理路由器中链路状态数据库中旧的或无效的信息，以防以下问题的影响，如：路由器崩溃后重启序号从0 开始的话会被当做过时信息丢弃；传递过程中序号出现差错如4 变65540，那么只有seq 字段就会导致后面的5-65539 全被拒绝。</p><p>算法步骤：</p><ol><li>发现邻居节点，并知道其网络地址</li><li>测量到各邻居节点的延迟或开销</li><li>构造一个分组，分组中包含所有它刚知道的信息</li><li>将这个分组发送给所有其他的路由器</li><li>计算出到每一个其他路由器的最短路径</li></ol><p><strong>务必重点掌握距离矢量算法和链路状态算法</strong>，详见中文课本P285—P291</p><p>因为距离矢量算法每个节点只与邻居节点交换信息，在面临路由器失效时会出现无穷计数问题。链路状态算法用泛洪的方式分发链路状态包，所以每个节点都知道完整的网络加权0拓补图，重点在链路状态包的构造和分发方法以及健壮性。</p><h2 id="层次路由"><a href="#层次路由" class="headerlink" title="层次路由"></a>层次路由</h2><p>随着网络规模的增长，路由器的路由表也成比例增长，结果是路由器效率下降，成为网络服务的瓶颈。解决之道是将网络分层，采用分层路由之后，路由器被划分成区域，每个路由器知道如何将数据包路由到自己所在区域内的目标地址，但是对于其他区域的内部结构毫不知情。</p><p>可以认为每个区域是一个村，普通村民知道如何与本区域所有其他人联系，而村长除此之外还知道如何与别的村的村长联系，村民与外村人联络时会先将信交给村长由村长转发，他负责本区域与其他区域的联络。后面IP 协议的子网划分中的分类寻址就是层次化的设计。</p><h1 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h1><p>主要掌握RED 协议，完整的流量控制应该是网络层（RED 协议）和传输层（TCP 慢启动）配合的任务。</p><p>拥塞：网络中存在太多数据包导致数据包被延迟和丢失，从而降低了传输性能。当拥塞出现后，有可能遭遇拥塞崩溃。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/11/29/6566f58bf0add.png"></p><p>随机早期检测（RED）（P310）<br>当某条链路上的平均队列长度超过某个阈值时，该链路就被认为即将拥塞，因此路由器随机丢弃一小部分数据包。</p><p>当拥塞时，若路由器向发送方发抑制包，那么大量的抑制包反而会加重拥塞。所以网络层解决拥塞的思路就是防患于未然，在局面变得毫无希望前让路由器舍弃负担。后面配合传输层可以降低用户发送速率，从根本上解决拥塞。</p><h1 id="流量整形——平滑的流量更好管理"><a href="#流量整形——平滑的流量更好管理" class="headerlink" title="流量整形——平滑的流量更好管理"></a>流量整形——平滑的流量更好管理</h1><p>流量整形（traffic shaping）是指调节进入网络的数据流的平均速率和突发性所采用的技术，包括漏桶和令牌桶。</p><ul><li>漏桶算法：无论注入桶内的速率是大是小，出桶的速率总是恒定的。</li><li>令牌桶算法：桶内存放发送数据的令牌，每单位时间获得一定量的令牌，发送数据时取出令牌，流量大小受限于积累的令牌数量。一般令牌桶下面会有一个漏桶用于平滑发送速率。</li></ul><h1 id="IPv4-协议"><a href="#IPv4-协议" class="headerlink" title="IPv4 协议"></a>IPv4 协议</h1><p>层与层之间数据的传递：上层整段消息内容是对下一层透明的数据</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/06/65703a13452c5.png"></p><h2 id="IP-头"><a href="#IP-头" class="headerlink" title="IP 头"></a>IP 头</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/06/65703ef2d7be6.png"></p><p>IP 协议Internet Protocol 提供尽最大努力的数据传输，不保证可靠</p><p>IP 数据报由头和正文组成，正文是有效净荷，携带数据；头由20 字节定长及一个可选变长组成，携带此数据报的解释信息。下面是IP 头的相关介绍。</p><ol><li>版本：记录数据报属于什么版本，Ipv4 Ipv6</li><li>IHL：IP 头长，单位为4 字节，因为头部至少20 字节定长，所以值域5~15。</li><li>区分服务：前6 位标识数据报服务类型，后2 位携带显示拥塞信息，了解。</li><li>总长度：数字报总长度，单位是1 字节（8bit），包括头和数据，最大长度216 字节</li><li>生存期TTL：计数单位为跳数，每经过一跳减一，递减到0 的时候数据包被丢弃并由路由器给源地址发送一个报警包。设定目的主要解决环路问题，避免数据包被永远都留在网路中。不同协议的技术单位不同，有的还设定为秒，这是为了控制拥塞，但是秒不好实现。</li><li>协议：记录IP 分组携带数据的协议类型，即传输层协议的编号，如TCP、UDP 等</li><li>头校验和：对IP 头信息进行校验，检测数据包穿过网络时是否发生错误。但是由于只校验了头，所以IP 数据报整体依旧不可靠</li><li>源地址和目的地址：源地址可以用于丢包时给源地址发消息；目的地址用于寻找路径时查路由表</li><li>选项：给出对寻址过程中要求必须经过的路由器，如今，几乎已经不再使用IP 选项</li><li>IP 头第二行都是关于分段的处理，其用途就是：不同网络的最大帧长的要求可能不同，从而大数据进入小网络需要对大的数据进行分段。标识表示这段分段属于哪个数据报：DF 表示是否允许分段，DF&#x3D;1 表示该数据报不允许分段，到达需要分段的地方就丢包返回消息；MF 表示所属于的数据报是否还有更多的段。MF&#x3D;0 表示当前分段是该数据报的最后一段；分段偏移量表示该分段在整个数据包中的位置，以8 字节为单位。具体计算此处不再详细介绍，这一行了解即可。</li></ol><h2 id="分类寻址Classful-Addresing"><a href="#分类寻址Classful-Addresing" class="headerlink" title="分类寻址Classful Addresing"></a>分类寻址Classful Addresing</h2><p>IP 地址被分为五类。如A 类允许27 个网络，每个网络中允许有224 台主机，由于每类网络中允许的主机数量是固定的，所以造成了IP 地址极大的浪费，这才引入了后面的CIDR</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/06/65703fde4d64b.png"></p><h2 id="子网Subnet-与前缀prefix"><a href="#子网Subnet-与前缀prefix" class="headerlink" title="子网Subnet 与前缀prefix"></a>子网Subnet 与前缀prefix</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/06/65704054be34e.png"></p><ol><li>IP 地址长32 位，由高位的可变长网络号和低位的主机号组成，同一网络上所有主机的网络号相同，一个网络对应一块连续的IP 地址空间，这块地址空间就被称为地址的前缀</li><li>写法：点分十进制，如18.0.31.0&#x2F;24，24 表示网络号位数。子网掩码是网络号长度个1 和主机号长度个0 组成，子网掩码和IP 按位与可以得到网络号</li><li>子网划分subnetting：在内部将一个网络块分成几个部分供多个内部网络使用，但对外部世界仍然像是单个网络一样。而第一章的子网subnet 是分割一个大型网络得到的一系列结果网络，是指网络中所有路由器和通信线路的集合。</li><li>转发过程：数据报到达后，路由器检查该数据包的目的地址，将该目的地址与路由表中每个子网目标的子网掩码按位与看是否匹配</li></ol><h2 id="无类域间路由CIDR"><a href="#无类域间路由CIDR" class="headerlink" title="无类域间路由CIDR"></a>无类域间路由CIDR</h2><p>Classless Inter-Domain Routing，是为解决IP 路由表爆炸、IP 地址耗尽而提出的一种措施。在变长子网掩码的基础上提出的一种消除ABCDE 类网络划分，并且可以在软件的支持下实现构造超网的一种IP 地址的划分方法。</p><p>子网划分与聚合的一个实例：以下页图为例用一块从194.24.0.0 开始的大小为213 的地址分配三个大学的地址。计算过程如下。其中每个地点的两行分别代表该地的起始和终止IP 地址。竖虚线为网络号和主机号划分。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/06/657040ea02b46.png"></p><p>分配的原则是：一个网路只能有一个网络号，进行IP 地址分配时尽可能连续分配。以牛津大学为例，尽管前面余下210 个空白，但是依旧选择向后。</p><p>路由聚合rounte aggregation：为了减小路由表长度，将多个小前缀地址块合并为一个大前缀地址块，如上面的三个地址就可以聚合成一个地址，方法是将三者网络号最大公共部分聚合为新网络号<br>194.21.0.0&#x2F;21<br>194.24.8.0&#x2F;22 → 194.24.0.0&#x2F;19<br>194.24.16.0&#x2F;20</p><p>如此，就可以将三个路由表项合成一个，其下一跳是伦敦。但由此带来一个问题：如果上面空白的那部分被分配给非洲某学校，那么空白部分就会被错误的聚合。因此要在路由表中新增一项单独指明空白部分的下一跳。</p><p>所以，在没有聚合时，查路由只需要找到匹配的一项就可以跳到下一跳，但是有聚合以后，需要寻找路由表项中的最长匹配</p><p>路由器的转发过程完善如下：当新的消息进入路由器时，首先进入等待队列，通过一定的调度策略进行调度。调度到这个消息时，获取其目的地址，将目的地址分别与路由表中的每一项网络号的子网掩码进行比对，选取最长匹配的网络表项进行转发。当然，没有查询到匹配的时候，转发到缺省表项，也就是给上一层路由，继续寻找。</p><h2 id="NAT-网络地址转换"><a href="#NAT-网络地址转换" class="headerlink" title="NAT 网络地址转换"></a>NAT 网络地址转换</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/06/6570419dd9c6a.png"></p><ol><li>IP 地址短缺问题解决策略：①动态分配IP ②迁移到IPv6 ③多台共用一个IP</li><li>NAT(Network Address Translation)，它的思想是设定两套IP 地址,内网相对于外网来说共用一个public 地址，而在内网中，每台机器对应一个private 地址</li><li>内网之间的通信使用private 地址，当想要向外网发送消息时，只需将源地址替换为内网共用的public 地址</li><li>当外网向内网发送消息时，因无法区分内网的主机，所以引入了port。将私有IP与端口号影射成新的port，当与这个端口号交互时，根据影射算法可以知道私有IP</li><li>缺点：①违反了最基本的协议分层原则，传输层的数据不再对网络层透明②私有IP 与port 对公有port 的映射关系不是一一对应的③违反IP 唯一性原则等。</li></ol><h2 id="隧道技术"><a href="#隧道技术" class="headerlink" title="隧道技术"></a>隧道技术</h2><p>隧道技术（tunneling）：是一种通过使用互联网络的基础设施在不同网络之间传递数据的方式。使用隧道传递的数据（或负载）可以是不同协议的数据帧或包。隧道协议将其它协议的数据帧或包重新封装然后通过隧道发送，到达对方以后再将被包裹的数据提取出来进行传递。新的帧头提供路由信息，以便通过互联网传递被封装的负载数据。</p><p>简言之，就是处理不同网络相连接的情形，隧道技术对于两头网络相同中间不同的特例有效。它的方法就是在经过中间网络的时候加一个新的IP 头，度过以后再拆掉。</p><h1 id="Internet-控制协议"><a href="#Internet-控制协议" class="headerlink" title="Internet 控制协议"></a>Internet 控制协议</h1><h2 id="ICMP-控制消息协议"><a href="#ICMP-控制消息协议" class="headerlink" title="ICMP 控制消息协议"></a>ICMP 控制消息协议</h2><p>为了提高IP 数据报交付成功的机会，在网络层使用了网络控制报文协议来允许主机或者路由器来报告差错和异常情况。了解即可，详见P358。ICMP 是通过向数据包的源地址报告有关事件使网络运行正常。</p><h2 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h2><p>Address Resolution Protocol，地址解析协议是一个连接二三层的协议，可以说是IP 分组-帧连接协议。</p><p>某一层的地址只在本层有效，网络层负责寻找路径，而真正实现消息传递的是链路层，所以要实现两层地址之间的映射。</p><h3 id="路由器之间消息的传递"><a href="#路由器之间消息的传递" class="headerlink" title="路由器之间消息的传递"></a>路由器之间消息的传递</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/06/657042462a6ed.png"></p><p>现在的关键在于已知源IP、源MAC 和目的IP 的情况下怎样获取目的MAC</p><h3 id="交换机原理"><a href="#交换机原理" class="headerlink" title="交换机原理"></a>交换机原理</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/06/6570426ac07e8.jpg"></p><p>在上图中的交换机中存储着一张MAC 和port 的对应表，交换机的一个端口和一台主机一一对应。只有发送过消息的端口的对应关系才会被交换机所知道，而一个广播能同时将一个子网的全部对应关系都传送给交换机。</p><h3 id="同一子网中消息的传递"><a href="#同一子网中消息的传递" class="headerlink" title="同一子网中消息的传递"></a>同一子网中消息的传递</h3><p>如上，主机1 欲给主机2 发消息，应首先经过如下两个过程：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/06/657042a021d67.png"></p><h3 id="不同子网消息的传递"><a href="#不同子网消息的传递" class="headerlink" title="不同子网消息的传递"></a>不同子网消息的传递</h3><p>E3 作为通往外网的代理分析广播的接收方是否在这个子网中。若目的IP 与E3 所在网络号相同那么E3 就当做一个普通主机，否则提交到路由器的网络层，而E3 则作为这条消息的代理与网外交互。</p><p>而在路由表中找到对方所属的子网以后，在该子网中通过ARP 广播找到该IP</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/06/657042c6734dc.png"></p>]]></content>
      
      
      <categories>
          
          <category> 大学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网介质访问控制子层</title>
      <link href="/2023/12/04/%E8%AE%A1%E7%BD%91%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/"/>
      <url>/2023/12/04/%E8%AE%A1%E7%BD%91%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<blockquote><p>该层是用来确定多路访问信道下一个使用者的协议属于数据链路层的一个子层，称为介质访问控制（Medium Access Control) 子层，也叫MAC 子层。注意这章的标题是“子层”，也就是说这一章的内容还是属于数据链路层，是它的一个子层，虽然出现的章节比第三章要晚，但实际上却是整个数据链路层的底层。</p><p>因为在同一介质中相同频率波段的传输信号会相互干扰，导致无法得到有效的信号，而采用频率，时间区别不同信号又无法最大限度地利用资源，这时候就希<br>望有种协议可以协商三个以上的机器如何可以在没有统一调度的前提下“遵守秩序”“不打断别人”地发言，让介质顺利被利用不产生冲突。数据链路层的两点之间可靠传输有个前提，首先要确定到底是哪个点可以获得信道开始传输。所以说这一章内容是数据链路层的底层。</p></blockquote><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/05/656eabaf2b413.png"></p><p>上图为本章考试重点，非原书结构，仅供参考。</p><h1 id="多路访问协议"><a href="#多路访问协议" class="headerlink" title="多路访问协议"></a>多路访问协议</h1><h2 id="ALOHA-系统"><a href="#ALOHA-系统" class="headerlink" title="ALOHA 系统"></a>ALOHA 系统</h2><h3 id="纯ALOHA"><a href="#纯ALOHA" class="headerlink" title="纯ALOHA"></a>纯ALOHA</h3><p>用户有数据就发送，不考虑信道是否空闲，只管发。用户如果发现有冲突，则随机等待一段时间后再发。它的意义在于提出了非协调用户竞争使用单个共享信道的系统的问题，现实中已不使用，详见P203。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/05/656f0f4384ba4.png"></p><h3 id="分槽ALOHA"><a href="#分槽ALOHA" class="headerlink" title="分槽ALOHA"></a>分槽ALOHA</h3><p>为了提高发送的容量，将时间分成了离散的间隔，称为时间槽，用户只能在槽边界发数据，减少了冲突期，将吞吐量提升了一倍。详见P204，P205</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/05/656f0fdc59e61.png"></p><h2 id="CSMA"><a href="#CSMA" class="headerlink" title="CSMA"></a>CSMA</h2><p>载波检测多路访问（Carrier Sense Multiple Access）指每个站监听线路上是否有载波（传输），并据此采取相应的动作的方式。相比ALOHA的先发后听，这是先听后说，大大地提高了利用率。</p><h3 id="1-坚持，0-坚持，p-坚持的CSMA"><a href="#1-坚持，0-坚持，p-坚持的CSMA" class="headerlink" title="1 坚持，0 坚持，p 坚持的CSMA"></a>1 坚持，0 坚持，p 坚持的CSMA</h3><ul><li>1 坚持：当一个站有数据要发送时，它首先侦听信道，确定当时是否有其他站正在传输数据；如果信道空闲，就发送数据，如果信道忙，该站持续坚持监听信道，直到空闲，一旦监听到空闲，则站立即发送一帧。如果发生冲突，该站等待一段随机的时间，然后从头开始上述过程。这样的协议之所以称为1坚持，是因为当站发现信道空闲时，它传输数据的概率为1。</li><li>非坚持：如1 坚持一样监听信道如果空闲则发，然而如果信道当前正在使用中，则该站并不持续对信道进行监听。相反，它会等待一段随机时间，然后重复上述算法。因此，该算法将会导致更好的信道利用率，但是比起1-坚持也带来了更大的延迟。</li><li>P 坚持：以概率P 发送数据，以概率q&#x3D;1-P 将此次发送推迟到下一个时间槽发送。如果下一个时间槽也是空闲的，则它还是以概率P 发送数据，或以概率q 再次推迟发送。该过程一直重复，直到帧被发送出去，或者另一个站开始发送数据。属于两种方式的改良，直觉上保证了“有礼貌”地在信道上不打断其他站的传输且只在空闲的时候传输就可以解决多路访问的冲突问题。</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/05/656f11e4a816c.png"></p><p>但是这三个协议都没有解决在多个站同时监听到空闲后都发送时会导致的信号混杂从而冲突的情形，如果有协议保证站可以迅速监听到冲突后立即停止，则可以最大程度上节省了注定失败的传输所占用信道的时间和带宽，这种协议就是下面的带冲突检测的CSMA，也是现在以太网实际采用的协议。</p><h3 id="CSMA-CD"><a href="#CSMA-CD" class="headerlink" title="CSMA&#x2F;CD"></a>CSMA&#x2F;CD</h3><p>带冲突检测的CSMA（CSMA with Collision Detection）P207，P208</p><p>不止在发前监听信道，在信号发送过程中发送方也要持续监听信道，如果发现线路上的信号与自己发送的信号不一致（即产生了冲突），则立刻停止传输信息，发送一段48bit的阻塞信号告诉与自己发生冲突的站不要漏检这次冲突，之后它等待一段时间再发送。</p><p>如何确保发送方意识到冲突是这个协议着重解决的问题，也就是发送时间需要足够长，保证即使是另一端的产生冲突的信号传过来自己也还在发，不至于发完了不再监听信道后不知道自己这次的传输已经失败了。也就是说需要至少发满信号跑一个</p><h2 id="无线局域网协议"><a href="#无线局域网协议" class="headerlink" title="无线局域网协议"></a>无线局域网协议</h2><h3 id="无线局域网与有线局域网的不同"><a href="#无线局域网与有线局域网的不同" class="headerlink" title="无线局域网与有线局域网的不同"></a>无线局域网与有线局域网的不同</h3><ol><li>两者的传输介质有着本质区别，也正是这种区别，导致WLAN 存在新的问题：隐藏终端问题和暴露终端问题。</li><li>两者传输范围有区别：WLAN 中，无线电传输范围有限，一个站不能给所有其他站发送帧，也无法接收来自所有其他站的帧；在有线局域网中一个站发出一帧，所有其他站都能接收到。</li><li>信道检测方式不同：WLAN 采用能量检测、载波检测和能量载波混合检测三种检测信道空闲的方式；以太网通过电缆中电压的变化来检测。</li><li>在WLAN 中，对某个节点来说，其刚刚发出的信号强度要远高于来自其他节点的信号强度，也就是说它自己的信号会把其他的信号给覆盖掉，但在本节点处有冲突并不意味着在接收节点处就有冲突。</li></ol><p>详见p214</p><h3 id="MACA-冲突避免多路访问"><a href="#MACA-冲突避免多路访问" class="headerlink" title="MACA 冲突避免多路访问"></a>MACA 冲突避免多路访问</h3><p>（Multiple Access with Collision Avoidance）</p><h4 id="隐藏终端问题"><a href="#隐藏终端问题" class="headerlink" title="隐藏终端问题"></a>隐藏终端问题</h4><p>A 给B 发，但C 的信号接收覆盖范围没法覆盖到A，导致不知道A 在给B 发，误以为B空闲，一旦发送，则信号会冲突干扰，导致失效。可以看到，问题的关键在于C 无法知道B的接收情况，因为之前的监听是在发送方C 自己这里进行的。这个问题是致命的。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/05/656f13a2f02a3.png"></p><h4 id="暴露终端问题"><a href="#暴露终端问题" class="headerlink" title="暴露终端问题"></a>暴露终端问题</h4><p>B 给A 发，此时C 想要发送信号给D，但C 监听到介质上有信号传输，则会等待B 传输结束再进行给D 的传输，但实际上这种等待是不必要的因为C 即使发给D 也不会干扰A 的接收信号，因为干扰只在接收方端产生，所以这种问题带来了效率的降低，根源还是在于C不知道接收方A 的情况，只知道自己附近发送方B 的情况。但注意并不是致命的，因为还是没有破坏传输。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/05/656f13c97563a.png"></p><h4 id="RTS（Request-To-Send）和CTS-Clear-To-Send"><a href="#RTS（Request-To-Send）和CTS-Clear-To-Send" class="headerlink" title="RTS（Request To Send）和CTS (Clear To Send)"></a>RTS（Request To Send）和CTS (Clear To Send)</h4><p>为了解决上面两个问题，即之前的CSMA 只能监听到发送方附近而不是接收方附近介质情况根本问题，希望能通过协议让接收方也“发言”，即通过这次信号让接收方附近的站点也能感受到接收方的存在，从而避免后续的继续发送造成该接收方的冲突。<br>解决的方案就是发送方先发RTS，之后接收方回CTS 信号，并从这个信号中包含这次传输的持续时长信息保证让此时长内接收方附近站点主动静默，从而不会使其受到干扰。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/05/656f159406a73.png"></p><p>即一个点如果只听到RTS，没有听到CTS，说明它在发送方的发送范围内，却不在接收方的发送范围内，则它只要不干扰发送方收CTS，即可随便发送。解决了暴露终端问题。<br>一个点如果只要听到CTS 说明它就在接收方发送范围内，此时它要保持静默到持续时长，直到此次传输结束它再进行发送，否则会干扰接收方接收。解决了隐藏终端问题。</p><h3 id="CSMA-CA"><a href="#CSMA-CA" class="headerlink" title="CSMA&#x2F;CA"></a>CSMA&#x2F;CA</h3><p>带有冲突避免的CSMA（CSMA with Collision Avoidance）P234—P236。它是802.11 MAC 子层协议的核心协议，与之前的MACA 相比，它引入了短确认确保每<br>一帧的发送成功，即数据发送后站启动确认计时器，如果计时器时间到但没有收到接收方回复的收到的确认，则试图重新发送。但在RTS 和CTS 方面并没有考虑暴露终端问题。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/05/656f16037a609.png"></p><ol><li><p>RTS 和CTS</p><p>与MACA 类似，但是将规则改成了听到RTS 后也停止传输一切东西，直到此次数据传输结束后再进行传输。这样其实是无法解决暴露终端问题的，但由于考虑到暴露终端问题是效率问题而不是致命问题，且处理这个不经常发生的问题需要耗费操作时间，所以就进行了舍弃。</p></li><li><p>NAV 网络分配向量（Network Allocation Vector）P236</p><p>每个站保留的信道何时要用的逻辑记录，每个帧携带一个NAV 字段，说明这个帧所属的一系列数据将传输多长时间。所有听到数据帧的站将在发送确认期间推迟发送，不管能否真正听到确认的发送。</p></li><li><p>二进制指数后退的CSMA&#x2F;CA P220，P234</p><p>侦听很短的一段时间后发现没有信号，则随机选择0-15 个时间槽进行倒计时倒数，当听到有帧发送时暂停倒计时，空闲时计数，到0 时就发送，如果发送成功则目标站会发送一个短确认，如果没收到确认，则发送方加倍自己选择的时间槽数，重新试图发送。如此反复，直到成功发送帧或达到最大重传次数。</p></li></ol><h1 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h1><h2 id="经典以太网"><a href="#经典以太网" class="headerlink" title="经典以太网"></a>经典以太网</h2><p>经典以太网MAC 子层的帧格式</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/05/656f17977f22e.png"></p><p>具体字段内容解释见课本P218——P220，注意由于冲突检测要求有效数据必须大于64个字节，所以不算前导码的8 位，用户Data 段为0 时，此时帧的最短长度只有18 个字节，所以存在最长为46 字节的填充位（18+46 &#x3D; 64）.</p><h2 id="交换式以太网"><a href="#交换式以太网" class="headerlink" title="交换式以太网"></a>交换式以太网</h2><p>以交换机为核心设备而建立起来的一种高速网络。可在高速与低速网络间转换，实现不同网络的协同。交换机分割了连接的不同网络成为不同的冲突域，不同冲突域之间信号不会彼此干扰，所以不用考虑不同自治域间的冲突问题。</p><h1 id="交换机（网桥）"><a href="#交换机（网桥）" class="headerlink" title="交换机（网桥）"></a>交换机（网桥）</h1><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>网桥工作在数据链路层，将多个LAN 连接起来，通过检查数据链路层地址来转发帧。</p><ul><li>当一帧到达时，网桥必须决定是将该帧转发还是丢弃</li><li>如果决定转发，还必须要决定在哪个端口传输帧</li><li>网桥通过在其内部配备一个大的(哈希)表来查询一帧的目的地址，该表中列出了每一个可能的目的地址以及它隶属的输出端口</li><li>当网桥第一次被接入网络时，所有的哈希表都是空的，网桥使用洪泛算法完善哈希表。</li><li>其具体转发过程为：<ol><li>目的地址的端口与源端口相同，则丢弃该帧</li><li>目的地址的端口与源端口不同，则转发该帧到目的端口</li><li>目标地址端口未知，则使用洪泛算法，将帧发送到所有的端口，除了他入境的那个。</li></ol></li></ul><h2 id="目的地-端口哈希表（转发表）的获得"><a href="#目的地-端口哈希表（转发表）的获得" class="headerlink" title="目的地-端口哈希表（转发表）的获得"></a>目的地-端口哈希表（转发表）的获得</h2><p>泛洪算法：不需要知道网络的拓扑结构和相关的路由计算，仅要求接收到信息的节点以广播的形式转发数据包。</p><p>对于每个发向未知目的地址的入境帧，网桥将他输送到所有的端口，除了它到来的那个端口，慢慢的网桥学习到目标地址在哪里)和向后学习法(通过检查每个窗口上发送的所有帧的源地址，网桥就可获知通过那个窗口能访问到哪些机器。</p><h2 id="中继器-集线器-网桥-交换机-路由器-网关的对比"><a href="#中继器-集线器-网桥-交换机-路由器-网关的对比" class="headerlink" title="中继器&#x2F;集线器&#x2F;网桥&#x2F;交换机&#x2F;路由器&#x2F;网关的对比"></a>中继器&#x2F;集线器&#x2F;网桥&#x2F;交换机&#x2F;路由器&#x2F;网关的对比</h2><p>中继器：物理层，模拟设备，用于连接两根电缆段，放大信号。</p><p>集线器：物理层，有许多输入线路，它将这些输入线路连接起来，在任何一条线路上到达的帧都被发送到其他线路上。</p><p>交换机：数据链路层，多端口的网桥。根据帧的目的地址转发，常被用来连接独立计算机。</p><p>路由器：网络层，当一个分组进入到一个路由器中的时候，帧头和帧尾被剥掉，位于帧的IP 分组被传递给路由软件，路由软件利用分组的头信息来选择一条输出线路。</p><p>网关：传输层，应用层。应用网关是将一个网络与另一个网络进行相互连通，提供特定应用的网际间设备，应用网关必须能实现相应的应用协议。应用网关可设在应用层或传输层。设在应用层的叫应用层网关，也称代理服务器。设在传输层的叫传输层网关。</p>]]></content>
      
      
      <categories>
          
          <category> 大学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网数据链路层</title>
      <link href="/2023/12/03/%E8%AE%A1%E7%BD%91%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
      <url>/2023/12/03/%E8%AE%A1%E7%BD%91%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<blockquote><p>数据链路层是基于物理层不可靠的传输向上层提供可靠的传输，它提供的是相邻两个节点之间可靠的数据传输。本章将学习网络模型中的第二层（即数据链路层）的设计原则。学习内容涉及两台相邻（指两台机器通过一条通信信道连接起来）机器实现可靠有效的完整信息块（称为帧）通信的一些算法，而不像物理层那样只关注单个比特传输。解决通信线路中出错的情况、关于有限的数据传输率、发送时间和接受时间存在的非零延迟等问题。</p></blockquote><blockquote><p>本章内容结构：</p><ol><li>首先介绍数据链路层的关键设计问题，并学习如何考察错误的本质以及如何检测和纠正这些错误。</li><li>然后，我们将学习一系列复杂性逐步递增的协议，每个协议解决了本层中越来越多的问题。</li><li>最后会给出一些数据链路层协议的例子。</li></ol></blockquote><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/03/656c6a52e2155.png"></p><p>上图为本章考试重点，非原书结构，仅供参考。</p><h1 id="数据链路层的设计问题"><a href="#数据链路层的设计问题" class="headerlink" title="数据链路层的设计问题"></a>数据链路层的设计问题</h1><p>数据链路层使用物理层提供的服务在通信信道上发送和接受比特。完成一些功能：</p><ol><li>向网络层提供一个定义良好的服务接口。</li><li>处理传输错误。</li><li>调节数据流，保证慢速的接收方不会被快速的发送方淹没。</li></ol><p>为实现这些目标：，数据链路层从网络层获得数据包，并将之包装成包含：帧头+ 有效载荷（存放数据包）+ 帧尾的帧（frame）。</p><p><strong>数据链路层的工作核心就是帧的管理。</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/03/656c6c040e83e.png"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/03/656c6c55a859d.png"></p><p>帧的通用结构中前三项称为帧头。</p><h2 id="提供给网络层的服务"><a href="#提供给网络层的服务" class="headerlink" title="提供给网络层的服务"></a>提供给网络层的服务</h2><p>最主要的服务是将数据从源机器的网络层传输到目标机器的网络层。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/03/656c6cdd1bc89.png"></p><p>一般情况下，提供以下三种可能的服务：</p><ol><li><p>无确认的无连接服务。</p><p>源机器向目标机器发送独立的帧，目标机器不对这些帧进行确认。不需建立逻辑连接。适用于错误率低或者实时通信（语音传输）的情况。</p></li><li><p>有确认的无连接服务。</p><p>源机器向目标机器发送独立的帧，目标机器会对这些帧进行确认。不需建立逻辑连接。适用于不可靠的信道（无线系统，WiFi）。</p></li><li><p>有确认的有连接服务。</p><p>源机器和目标机器在传输任何一个数据之前要建立一个连接，保证目标机器按照正确的顺序接受每一个帧。适用于长距离且不可靠的链路（卫星信道，长途电话）。</p></li></ol><h2 id="成帧"><a href="#成帧" class="headerlink" title="成帧"></a>成帧</h2><p>为检测错误和纠正错误，数据链路层将比特流拆分成多个离散的帧，为每个帧计算一个称为校验和的短令牌，并将该校验和放在帧中一起传输。为拆分比特流需要解决两个问题：</p><ol><li>帧的边界问题：如何识别帧的边界</li><li>帧的透明传输（填充）问题：如果帧的数据中出现和边界一样的flag 该如何防止被识别为边界</li></ol><p>下面介绍四种成帧方法</p><ol><li><p>Character count（字节计数法）</p><p>用头部的一个字段来标识该帧中的字符数。<br>问题：因为一个传输错误，就会全弄混。很少被使用。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/03/656c7171f13a3.png"></p></li><li><p>Flag Bytes with byte stuffing（字节填充的标志字节法）</p><p>发送方使用标志字节（FLAG）作为开始和结束；使用转义字节（ESC）表示其后的字节为数据字节而不是标志字节或转义字节。接收方将收到的数据中的转义字节删除后再传递给网络层。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/03/656c71aef37a7.png"></p></li><li><p>Starting and ending flags,with bit stuffing（比特填充的标志比特法）</p><p>使用“01111110”表示帧的开始和结束（帧的边界问题解决），并且在数据中，若遇到5 个连续的比特1，就在其后填入一个比特0（帧的填充问题解决）。接收方除了将首尾的“01111110”删除外，还要将数据中所有5 个连续比特1 其后的比特0 删除。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/03/656c71e52f522.png"></p></li><li><p>Physical layer coding violation（物理层编码违禁法）</p><p>使用“不会出现在常规数据中”的冗余比特作为边界。好处是除了开始和结束的填充外，不再需要填充额外的数据。</p></li></ol><h2 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h2><p>为确保所有帧按照正确顺序传递给目标机器的网络层：</p><ul><li>发送方发送反馈信息来确保传递可靠。</li><li>引入计时器来防止硬件故障或通信信道出错等原因丢失某一帧使发送方持续等待确认。</li><li>通过序号保证每一帧按照顺序且不会被接收方重复接收。</li></ul><p>具体的确认方式在后面通过协议的形式来讲。</p><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>发送方发送帧的速度超过了接收方能够接收这些帧的速度，而导致丢帧。<br>解决方法：</p><ul><li>基于反馈的流量控制（链路层）。</li><li>基于速率的流量控制（网络层）。</li></ul><h1 id="差错检测和纠正"><a href="#差错检测和纠正" class="headerlink" title="差错检测和纠正"></a>差错检测和纠正</h1><h2 id="纠错码"><a href="#纠错码" class="headerlink" title="纠错码"></a>纠错码</h2><p>推断出被发送的数据是什么。适用于错误发生很频繁的信道，因为再次传输仍可能出错。</p><p>海明码（参考原书p159 ）：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/03/656c73b564262.png"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/03/656c73b511120.png"></p><h2 id="检错码"><a href="#检错码" class="headerlink" title="检错码"></a>检错码</h2><p>循环冗余校验码（CRC，Cyclic Redundancy Check，也称作多项式编码)，推断是否发生错误。适用于高度可靠的信道，错误偶尔发生时，只需重传整个数据块即可。注意有一定的误判率。<br>步骤：（以下面算式为例讲解，具体原理参见课本P165）</p><ol><li>收发双方商定一个比帧短且头尾都是1 的01 串叫做生成多项式，如下的10011</li><li>帧的后面附上生成多项式长度减一个0 后，作为被除数对生成多项式模2 除，得到<br>商和余数，如10011 长度为5，所以附上了4 个0</li><li>若帧与余数合并以后在接收方被生成多项式整除，那么认为传递的过程没有出错</li></ol><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/03/656c7680023ac.png"></p><p>模2除原则：列竖式的方式同除法，但是模2 除法中加法无进位，减法无借位，即加减皆等同于异或，而商0 还是1 由被除数首位决定，首位是1 商1，否则商0。</p><h1 id="基本数据链路层协议"><a href="#基本数据链路层协议" class="headerlink" title="基本数据链路层协议"></a>基本数据链路层协议</h1><p>组成帧的四个字段：kind、seq、ack 和info。前三个包含控制信息，称为帧头，最后一个可能包含了要被传输的实际数据。</p><h2 id="一个乌托邦式的单工协议（协议1）"><a href="#一个乌托邦式的单工协议（协议1）" class="headerlink" title="一个乌托邦式的单工协议（协议1）"></a>一个乌托邦式的单工协议（协议1）</h2><ul><li>不需考虑任何错误情况：数据单向传输，双方总是就绪，数据处理时间不计，缓存空间无限大，通信信道永不丢帧。</li><li>这是一个完全不现实（理想化）的协议，所以称为“乌托邦” 协议。</li><li>发送过程是一个无限的while 循环，它尽可能快速地把数据放到线路上。无差错控制或者流量控制方面的限制。接受过程一直等待一个未损坏的帧到达。（发送速率和接收速率必须一样快）</li></ul><h2 id="无错信道上的单工停-等式协议（协议2）"><a href="#无错信道上的单工停-等式协议（协议2）" class="headerlink" title="无错信道上的单工停-等式协议（协议2）"></a>无错信道上的单工停-等式协议（协议2）</h2><p>单向数据传输，发送方网络层一直有无限的数据要发送， 信道不会出错，从不损坏或丢失帧，发送方需等待接收方确认帧返回后才发送下一帧。如果接收方不反馈应答信号，则发送方必须一直等待，然后就陷入等待接收方确认信息的过程中，因而传输效率低。</p><h2 id="有错信道上的单工停-等式协议（协议3）"><a href="#有错信道上的单工停-等式协议（协议3）" class="headerlink" title="有错信道上的单工停-等式协议（协议3）"></a>有错信道上的单工停-等式协议（协议3）</h2><p>信道存在噪音。需要计时器与序号配合，需要超时重传机制。</p><h1 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>滑动窗口（sliding window）：为了便于理解，可以认为数据是一条传送带，而滑动窗口中的数据是当前准备处理的数据。一旦窗口的第一条数据被确认处理结束，窗口就会继续向后滑动以处理后面的数据。下面是发送方的发送窗口形象化的表示：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/03/656c785d76a99.png"></p><ul><li>捎带确认（piggybacking）：暂时延缓确认以便将确认信息搭载在下一个出境数据帧上的技术。捎带确认通常与累计确认一同使用，更好的利用了信道的可用带宽。</li><li>期望确认：收到数据帧以后向发送方发送期望对方发送的下一帧的序号。</li><li>累计确认（cumulative acknowledgement）：当n 号帧的确认到达，n-1 号帧、n-2号帧等都会自动被确认。</li><li>否定确认（NAK）：接收方检测到错误时发送的否定确认，实际是一个重传请求，在NAK中指定了要重传的帧。</li><li>发送窗口（sending window）：发送方总维持着一组序号，分别对应于允许它发送的帧，我们称这些帧落在发送窗口。</li><li>接收窗口(receiving window):接收方维持着的一个窗口对应于一组允许它接受的帧。</li></ul><h2 id="1-位滑动窗口协议（协议4）"><a href="#1-位滑动窗口协议（协议4）" class="headerlink" title="1 位滑动窗口协议（协议4）"></a>1 位滑动窗口协议（协议4）</h2><p>（发送窗口大小&#x3D;1，接收窗口大小&#x3D;1）</p><p>当接收窗口大小为1 时，可保证帧的有序接收，但效率较低。</p><p>源站发送单个帧后必须等待确认，在目的站的确认到达源站之前，源站不能发送其他数据帧。这是因为发送窗口大小仅为1，必须用来保存当前未确认的帧以超时重传。</p><p>发送方必须在内存中保存所有的帧，因此如果最大窗口的尺寸为n，则发送方需要n 个缓冲区才存放未被确认的帧。</p><h2 id="回退N-协议（协议5）"><a href="#回退N-协议（协议5）" class="headerlink" title="回退N 协议（协议5）"></a>回退N 协议（协议5）</h2><p>（发送窗口大小&gt;1，接收窗口大小&#x3D;1）</p><p>发送方按照顺序向对方发送帧，在收到对方的确认以后窗口向后滑动，若当前窗口中的第一个帧出现超时，那么回退到这个帧重新发送所有的帧。</p><p>而因为接收窗口大小为1，除了数据链路层必须要递交给网络层的下一帧外，接收方拒绝接受任何帧。如果在计时器超时以前，发送方的窗口已被填满，则管道将变为空闲，最终，发送方将超时，并且按照顺序重传所有未被确认的帧，从那个受损或者丢失的帧开始。</p><p>一般使用累计确认。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/03/656c79b03033b.png"></p><h2 id="选择重传协议（协议6）"><a href="#选择重传协议（协议6）" class="headerlink" title="选择重传协议（协议6）"></a>选择重传协议（协议6）</h2><p>（发送窗口大小&gt;1，接收窗口大小&gt;1）</p><p>发送方按照窗口的顺序依次发送帧给接收方，而接收方检查该帧是否可以落在接收窗口内，即以前没有接收过且该序号在窗口可接收的范围内，如果可以那么不管这一帧是否为网络层所期望的下一个数据包都接收该帧并暂存于缓冲区内。该帧会一直保存在数据链路层中直到所有序号比它小的帧已经按顺序递交给网络层，它才能被传递给网络层。</p><p>辅助计时器：在发送方的计时器超时之前，没有出现需要发送的反向流量，则发送一个单独的确认帧，而发送的时间间隔由辅助计时器决定，因此辅助计时器的超时间隔应该明显短于数据帧关联的计时器的间隔。</p><p>除ACK，选择重传还有否定确认，当接收方发现坏帧丢弃时，立刻发送一个NAC 给发送方告知该帧未收到让它重传，以防超时。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/03/656c79b052d99.png"></p><p>选择重传和回退N 实际是带宽使用效率与数据链路层缓存空间之间的权衡。</p><h1 id="数据链路协议实例"><a href="#数据链路协议实例" class="headerlink" title="数据链路协议实例"></a>数据链路协议实例</h1><p>这里要考察的是那些出现在Internet 两种常见情形下的数据链路协议，这些协议主要用在点到点的线路上。第一种情形是通过广域网中的SONET 光纤链路发送数据包。例如，这些链路被广泛用于连接一个ISP 网络中位于不同位置的路由器。</p><p>第二种情形是运行在Internet 边缘的电话网络本地回路上的ADSL 链路。这些链接把成千上百万的个人和企业连接到Internet 上。</p><p>针对上述这些使用场景Internet 需要点到点链路，还会用到拨号调制解调器、租用线路和线缆调制解调器等。所谓点到点协议（Point-to-Point Protocol) 的标准协议就是使用这些链路来发送数据包。PPP 由RFC1661 定义，并在RFC1662 中得到进一步的阐述(Simpson, 1994a， 1994b)。 SONET 和ADSL 链路都釆用了PPP, 但在使用方式上有所不同。</p><p>详见原书。</p>]]></content>
      
      
      <categories>
          
          <category> 大学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网物理层（二）</title>
      <link href="/2023/12/01/%E8%AE%A1%E7%BD%91%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2023/12/01/%E8%AE%A1%E7%BD%91%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>物理层是网络协议模型的最底层，该层定义了比特作为信号在信道上发送时相关的电气、时序和其他接口，是构建网络的基础。物理信道的不同特性决定了其传输性能的不同（比如，吞吐量、延迟和误码率），所以物理层是我们展开网络之旅的最好始发地。</p></blockquote><blockquote><p>本章内容结构：</p><ol><li>首先从数据传输的理论分析出发，探讨决定信道传输的自然局限。</li><li>接着给出三类传输介质：有线（铜线和光纤)、无线（陆地无线电）和卫星。每种技术都有其自身独特的性质，而这将影响到采用这些传输技术的网络设计和性能。这部分内容为我们理解现代网络的关键传输技术提供了背景知识。</li><li>然后讨论数字调制解调技术，主要解决如何把模拟信号转换成数字比特以及将数字比特还原成模拟信号。在此基础上，引入多路复用方案，探讨如何在同一个传输介质上同时进行多个会话而彼此不会干扰。</li><li>最后将关注三个被广泛应用于计算机广域网的通信系统实例：（固定）电话系统、移动电话系统和有线电视系统。</li></ol><p><strong>该篇博客将讨论后两部分。</strong></p></blockquote><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/11/30/65685de1320c5.jpg"></p><p>上图为本章考试重点，非原书结构，仅供参考。</p><h1 id="数字调制"><a href="#数字调制" class="headerlink" title="数字调制"></a>数字调制</h1><p>有线和无线信道运载模拟信号，模拟信号可表示成诸如连续变化的电压、光照强度或声音强度。为了发送数字信息，我们必须设法用模拟信号来表示比特。比特与代表它们的信号之间的转换过程称为<strong>数字调制</strong>（digital modulation）。</p><p>我们首先学习如何把数据比特直接转换成信号的一些方案。这些方案导致了所谓的<strong>基带传输</strong>（baseband transmission）,这是有线介质普遍使用的一种调制方法。然后我们将考虑通过调节载波信号的幅值、相位或频率来运载比特的调制模式。这些转换方案导致了<strong>通带传输</strong>（passband transmission）, 即信号占据了以载波信号频率为中心的一段频带。这是无线和光纤信道最常使用的调制方法，因为在这样的传输介质中只能在给定的频带中传输信号。</p><h2 id="基带传输（数字信号）"><a href="#基带传输（数字信号）" class="headerlink" title="基带传输（数字信号）"></a>基带传输（数字信号）</h2><ul><li><p>相关概念</p><p>带宽效率：带宽通常是一种有限资源，即使对有线信道也一样。信号频率越高衰减越大，其可用性就越小，而且高频信号还需要更快的电子设备。信号改变的速率称为符号率，以示区别于比特率。比特率是符号率与每个符号的比特数的乘积。</p><p>时钟恢复问题：存在一长串0 或1 时，经过较长时间会导致接收方无法准确判定信号的每个比特，比如15 个0 很像16 个0.</p></li><li><p>数字信号的表示方法<br><strong>下面所有例子的0 和1 表达方式可以交换，即0高1低可换成0低1高，无影响</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/03/656c32a04a0b4.png"></p><ol><li><p>不归零（NRZ，non-return-to-zero）：简单的将低电平表示为0，高电平表示为1。<br>问题：带宽效率低；较多连续的0 或1 导致接收方无法分辨每个比特。</p></li><li><p>不归零逆转（NRZI，non-return-to-zero）：0 时信号不发生变化，1 时信号跳变。<br>问题：可以对连续的1 进行区分，但是不能对连续的0 区分。</p></li><li><p>曼彻斯特编码（Manchester）：将数据信号与时钟信号通过异或方式混合在一起。<br>问题：带宽效率低（需要的带宽是NRZ 的两倍）。</p></li><li><p>差分曼特斯特编码：相对调相的编码，与时钟的表达很相近，但不同点是：若1 则在起始位置进行跳变，若为0 则不进行跳变。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/03/656c30fcd015c.png"></p><p><strong>注意</strong>：两种曼彻斯特编码的1、0 位的定义没有严格的要求，可以与上图表示的相反，只要在过程中完全一致即可</p></li><li><p>N 级编码：采用N 个信号级别，如用单个符号可以一次携带2 个比特，只要接收方可以辨识信号的四个级别即可。如二级编码。</p></li></ol></li></ul><h2 id="通带传输（模拟信号）"><a href="#通带传输（模拟信号）" class="headerlink" title="通带传输（模拟信号）"></a>通带传输（模拟信号）</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/03/656c371f32856.png"></p><p>y&#x3D;Asin(fx+φ)，下面的分别表示是改变A、f 和φ三个参数来区分不同信号</p><ol><li><p>幅移键控（ASK，amplitude shift keying）：不同的振幅表示0，1.</p></li><li><p>频移键控（FSK，frequency shift keying）：不同的频率表示不同的信号，如采用两个不同的频率分别表示0,1</p></li><li><p>相移键控（PSK，phase shift keying）：不同的相位表示不同的信号。在每个符号的周期中，把载波波形偏移0°或180°。更有效利用信道带宽的方法是<br>使用四个偏移（例如45°，90°，135°，180°），这样每个符号可以表示两个比特信息，这种方式被称为正交相移键控（QPSK,quadrature phase shift keying）。</p><p>上述1.2.3方法均为绝对调相（相连两位之间互不影响）。</p></li><li><p>相对调相（relative phase modulation）：相邻两位之间存在相互影响。若为1则跳变，若为0 则无变化，需要给出初始波形，和差分曼彻斯特类似。具体相位变化表示如下图</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/03/656c378fe591e.png"></p><p>例子如下所示（给出初始波形）：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/03/656c37b20eae7.png"></p></li></ol><h1 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h1><p>多路复用简单来说就是使多个信号可以共享同一传输路线。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/03/656c3a9ee40a8.png"></p><h2 id="频分复用"><a href="#频分复用" class="headerlink" title="频分复用"></a>频分复用</h2><p>频分复用（FDM，Frequency Division Multiplexing) 利用通带传输的优势使多个用户共享一个信道。它将频谱分成几个频段，每个用户完全拥有其中的一个频段来发送自己的信号。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/03/656c3a9ef314a.png"></p><h2 id="时分复用"><a href="#时分复用" class="headerlink" title="时分复用"></a>时分复用</h2><p>时分（TDM，time division multiplexing）指一条物理信道按时间分成若干个时间片轮流地分配给多个信号使用。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/03/656c3a9ecf1a3.png"></p><p>例如：下图中，ABCD分别为四个用户，每个用户只在对应的时隙里传输自己的数据。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/03/656c3a9f23044.png"></p><h2 id="波分复用"><a href="#波分复用" class="headerlink" title="波分复用"></a>波分复用</h2><p>波分（WDM，wavelength division multiplexing）是频分多路复用的一种，利用光纤信道的巨大带宽，同一光纤可以同时传输一组不同波长的光信号，并且不会互相影响。简单来说就是光的频分多路复用。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/03/656c3a9f3d575.png"></p><h2 id="码分复用"><a href="#码分复用" class="headerlink" title="码分复用"></a>码分复用</h2><p>码分复用（CDM，Code Division Multiplexing)是扩展频谱通信的一种形式，完全不同于FDM 和CDM，它把一个窄带信号扩展到一个很宽的频带上。广泛应用于无线链路共享。</p><h1 id="公共电话交换网络"><a href="#公共电话交换网络" class="headerlink" title="公共电话交换网络"></a>公共电话交换网络</h1><p>（PSTN，public switched telephone network）</p><ul><li>PSTN 是一种常用的旧式电话系统，提供的是一个模拟的专用通道，通道之间经由若干电环交换机连接而成，当两台主机或路由器需通过PSTN 连接时，必须在网络接入侧使用调制解调器实现信号的模数&#x2F;数模转换。</li><li>电话系统的组成：本地回路、中继线（多路复用）和交换局（交换机、交换技术如虚电路交换和分组交换等）</li></ul><h2 id="本地回路"><a href="#本地回路" class="headerlink" title="本地回路"></a>本地回路</h2><p>本地回路常常称为“最后一英里”，将涉及电话调制解调器、ADSL（非对称数字用户线） 以及光纤到户三部分。</p><ul><li>执行数字比特流和模拟信号流之间转换的设备称为调制解调器, 调制解调器是调制器和解调器的缩写。</li><li>己部署的铜质本地回路限制了ADSL 和电话调制解调器的性能。为了让它们运行得更快，电话公司逐步升级本地回路，把光纤一路拉到家庭住宅和办公楼，这种改进结果就是所谓的光纤到户。</li></ul><h2 id="中继线和多路复用"><a href="#中继线和多路复用" class="headerlink" title="中继线和多路复用"></a>中继线和多路复用</h2><p>电话网络中的中继线不仅比本地回路快得多，而且在其他两个方面与本地回路也有所不同。首先，电话网络核心传送的是数字信息而不是模拟信息，即传的是比特而不是声音。为了在长途中继线上传输数字形式，需要在端局对信号进行一次转换。其次，中继线上同时正进行着数以千计，甚至上百万的电话呼叫。这种多个电话共享一根中继线的方式对于实现规模经济非常重要，因为在两个电话端局之间安装和维护高带宽中继线所需要的基本开销和安装并维护一个低带宽中继线所需的费用差不多。高带宽中继线的共享可通过<strong>TDM</strong>和<strong>FDM</strong> 多路复用方法实现。</p><h2 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h2><p>站在普通电话工程师的角度，电话系统分为两个基本部分：局外部分（本地回路和中继线，因为从物理位置来看，看它们都位于交换局外部）和局内部分（交换机，它们在交换局内部）。</p><p>当前，电话系统中用到了两种不同的交换技术：电路交换和数据包交换。传统的电话系统基于电路交换技术，但随着IP 技术之上的语音通信兴起，数据包交换已经取得了长足的进步。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/03/656c40bda4d63.png"></p><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><ul><li>（面向连接）电路交换是以电路连接为目的的交换方式，通信之前要在通信双方之间建立一条被双方独占的物理通道。一旦一个呼叫被建立起来，在两端之间的专用路径被建立就会持续到该次呼叫结束为止。</li><li>电路交换的三个阶段：建立连接、通信、释放连接</li></ul><h3 id="包交换"><a href="#包交换" class="headerlink" title="包交换"></a>包交换</h3><ul><li>（非连接）路由器采用存储-转发技术，把经过它的每个数据包（根据网络线路、包的目的地址等条件）发送到通往该包目的地的路径上，没有固定的路径每个包都可以都不同的路径，所以它们到达的顺序可能出现混乱。</li><li>出现的问题：排队延迟（queuing delay）：数据包可能会因为存在很多包要被转发而需要等待一段时间才能到它被转发，还可能引起拥塞。</li></ul><h1 id="移动电话系统"><a href="#移动电话系统" class="headerlink" title="移动电话系统"></a>移动电话系统</h1><p>移动电话系统可用于广域范围的语音通信和数据通信。移动电话有时称为蜂窝电话。它的发展已经历了三代，俗称1G、2G 和3G 每一代有不同<br>的技术：</p><ol><li>模拟语音</li><li>数字语音</li><li>数字语音和数据</li></ol><h1 id="有线电视"><a href="#有线电视" class="headerlink" title="有线电视"></a>有线电视</h1><p>前面学习了固定电话系统和无线电话系统。很明显，在将来的网络中，它们都将继续扮演着重要的角色。然而，在过去10 年间还出现了另一种可用于Internet 接<br>入的方法：即有线电视网络。</p><p>具体有关有线电视系统的信息，请参见原书。</p>]]></content>
      
      
      <categories>
          
          <category> 大学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网物理层（一）</title>
      <link href="/2023/11/30/%E8%AE%A1%E7%BD%91%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2023/11/30/%E8%AE%A1%E7%BD%91%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>物理层是网络协议模型的最底层，该层定义了比特作为信号在信道上发送时相关的电气、时序和其他接口，是构建网络的基础。物理信道的不同特性决定了其传输性能的不同（比如，吞吐量、延迟和误码率），所以物理层是我们展开网络之旅的最好始发地。</p></blockquote><blockquote><p>本章内容结构：</p><ol><li>首先从数据传输的理论分析出发，探讨决定信道传输的自然局限。</li><li>接着给出三类传输介质：有线（铜线和光纤)、无线（陆地无线电）和卫星。每种技术都有其自身独特的性质，而这将影响到采用这些传输技术的网络设计和性能。这部分内容为我们理解现代网络的关键传输技术提供了背景知识。</li><li>然后讨论数字调制解调技术，主要解决如何把模拟信号转换成数字比特以及将数字比特还原成模拟信号。在此基础上，引入多路复用方案，探讨如何在同一个传输介质上同时进行多个会话而彼此不会干扰。</li><li>最后将关注三个被广泛应用于计算机广域网的通信系统实例：（固定）电话系统、移动电话系统和有线电视系统。</li></ol><p><strong>该篇博客将讨论前两部分。</strong></p></blockquote><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/11/30/65685de1320c5.jpg"></p><p>上图为本章考试重点，非原书结构，仅供参考。</p><h1 id="数据通信的理论基础"><a href="#数据通信的理论基础" class="headerlink" title="数据通信的理论基础"></a>数据通信的理论基础</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ol><li><p>带宽（bandwidth）：在传输中不会明显减弱的频率的宽度，通常引用的带宽是指从0 到使得接收能量保留一半的那个频率位置，是传输介质的一种物理属性。通常取决于介质的构成、厚度、电线或者光纤的长度。</p></li><li><p>信噪比（SNR）：信号功率S 与噪声功率N 的比值，即为信噪比S&#x2F;N。</p></li><li><p>分贝（dB）：通常把信噪比表示成对数的形式10log10S&#x2F;N，对数的取值单位称为分贝。信噪比为100 可表示为20dB。</p></li></ol><h2 id="计算信道的最大数据传输速率"><a href="#计算信道的最大数据传输速率" class="headerlink" title="计算信道的最大数据传输速率"></a>计算信道的最大数据传输速率</h2><ol><li><p>尼奎斯特定理Nyquist<br>用来表示一个有限带宽的无噪声信道的最大数据传输率。<br>表达式：(每秒2B 次采样)最大数据速率&#x3D;2Blog2V（比特&#x2F;秒）<br>B:带宽     V:离散级数，即可识别的信号个数</p></li><li><p>香农定理Shannon<br>用来表示一条带宽为B Hz，信噪比是S&#x2F;N 的有噪声信道的最大数据传输率或容量。<br>表达式：最大数据传输率&#x3D;Blog2(1+S&#x2F;N)（比特&#x2F;秒）<br>B:带宽     S&#x2F;N:信噪比</p></li></ol><h1 id="引导性传输介质"><a href="#引导性传输介质" class="headerlink" title="引导性传输介质"></a>引导性传输介质</h1><p>物理层的作用是将比特从一台机器传输到另一台机器。实际传输所用的物理介质大致上可以分为引导性介质（也称为有线介质，比如铜线和光纤）和非引导性介质（也称为无线介质，比如地面无线电、卫星和激光）两大类。这里探讨引导性传输介质，在下节探讨非引导性传输介质。</p><h2 id="磁介质"><a href="#磁介质" class="headerlink" title="磁介质"></a>磁介质</h2><ul><li>磁介质是将数据写到磁带或其他可擦写介质上（例如可刻录DVD)，然后用物理的方法将磁带或者磁盘运送到目标机器，再将数据从磁带或磁盘里读出来。</li><li>特点：有良好的带宽，但是延迟高。</li></ul><h2 id="双绞线（twisted-pair）"><a href="#双绞线（twisted-pair）" class="headerlink" title="双绞线（twisted pair）"></a>双绞线（twisted pair）</h2><ul><li><p>原理：两根线绞在一起，噪音对他们的干扰是一样的，所以他们的电压差不会改变，通过电压差来表示信号。</p></li><li><p>类型：</p><p>双绞线可以分成几大类。部署在许多办公大楼内的称为5 类线（Category 5) 或“猫5”(Cat 5)。5 类双绞线由两根绝缘导线轻轻地扭在一起，4 对这样的双绞线被套在一个塑料保护套内。塑料外套既保护了双绞线又把多根导线捆在一起，如图2-3 所示。</p><p>5 类线取代了早期的3 类线，每米内的双绞线扭得更紧了，可以导致更少的串扰，而且在长距离传输过程中还能使信号质量更好。</p><p>新双绞线很有可能是6 类甚至是7 类线。这些类别的双绞线具有更严格的规范来处理高带宽信号。某些6 类和更髙类的双绞线信号速率高于500 MHz, 可以支撑10 Gbps 的链路。这些双绞线将很快得到部署。</p></li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/11/30/65686338195a1.png" alt="2-3.png"></p><ul><li><p>概念：</p><p>全双工链路（full-duplex）：可以双向同时用</p><p>半双工联路（half-duplex）：可以双向使用但每一时刻只允许使用一个方向</p><p>单工链路（simplex）：只允许一个方向传输</p></li></ul><h2 id="同轴电缆（coaxial-cable）"><a href="#同轴电缆（coaxial-cable）" class="headerlink" title="同轴电缆（coaxial cable）"></a>同轴电缆（coaxial cable）</h2><ul><li><p>结构：(自内到外)铜芯，绝缘材料，编织外层导体，保护塑料外套，如图2-4</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/11/30/65686524ac2ef.png" alt="2-4.png"></p></li><li><p>优点：很高的带宽，很好的抗噪性。</p></li></ul><h2 id="电力线"><a href="#电力线" class="headerlink" title="电力线"></a>电力线</h2><ul><li>用电力线组建网络十分便利性，只需简单地把电视机和接收器插入墙上的电源插座，它们就可以通过电线发送和接收电影了，如图2-5 所示。</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/11/30/656865f42c3db.png" alt="2-5.png"></p><ul><li>家庭网络使用电力线的困难在于电线是专为分发电源信号而设计的。分发电能与分发数据信号是两项完全不同的工作，电信号以50~60 Hz频率发送，高速率数据通信所需的更高频率（MHz）在电线上会产生严重的衰减，因此家庭布线是一项很可怕的工作。</li></ul><h2 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h2><ul><li><p>光纤主要用于网络骨干的长途传输、高速局域网以及高速Internet 接入。光纤传输系统由三个关键部件构成：光源、传输介质和探测器。光探测器探测到光时产生一个电脉冲。在光纤两端分别接上光源和探测器，我们就有了一个单向数据传输系统。该系统接收电子信号，将其转换成光脉冲并传输出去，然后在另一端把光脉冲转换回电子信号输出给接收端。</p></li><li><p>分类：单模光纤、多模光纤。</p></li></ul><h1 id="无线传输"><a href="#无线传输" class="headerlink" title="无线传输"></a>无线传输</h1><p>无线通信除了为用户提供进行Web冲浪的连接外还有许多其他重要的应用，在某些情况下无线具有的优势甚至超过了固定设备的优势。例如，由于地形（山区、丛林、沼泽等）等陆地原因造成把光纤拉到一座建筑物非常困难时，无线或许是更好地选择。</p><p><strong>下面列出了无线传输的五种方式，仅供了解，具体可看原书。</strong></p><h2 id="电磁频谱"><a href="#电磁频谱" class="headerlink" title="电磁频谱"></a>电磁频谱</h2><h2 id="无线电传输"><a href="#无线电传输" class="headerlink" title="无线电传输"></a>无线电传输</h2><h2 id="微波传输"><a href="#微波传输" class="headerlink" title="微波传输"></a>微波传输</h2><h2 id="红外传输"><a href="#红外传输" class="headerlink" title="红外传输"></a>红外传输</h2><h2 id="光通信"><a href="#光通信" class="headerlink" title="光通信"></a>光通信</h2><h1 id="通信卫星"><a href="#通信卫星" class="headerlink" title="通信卫星"></a>通信卫星</h1><p>早在20 世纪50 年代和60 年代初期，人们尝试着利用金属化的气象气球对信号的反射作用来建立通信系统。不幸的是，由于接收到的信号强度太弱，根本没有任何实际价值。后来，美国海军注意到空中存在一个永久性的气象气球——月球，它们通过月球对信号的反射作用建立了一个可实际运行的船-岸通信系统。</p><p>直到第一颗通信卫星发射上天，天体通信领域才有了进一步发展。人造卫星和真实卫星之间的关键区别在于人造卫星把信号送回来之前先对它们进行了放大处理。由此，人类的好奇心促成了一种强大通信系统的诞生。</p><p>通信卫星有一些令人感兴趣的特性，这些特性对于许多应用具有很大的吸引力。按照最简单的方式理解，可以把一个通信卫星想象成天空中的一个大型微波中器。它包含几个转发器，每个转发器侦听频谱中的某一部分，对入境信号进行放大；然后在另一个频率上将放大后的信号重新广播出去；出境信号釆用不同的频率可避免与入境信号相互干扰。这种操作模式称为弯管。还可以将数字化处理添加到分别处理数据，或者把数据流重定向到整个波段，甚至在卫星接收数字信息后再重新广播。以这种方式重新生成的信号相比弯管性能更好，因为卫星没有将上行信号中的噪声放大。下行波束可以很宽，覆盖地球表面相当大的一部分；也可以很窄，仅仅覆盖几百千米直径的区域。</p><p><strong>下面列出四种通信卫星，仅供了解，具体可看原书。</strong></p><h2 id="地球同步卫星"><a href="#地球同步卫星" class="headerlink" title="地球同步卫星"></a>地球同步卫星</h2><h2 id="中地球轨道卫星"><a href="#中地球轨道卫星" class="headerlink" title="中地球轨道卫星"></a>中地球轨道卫星</h2><h2 id="低地球轨道卫星"><a href="#低地球轨道卫星" class="headerlink" title="低地球轨道卫星"></a>低地球轨道卫星</h2><h2 id="卫星与光纤"><a href="#卫星与光纤" class="headerlink" title="卫星与光纤"></a>卫星与光纤</h2>]]></content>
      
      
      <categories>
          
          <category> 大学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络引言</title>
      <link href="/2023/11/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BC%95%E8%A8%80/"/>
      <url>/2023/11/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BC%95%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<blockquote><p>计网是四大件之一，在计算机基础中占重要地位，对于相关学习者来说是绕不开的一部分。</p><p>以此系列博客记录一下我大三上学期计网的学习过程，期间用到的教材是第五版龙书，有需要电子版的朋友可以联系我。（因为是由英文原书翻译过来的，有些看起来荒谬冗长的语句需要大家联想纠正）</p><p>博客内容主要是考试重点，有很多不完整的部分建议看原书。</p></blockquote><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/11/30/6568496982610.jpg"></p><p>上图为本章考试重点，非原书知识结构，仅供参考。</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ol><li><p>计算机网络(computer networks)：表示一组通过单一技术相互连接起来的自主计算机集合。</p></li><li><p>分布式系统（distributed system）：分布式系统是建立在网络之上的软件系统，有高度的内聚性和透明性。<br>内聚性：每一个数据库分布节点高度自治，有本地数据库管理系统<br>透明性：每个数据库分布节点对用户应用来说是透明的，用户感觉不到数据是分布的</p><p>Internet 是最著名的计算机网络，万维网是最著名的分布式系统，万维网（软件）运行于Internet（硬件）上</p></li><li><p>虚拟专用网络(VPN,virtual private networks)：一种可以将不同地点的单个网络联结成一个扩展网络的技术。</p></li><li><p>P2P 与CS(client-server)<br>CS：由高性能计算机服务器和普通计算机客户机组成，服务器负责存储数据并处理客户请求，而客户机可远程访问服务器<br>P2P：对等模型（又称工作组），各台计算机具有相同功能，一台计算机可作为服务器设定共享资源供网络中其他计算机使用，又可作为工作站。没有专用的服务器或工作站。</p></li></ol><h1 id="网络分类"><a href="#网络分类" class="headerlink" title="网络分类"></a>网络分类</h1><h2 id="依据传输模式划分网络"><a href="#依据传输模式划分网络" class="headerlink" title="依据传输模式划分网络"></a>依据传输模式划分网络</h2><ul><li><strong>单播</strong>(unicasting)：只有一个发送方和一个接收方的点到点传输，也叫点到点链路(point-to-potint)</li><li><strong>广播</strong>(boradcasting)：任何一台机器发出的数据包能被其他人任何机器收到。每个数据包的地址字段指定了预期的接收方，只有预期的接收方会做出应答，其他的机器会忽略这个数据包。</li><li><strong>多播&#x2F;组播</strong>(mutilcasting)：将数据包发给一组机器，即所有机器的一个子集。广播可以看成是一种特殊的组播形式。</li></ul><h2 id="依据网络尺度划分网络"><a href="#依据网络尺度划分网络" class="headerlink" title="依据网络尺度划分网络"></a>依据网络尺度划分网络</h2><ol><li><p>个域网(PAN,Personal Area Network)：允许设备围绕一个人进行通信。一个常见的例子是计算机通过无线网络与其外围设备链接。突出的技术就是蓝牙(bluetooth)。</p></li><li><p>局域网(LAN,Local Area Network)：一种局部地区的私有网络，一般在一座建筑物内或是建筑物附近，比如家庭、办公室或工程。具体分为有线和无线两种。</p><ul><li><p>局域网特点：①距离短；②传输速率高；③错误率低。</p></li><li><p>无线LAN：每台计算机都有一个无线调制解调器和一个天线，用来和其他计算机通信。大多数情况下是和一个设备通信，这个设备称为接入点(AP,Access Point)、无线路由器或者基站。这个设备主要负责中继无线计算机之间的数据包，还负责中继无线计算机和Internet 之间的数据包。代表技术就是WIFI。</p></li><li><p>有线LAN：大多使用铜线作为传输介质，也有一些使用光纤。许多有线局域网的拓扑结构是以点到点链路为基础的，俗称以太网的IEEE 802.3 是迄今为止最常见的一种有线局域网。每台计算机按照以太网协议规定的方式运行，通过一条点到点链路链接到一个盒子，这个盒子称为交换机(switch)，一台交换机有多个端口，每个端口连接一台计算机。交换机的工作是中继与之连接的计算机之间的数据包，根据数据包中的地址来确定这个数据包要发<br>送给哪台计算机。</p></li></ul></li></ol><ul><li>有线局域网在性能的所有方面都超过了无线局域网，因为通过电线或通过光纤发送信号比通过空气发送信号更容易。</li></ul><ol start="3"><li><p>城域网(MAN,Metropolitan Area Network)：范围覆盖一个城市。最著名的城域网例子是许多城市都有的有线电视网。</p></li><li><p>广域网(WAN,Wide Area Network)：范围很大，它跨越很大的地理区域，通常是一个国家、地区或者一个大陆。</p><p>通信子网(subnet):我们按照传统的说法把机器叫做主机，把链接这些主机的网络其余部分称为通信子网，或简称子网。</p></li></ol><p>子网的工作是把信息从一个主机携带到另一个主机。</p><p>子网由两个不同部分组成：传输线路和交换元素。</p><p>传输线路负责在机器之间移动比特，它们可以是铜线、光纤、甚至无线链路。</p><p>交换元素或简称交换机是专用的计算机，负责链接两条或两条以上的传输线路。现在一般称为路由器(Router)</p><ol start="5"><li>互联网：一组相互连接起来的网络。</li></ol><h1 id="服务、接口与协议"><a href="#服务、接口与协议" class="headerlink" title="服务、接口与协议"></a>服务、接口与协议</h1><h2 id="协议层次结构"><a href="#协议层次结构" class="headerlink" title="协议层次结构"></a>协议层次结构</h2><ul><li><strong>协议</strong>(protocol)：是指通信双方就如何进行通信的一种约定。</li><li><strong>接口</strong>(interface)：定义了下层向上层提供哪些原语操作和服务。（它告诉上面的进程如何访问本层，规定了有哪些参数以及结果是什么，但并未说明工作过程和服务方式。）</li><li><strong>服务</strong>是由一组原语(primitive)正式说明，用户可以通过这些原语来访问该服务。协议栈：一个特定的系统所使用的一组协议。</li><li>协议栈：一个特定的系统所使用的一组协议。</li><li><strong>对等体</strong>(peer)：不同机器上构成相应层次的实体称为对等体。</li><li>网络体系机构(network architecture)：层和协议的集合。</li></ul><h2 id="服务和协议的关系"><a href="#服务和协议的关系" class="headerlink" title="服务和协议的关系"></a>服务和协议的关系</h2><ol><li><p>服务是指某一层向它上一层提供的一组原语操作，服务定义了该层打算代表其用户执行哪些操作，但是他不涉及如何实现这些操作，服务也会涉及到两层之间的接口，其中底层是服务提供者，而上层是服务的用户。(上下层之间的联系)</p></li><li><p>协议是一组规则，用来规定同一层上的对等体之间所交换的消息或者分组的格式和含义。这些实体利用协议来实现他们的服务定义，他们可以自由的改变协议而不影响它提供给上层的服务(对等体之间的规范)。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/11/30/6568496a76a6b.jpg" alt="服务和协议的关系.jpg"></p></li></ol><h2 id="面向连接与无连接的服务"><a href="#面向连接与无连接的服务" class="headerlink" title="面向连接与无连接的服务"></a>面向连接与无连接的服务</h2><ul><li>面向对象的连接的服务(connection-oriented service)：是按照电话系统建模的。服务用户首先必须建立一个连接，然后使用连接传输数据，最后释放连接。本质上像一个管道。</li><li>无连接的服务(connectionless service)：是按照邮政系统建模的。每一个报文都携带者完整的目的地址，每个报文都由系统中的中间节点路由，并且独立于后续的报文。</li><li>区别：<ol><li>面向连接的要求建立连接，因而没有传输的数据没有必要再标明传输的目的地址；而无连接的则对每个报文都由独立的目标地址。</li><li>一般来说，面向连接的可靠性较高，协议相对复杂，传输的数据按照发送顺序到达；而无连接的可靠性较差，协议相对简单，常出现乱序，重复和丢失现象。</li></ol></li></ul><h2 id="可靠和不可靠的服务"><a href="#可靠和不可靠的服务" class="headerlink" title="可靠和不可靠的服务"></a>可靠和不可靠的服务</h2><ol><li><p>可靠服务：即从来不丢失数据的一种服务。一般情况下，可靠服务都要求接收方向发送方确认收到的每个报文。</p></li><li><p>不可靠的服务：不会给发送方反馈任何确认消息，不保证数据不丢失。</p></li><li><p>可靠与不可靠服务同时存在的原因：</p></li></ol><p>  在给定的层次可靠通信并不总是可以使用的。</p><p>  为了提高可靠服务而导致的固有延迟可能是不可接受的。</p><ol start="4"><li>例题：面向连接的服务是可靠的吗？<br> 面向连接的服务只是在发送发和接收方之间建立连接，它并不能保证发送的数据流能准确无误的按序到达接收方。面向连接的服务同样分为可靠的面向连接服务和不可靠的面向连接服务。其中，前者主要包括报文序列、字节流，后者如数字化语音。</li></ol><h1 id="参考模型"><a href="#参考模型" class="headerlink" title="参考模型"></a>参考模型</h1><h2 id="OSI-模型"><a href="#OSI-模型" class="headerlink" title="OSI 模型"></a>OSI 模型</h2><p>Open Systems Interconnection具体分为七层，由低到高分别为：物理层，数据链路层，网络层，传输层，会话层，表示层，应用层。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/11/30/6568496a64508.jpg" alt="OSI模型.jpg"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/11/30/6568496c08b36.png" alt="OSI模型七层结构.png"></p><p>可以看到，第n 层的问题若第n 层无法完全解决，那么需要依靠其上一层。如物理层实现了点到点的传输，而链路层使此传输变得可靠；网络层确定了传输路径，而传输层使此传输变得可靠。</p><h2 id="TCP-IP-模型"><a href="#TCP-IP-模型" class="headerlink" title="TCP&#x2F;IP 模型"></a>TCP&#x2F;IP 模型</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/11/30/6568496976fdd.jpg" alt="TCP/IP模型.jpg"></p><p>由低到高具体包括：链路层，互联网层，传输层，应用层。<br>本书使用了混合模型，包括五层：物理层，数据链路层，网络层，传输层，应用层。</p><h2 id="OSI-模型和TCP-IP-模型的比较"><a href="#OSI-模型和TCP-IP-模型的比较" class="headerlink" title="OSI 模型和TCP&#x2F;IP 模型的比较"></a>OSI 模型和TCP&#x2F;IP 模型的比较</h2><ul><li>相同点：两者都是建立在协议栈概念上的，并且协议栈中的协议彼此相互独立。同时两个模型中各个层的功能也大致相似。</li><li>不同点：OSI 模型的实力在于模型本身，TCP&#x2F;IP 模型实力在于协议。</li><li>OSI 模型分为7 层，明确区分了服务、接口和协议。OSI 模型中的协议具有更好的隐蔽性，也更加的通用。这个模型是在协议之前产生的，它的网络层同时支持无连接和面向连接的通信，但是传输层只支持面向连接的通信。</li><li>TCP&#x2F;IP 模型分为4 层，没有明确区分服务、接口和协议。通用性差，不适合描述非TCP&#x2F;IP 网络。TCP&#x2F;IP 模型是先有的协议后有的模型，协议和模型切合度高。TCP&#x2F;IP 模型的网络层只支持无连接的通信，但是传输层同时支持两种。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 大学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CDN浅析及在butterfly的应用</title>
      <link href="/2023/11/25/CDN%E6%B5%85%E6%9E%90%E5%8F%8A%E5%9C%A8butterfly%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2023/11/25/CDN%E6%B5%85%E6%9E%90%E5%8F%8A%E5%9C%A8butterfly%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>博客加载速度一直较慢，在查阅了配置文件之后发现可以用CDN提升加载速度，于是乎了解了一下CDN并运用到自己的配置中。</p></blockquote><h1 id="CDN是什么"><a href="#CDN是什么" class="headerlink" title="CDN是什么"></a>CDN是什么</h1><p>CDN英文全称<code>Content Delivery Network</code>，中文翻译为内容分发网络。它是建立并覆盖在承载网之上，由分布在不同区域的边缘节点服务器群组成的分布式网络。CDN应用广泛，支持多种行业、多种场景内容加速，例如：图片小文件、大文件下载、视音频点播、直播流媒体、全站加速、安全加速。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/11/29/6566f6f4db178.png" alt="阿里云官网的例子.png"></p><p>借用上图阿里云官网的例子，来简单介绍CDN的工作原理。假设通过CDN加速的域名为<code>www.a.com</code>，接入CDN网络，开始使用加速服务后，当终端用户（北京）发起HTTP请求时，处理流程如下：</p><ol><li>当终端用户（北京）向<code>www.a.com</code>下的指定资源发起请求时，首先向LDNS（本地DNS）发起域名解析请求。</li><li>LDNS检查缓存中是否有<code>www.a.com</code>的IP地址记录。如果有，则直接返回给终端用户；如果没有，则向授权DNS查询。</li><li>当授权DNS解析<code>www.a.com</code>时，返回域名CNAME  <a href="http://www.a.tbcdn.com对应ip地址./">www.a.tbcdn.com对应IP地址。</a></li><li>域名解析请求发送至阿里云DNS调度系统，并为请求分配最佳节点IP地址。</li><li>LDNS获取DNS返回的解析IP地址。</li><li>用户获取解析IP地址。</li><li>用户向获取的IP地址发起对该资源的访问请求。</li></ol><ul><li>如果该IP地址对应的节点已缓存该资源，则会将数据直接返回给用户，例如，图中步骤7和8，请求结束。</li><li>如果该IP地址对应的节点未缓存该资源，则节点向源站发起对该资源的请求。获取资源后，结合用户自定义配置的缓存策略，将资源缓存至节点，例如，图中的北京节点，并返回给用户，请求结束。</li></ul><p>从这个例子可以了解到：</p><ol><li>CDN的加速资源是跟域名绑定的。</li><li>通过域名访问资源，首先是通过DNS分查找离用户最近的CDN节点（边缘服务器）的IP</li><li>通过IP访问实际资源时，如果CDN上并没有缓存资源，则会到源站请求资源，并缓存到CDN节点上，这样，用户下一次访问时，该CDN节点就会有对应资源的缓存了。</li></ol><p>简单讲，CDN就是通过将站点内容发布至遍布全球的海量加速节点，使其用户可就近获取所需内容。</p><p>CDN主要解决这么些问题:</p><ul><li>物理距离远，多次网络转发，延时高不稳定;</li><li>所在运营商不同，需运营商之间转发绕行;</li><li>网络带宽处理能力有限，海量请求时，响应速度与可用性降低。</li></ul><h1 id="CDN工作原理及作用"><a href="#CDN工作原理及作用" class="headerlink" title="CDN工作原理及作用"></a>CDN工作原理及作用</h1><p>CDN的工作原理就是将源站的资源缓存到位于全国各地的CDN节点上，用户请求资源时，就近返回节点上缓存的资源，而不需要每个用户的请求都回您的源站获取，避免网络拥塞、分担源站压力，保证用户访问资源的速度和体验。 </p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/11/29/6566f6f5addb2.png" alt="CDN原理.png"></p><p><strong>为什么要用 CDN？</strong></p><p>如果你在经营一家网站，那你应该知道几点因素是你制胜的关键：</p><ul><li>内容有吸引力</li><li>访问速度快</li><li>支持频繁的用户互动</li><li>可以在各处浏览无障碍</li></ul><p>此外，你的网站必须能在复杂的网络环境下运行，考虑到全球的用户访问体验。你的网站也会随着使用越来越多的对象（如图片、帧、CSS及APIs）和形形色色的动作（分享、跟踪）而系统逐渐庞大。所以，系统变慢带来用户的流失。</p><p>Google及其它网站的研究表明，一个网站每慢一秒钟，就会丢失许多访客，甚至这些访客永远不会再次光顾这些网站。可以想像，如果网站是你的盈利渠道或是品牌窗口，那么网站速度慢将是一个致命的打击。</p><p>这就是你使用CDN的第一个也是最重要的原因：<strong>为了加速网站的访问</strong>。</p><p>除此之外，CDN还有一些作用：</p><p><strong>1.为了实现跨运营商、跨地域的全网覆盖</strong>**</p><p>互联不互通、区域ISP地域局限、出口带宽受限制等种种因素都造成了网站的区域性无法访问。CDN加速可以覆盖全球的线路，通过和运营商合作，部署IDC资源，在全国骨干节点商，合理部署CDN边缘分发存储节点，充分利用带宽资源，平衡源站流量。</p><p><strong>2. 为了保障你的网站安全</strong></p><p>CDN的负载均衡和分布式存储技术，可以加强网站的可靠性，相当无无形中给你的网站添加了一把保护伞，应对绝大部分的互联网攻击事件。防攻击系统也能避免网站遭到恶意攻击。</p><p><strong>3. 为了异地备援</strong></p><p>当某个服务器发生意外故障时，系统将会调用其他临近的健康服务器节点进行服务，进而提供接近100%的可靠性，这就让你的网站可以做到永不宕机。</p><p><strong>4. 为了节约成本投入</strong></p><p>使用CDN加速可以实现网站的全国铺设，你根据不用考虑购买服务器与后续的托管运维，服务器之间镜像同步，也不用为了管理维护技术人员而烦恼，节省了人力、精力和财力。</p><p><strong>5. 为了让你更专注业务本身</strong></p><p>CDN加速厂商一般都会提供一站式服务，业务不仅限于CDN，还有配套的云存储、大数据服务、视频云服务等，而且一般会提供7x24运维监控支持，保证网络随时畅通，你可以放心使用。并且将更多的精力投入到发展自身的核心业务之上。</p><h1 id="CDN应用场景"><a href="#CDN应用场景" class="headerlink" title="CDN应用场景"></a>CDN应用场景</h1><ol><li><strong>网站站点&#x2F;应用加速</strong></li></ol><p>站点或者应用中大量静态资源的加速分发，建议将站点内容进行动静分离，动态文件可以结合云服务器ECS，静态资源如各类型图片、html、css、js文件等，建议结合 对象存储OSS 存储海量静态资源，可以有效加速内容加载速度，轻松搞定网站图片、短视频等内容分发。</p><ol start="2"><li><strong>视音频点播&#x2F;大文件下载分发加速</strong></li></ol><p>支持各类文件的下载、分发，支持在线点播加速业务，如mp4、flv视频文件或者平均单个文件大小在20M以上，主要的业务场景是视音频点播、大文件下载（如安装包下载）等，建议搭配对象存储OSS使用，可提升回源速度，节约近2&#x2F;3回源带宽成本。</p><ol start="3"><li><strong>视频直播加速</strong></li></ol><p>视频流媒体直播服务，支持媒资存储、切片转码、访问鉴权、内容分发加速一体化解决方案。结合弹性伸缩服务，及时调整服务器带宽，应对突发访问流量；结合媒体转码服务，享受高速稳定的并行转码，且任务规模无缝扩展。</p><ol start="4"><li><strong>移动应用加速</strong></li></ol><p>移动APP更新文件（apk文件）分发，移动APP内图片、页面、短视频、UGC等内容的优化加速分发。提供httpDNS服务，避免DNS劫持并获得实时精确的DNS解析结果，有效缩短用户访问时间，提升用户体验。</p><h1 id="CDN在hexo-butterfly主题下的应用"><a href="#CDN在hexo-butterfly主题下的应用" class="headerlink" title="CDN在hexo butterfly主题下的应用"></a>CDN在hexo butterfly主题下的应用</h1><p>因为众所周知的原因，jsdelivr无法使用了，所以要找新的CDN进行替换。</p><h2 id="新版butterfly"><a href="#新版butterfly" class="headerlink" title="新版butterfly"></a>新版butterfly</h2><p>使用新版butterfly的用户可以切换成local或者custom模式，如下图。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/11/29/6566f6f463235.png" alt="新版butterfly的CDN配置.png"></p><ul><li><p>如果想配置为local模式，只需修改<code>third_party_provider</code>属性为local，并且按照注释进行插件安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-butterfly-extjs</span><br></pre></td></tr></table></figure></li><li><p>如果想配置为custom模式，需修改<code>third_party_provider</code>属性为custom，并且修改<code>custom_format</code>属性，在上图中我就是这么做的。</p><p><code>custom_format</code>属性可以使用给出的例子，或者参考<a href="%5BWeb%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8CDN%E7%BD%91%E7%AB%99%E6%B1%87%E6%80%BB-CSDN%E5%8D%9A%E5%AE%A2%5D(https://blog.csdn.net/VariatioZbw/article/details/107822562)">这个链接</a>，给出了常用CDN汇总。</p></li></ul><h2 id="旧版butterfly"><a href="#旧版butterfly" class="headerlink" title="旧版butterfly"></a>旧版butterfly</h2><p>旧版butterfly用户或者新版想配置自定义CDN插件的用户就需要第三方CDN插件了。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/11/29/6566f6f43f2e4.png" alt="旧版butterfly配置CDN插件.png"></p><p>在上图的配置处进行逐个插件的配置，具体配置可以参考此博客，<a href="https://blog.zhheo.com/p/790087d9.html">Butterfly CDN链接更改指南，替换jsdelivr提升访问速度 | 张洪Heo (zhheo.com)</a>，如果找到更多CDN可以自己配置上。</p><p>CDN选择原则优先使用字节跳动的cdn，如果没有则使用elemecdn。</p>]]></content>
      
      
      <categories>
          
          <category> 技术浅谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网网络层-拥塞控制算法</title>
      <link href="/2023/11/25/%E8%AE%A1%E7%BD%91%E7%BD%91%E7%BB%9C%E5%B1%82-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95/"/>
      <url>/2023/11/25/%E8%AE%A1%E7%BD%91%E7%BD%91%E7%BB%9C%E5%B1%82-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>计网是四大件之一，在计算机基础中占重要地位，对于相关学习者来说是绕不开的一部分。以此系列博客记录一下我大三上学期计网的学习过程，期间用到的教材是第五版龙书，有需要电子版的朋友可以联系我。（因为是由英文原书翻译过来的，有些看起来荒谬冗长的语句需要大家联想纠正）</p></blockquote><blockquote><p>这里将网络层的拥塞控制这一章节详细展开讲述</p></blockquote><h1 id="拥塞的发生"><a href="#拥塞的发生" class="headerlink" title="拥塞的发生"></a>拥塞的发生</h1><p>网络中存在太多的数据包导致数据包被延迟和丢失，从而降低了传输性能，这种情况称为拥塞（congestion）。网络层和传输层共同承担着处理拥塞的责任，在这里，我们将着眼于拥塞控制在网络层方面的处理。</p><p>图5-21 描绘了拥塞的发生。当主机发送到网络的数据包数量在其承载能力范围之内时，送达的数据包数与发送的数据包数成正比例增长。如果发送量增加了两倍，则送达量也增长了两倍。然而，随着负载接近承载能力，偶尔突发的流量填满了路由器内部的缓冲区，因而某些数据包会被丢失。这些丢失的数据包消耗<br>了部分容量，因此，送达的数据包数量低于理想曲线。网络现在开始拥挤了。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/11/29/6566f58bf0add.png" alt="5-21.png"></p><h1 id="拥塞控制的途径"><a href="#拥塞控制的途径" class="headerlink" title="拥塞控制的途径"></a>拥塞控制的途径</h1><p>拥塞的出现意味着负载暂时大于资源可以处理的能力。很自然人们能想到两个解决方案：增加资源或减少负载。</p><p>如图5-22 所示，这些解决方案通常应用在不同的时间尺度上，要么预先避免拥塞，要么一旦发生拥塞随之做出反应。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/11/29/6566f58c9a56a.png" alt="5-22.png"></p><ul><li>避免拥塞的最基本方法是建立一个与流量匹配良好的网络。有时当出现严重拥塞时，可以动态增加网络资源。这就是所谓的<strong>供给</strong>（provisioning）在长期流量趋势推动下大约需要几个月的时间。</li><li>为了充分利用现有的网络容量，可以根据每天的流量模式度身定制路由，因为不同时区的网络用户每天醒来和睡觉的时间是不同的。例如，一些本地广播电台有直升机围绕着城市上空飞来飞去，及时报告城市道路拥堵情况，帮助它们的移动听众路由它们的数据包（汽车）绕开热点地区，这称为<strong>流量感知的路由</strong>（traffic-aware routing)。</li><li>然而，有的时候不可能增加容量。那么对抗拥塞的唯一的办法就是降低负载。在一个虚电路网络中，如果新的连接将导致网络变得拥挤不堪，那么就应该拒绝这种新连接的建立。这种控制称为<strong>准入控制</strong>（admission control）。</li><li>最后，当一切努力都失败，网络不得不丢弃它无法传递的数据包。这种方法的通用名称是<strong>负载脱落</strong>(load shedding)。一个选择丢弃哪些数据包的良好策略可以防止拥塞崩溃。</li></ul><h1 id="流量感知路由"><a href="#流量感知路由" class="headerlink" title="流量感知路由"></a>流量感知路由</h1><p>最直接的方式是把链路权重设置成一个（固定）链路带宽、传输延迟、（可变）测量负载或平均排队延迟的函数。’在所有其他条件都相同的情况下，最小权重的路径更青睐那些轻负载的路径。</p><p>早期Internet 使用的流量感知路由就是按照这个模型设计的。然而，这种路由存在一个危险。</p><p>考虑图5-23 所示的网络，这里网络被分为东部和西部，这两部分通过链路CF 和EI 相连。假设东西之间的大部分流量使用链路CF, 因此，这个链路负荷超重因而延迟增大。如果把排队延迟加入到计算最短路径的权重中，那么链路EI将变得更具吸引力。当新的路由表被安装好之后，大部分东西方的流量现在改走链路EI由此增加了此链路的负载。因此，在下一次路由更新时，CF 将成为最短路径。结果，路由表可能会剧烈地摇摆不定，从而导致不稳定的路由和许多潜在的问题。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/11/29/6566f58c137db.png" alt="5-23.png"></p><p>如果忽略负载，只考虑带宽和传输延迟，这个问题就不会发生。尝试在路由权重中包括负载但将其限定在一个狭窄的范围可减缓路由振荡。两种技术有助于获得成功的解决方案。首先是多路径路由，即从源到目的地可以存在多条路径。在我们的例子中，这意味着可以把整个流量分散到东部和西部的两条链路上。第二个技术是把流量慢慢迁移，足够慢到路由算法得到收敛。</p><p>由于存在这些困难，Internet 路由协议通常不依赖于负载来调整自己的路由。相反，在路由协议外部通过慢慢改变它的输入来调整路由。这种方法就是所谓的流量工程（traffic engineering )。</p><h1 id="准入控制"><a href="#准入控制" class="headerlink" title="准入控制"></a>准入控制</h1><p>一种广泛应用于虚电路网络，防止出现拥塞的技术是准入控制（admission control)。其基本思想非常简单：除非网络可以携带额外的流量而不会变得拥塞，否则不再建立新的虚电路。因此，任何建立新的虚电路的尝试或许会失败。</p><p>如果我们想要采用准入控制，必须归纳出虚电路的一些流量特性。流量往往用其速度和形状来描述。如何以一种简单而又有意义的方式来描述流量是困难的，因为流量呈现突发性平均速率只讲述了故事的一半。例如，浏览网页时的流量变化很大，比具有固定长期吞吐量的流式电影更难以处理，因为突发性的网页流量更容易<br>堵塞住网络中的路由器。捕获这个效果通常采用的描述符是漏桶（leaky bucket) 或令牌桶(token bucket)。一个漏桶有两个参数约束了平均速率和瞬时突发流量大小。我们将在服务质量这节仔细描述它。有了流量说明， 网络就能决定是否接受新的虚电路。</p><p>准入控制还可以和流量感知路由相结合，在虚电路建立过程中，考虑绕开流量热点区域的路由。例如，考虑图5-24 的网络，这里显示的两台路由器己经被堵塞。<br>假设一台连接到路由器A 的主机想要与另一台连接到路由器B 的主机建立一个连接。通常情况下，这个连接将会经过其中一台拥塞的路由器。为了避免这种情形，我们可以重画网络，如图5-24 (b) 所示，去掉拥塞的路由器和它们所有的线路。图中的虚线显示了条可能的虚电路路径，它避开了拥塞的路由器。（Shaikh 等，1999) 给出了这类负载敏感的路由方案设计。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/11/29/6566f58c618c0.png" alt="5-24.png"></p><h1 id="负载脱落"><a href="#负载脱落" class="headerlink" title="负载脱落"></a>负载脱落</h1><p>当以上任何一种方法都无法消除拥塞时，路由器可以亮出它的杀手锏，即负载脱落。负载脱落（load shedding） 是一种富有想象力的说法，它指当路由器因为来不及处理数据包而面临被这些数据包淹没的危险时，就将它们丢弃。</p><p>对于一个被数据包淹没的路由器来说，关键的问题是选择丢弃哪个数据包。首选的方案可能取决于使用网络的应用程序类型。对于文件传输，旧的数据包价值要高于新的数据包。相比之下，对于实时媒体流，新的数据包价值超过老的数据包。因为如果数据包被延迟并且错失了给用户的播放时间，那么该数据包就变得一无所用。</p><p>更智能的卸载方式需要发送方的合作。一个例子是携带路由信息的数据包。这些数据包比普通数据包要重要得多，因为它们是被用来建立的路由；如果丢失它们，或许就会丢失网络连接。为了实现智能丢弃政策，应用程序必须在它们的数据包上打上标记，指示网络它们有多重要。然后，当不得不丢弃数据包时，路由器可以首先丢弃重要性最轻一类数据包，然后是次重要一类数据包，以此类推。</p><h2 id="随机早期检测"><a href="#随机早期检测" class="headerlink" title="随机早期检测"></a>随机早期检测</h2><p>在拥塞刚出现苗头时就处理它比等拥塞形成之后再设法解决它更加有效。可以利用这种情形来帮助缓解拥塞。在局面变得毫无希望之前让路由器提前丢包，但这里有个时间点的确定问题，即发送方何时采取行动以免为时过晚。解决这个问题的一个流行算法称为随机早期检测（RED，Random Early Detection)。</p><p>为了确定何时开始丢弃数据包，路由器要维护一个运行队列长度的平均值。当某条链路上的平均队列长度超过某个阈值时，该链路就被认为即将拥塞，因此路由器随机丢弃一小部分数据包。随机选择丢弃的数据包使得快速发送方发现丢包的可能性更大；因为在数据报网络中，路由器不能分辨出哪个源引起了网络的最大麻烦，因此随机选择丢弃的数据包或许是最佳选择。当没有出现期待的确认信息时，受此影响的发送方就会发现丢包，然后传输协议将放慢速度。因此，丢失的数据包起到了传递抑制包的同样作用，但却是隐含的，无须路由器发送任何显式信号。</p><p>相比那些只在缓冲区溢出才丢包的路由器，RED 路由器能提高网络性能，虽然它们可能需要调整正常工作方式。举例来说，理想的丢包数量取决于有多少发送方必须得到拥塞通知。然而，如果ECN 可用，那么它就是首选的选项。它的工作方式几乎完全一样，但提供了一个显式拥塞信号而不是依据丢包来判断是否拥塞；RED 用在主机不能接收显式信号的环境里。</p>]]></content>
      
      
      <categories>
          
          <category> 大学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客迁移</title>
      <link href="/2023/11/24/Hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/"/>
      <url>/2023/11/24/Hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在重装系统、换电脑等很多情况下需要对Hexo迁移，进行新部署。</p><p>这里有个前提，一定要把之前博客相关的本地文件夹保存起来，可以上传到git或者直接迁移。</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>主要有两个步骤，安装配置所需环境（1-3）和部署博客，如果已经安装了相应环境可以直接跳转。</p><h2 id="1-Git安装配置"><a href="#1-Git安装配置" class="headerlink" title="1.Git安装配置"></a>1.Git安装配置</h2><p>从官网<a href="https://link.zhihu.com/?target=https://git-scm.com/">Git</a>下载git，在新电脑上安装，因为https速度慢，而且每次都要输入口令，常用的是使用ssh。使用下面方法创建，也可以自己找教程：</p><ol><li><p>打开git bash，在用户主目录下运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;youremail@xxx.com&quot;</span></span><br></pre></td></tr></table></figure><p> 把其中的邮件地址换成自己的邮件地址，然后一路回车。</p></li><li><p>完成后，会在用户主目录下生成<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH key密钥对，<code>id_rsa</code>是私钥，千万不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p></li><li><p>登陆GitHub，打开<code>「Settings」</code>-&gt;<code>「SSH and GPG keys」</code>，然后点击<code>「new SSH key」</code>，填上任意Title，在Key文本框里粘贴公钥<code>id_rsa.pub</code>文件的内容（千万不要粘贴成私钥了！），最后点击<code>「Add SSH Key」</code>，你就应该看到已经添加的Key。</p></li></ol><p><strong>注意</strong>：不要在git版本库中运行ssh，然后又将它提交，这样就把密码泄露出去了。</p><h2 id="2-下载Node-js，并安装"><a href="#2-下载Node-js，并安装" class="headerlink" title="2. 下载Node.js，并安装"></a>2. 下载<a href="https://link.zhihu.com/?target=https://nodejs.org/">Node.js</a>，并安装</h2><h2 id="3-安装Hexo"><a href="#3-安装Hexo" class="headerlink" title="3.安装Hexo"></a>3.安装Hexo</h2><p> 打开git bash客户端，输入 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>，开始安装hexo。</p><h2 id="4-迁移原本的Hexo"><a href="#4-迁移原本的Hexo" class="headerlink" title="4.迁移原本的Hexo"></a>4.迁移原本的Hexo</h2><p>下面就将原来的文件拷贝到新电脑中，但是要注意哪些文件是必须的，哪些文件是可以删除的。</p><ul><li>讨论下哪些文件是必须拷贝的：首先是之前自己修改的文件，像站点配置<code>config.yml</code>，<code>theme</code>文件夹里面的主题，以及<code>source</code>里面自己写的博客文件，这些肯定要拷贝的。除此之外，还有三个文件需要有，就是<code>scaffolds</code>文件夹（文章的模板）、<code>package.json</code>（说明使用哪些包）和<code>.gitignore</code>（限定在提交的时候哪些文件可以忽略）。其实，这三个文件不是我们修改的，所以即使丢失了，也没有关系，我们可以建立一个新的文件夹，然后在里面执行<code>hexo init</code>，就会生成这三个文件，我们只需要将它们拷贝过来使用即可。</li></ul><p><strong>总结：</strong><code>config.yml</code>，<code>theme/</code>，<code>source/</code>，<code>scaffolds/</code>，<code>package.json</code>，<code>.gitignore</code>是需要拷贝的。</p><ul><li>再讨论下哪些文件是不必拷贝的，或者说可以删除的：首先是<code>.git</code>文件，无论是在站点根目录下，还是主题目录下的<code>.git</code>文件，都可以删掉。然后是文件夹<code>node_modules</code>（在用<code>npm install</code>会重新生成），<code>public</code>（这个在用<code>hexo g</code>时会重新生成），<code>.deploy_git</code>文件夹（在使用<code>hexo d</code>时也会重新生成），<code>db.json</code>文件。其实上面这些文件也就是<code>.gitignore</code>文件里面记载的可以忽略的内容。</li></ul><p><strong>总结：</strong><code>.git/</code>，<code>node_modules/</code>，<code>public/</code>，<code>.deploy_git/</code>，<code>db.json</code>文件需要删除。</p><h2 id="5-模块安装"><a href="#5-模块安装" class="headerlink" title="5.模块安装"></a>5.模块安装</h2><p>在<code>git bash</code>中切换目录到新拷贝的文件夹里，使用 <code>npm install</code> 命令，进行模块安装。很明显我们这里没用<code>hexo init</code>初始化，因为有的文件我们已经拷贝生成过来了，所以不必用<code>hexo init</code>去整体初始化，如果不慎在此时用了<code>hexo init</code>，则站点的配置文件<code>_config.yml</code>里面内容会被清空使用默认值，所以这一步一定要慎重，不要用<code>hexo init</code>。</p><h2 id="6-安装其他必要组件"><a href="#6-安装其他必要组件" class="headerlink" title="6.安装其他必要组件"></a>6.安装其他必要组件</h2><ol><li><p>为了使用<code>hexo d</code>来部署到git上，需要安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li><li><p>为了建立RSS订阅，需要安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure></li><li><p>为了建立站点地图，需要安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure></li></ol><p>插件安装后，有的需要对配置文件<code>_config.yml</code>进行配置，具体可以参考上面插件在github主页上的具体说明</p><h2 id="7-检验"><a href="#7-检验" class="headerlink" title="7.检验"></a>7.检验</h2><p>使用<code>hexo g</code>生成静态文件，然后使用<code>hexo d</code>进行部署，如果都没有出错，就转移成功了。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>简单来说，就是将整个hexo的文件夹打包发送，然后重新安装模块就可以了。但是切记一定要保存好自己博客的配置和资源文件，否则是无法迁移的。</p>]]></content>
      
      
      <categories>
          
          <category> 技术浅谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客搭建</title>
      <link href="/2023/05/27/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>/2023/05/27/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>突发奇想，想搭建一个自己的博客记录一下计算机的学习生涯，在查阅了一些资料后决定使用GitHub Pages来搭建 Hexo 静态博客网站，用的主题是hexo-theme-butterfly。</p><p>说干就干，折腾了半天之后终于搞定，这里要感谢<a href="https://fe32.top/">Ethan.Tzy</a>大佬提供的技术博客，步骤很明确，大家有兴趣的可以关注一下。</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>基本的博客搭建步骤在前言提到的技术博客中都可以找到，这里我记录一下几个没有提到的基本问题。</p><h2 id="博客的创建"><a href="#博客的创建" class="headerlink" title="博客的创建"></a>博客的创建</h2><p>文章可以手动创建，也可以通过<code>hexo new</code>命令创建。hexo官方建议的流程如下：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/11/29/6566f58d96223.png" alt="官方流程.png"></p><ol><li><p>首先确定layout模板，模板中定义的内容可以认为是一种公共内容的提取，模板的内容称为Front-matter，在创建文章时会自动添加到新文件中。hexo自带了三种模板(可按实际情况修改)：page、post、draft。</p><p>page：用于创建列表页;</p><p>post：用于创建具体的博客文章;</p><p>dratf：用于创建草稿(一般不太用)。</p></li><li><p>使用 <code>hexo new</code>命令创建文章。</p></li></ol><p>给出一个最简单的创建文章的例子（文章标题自拟）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new 文章标题</span><br></pre></td></tr></table></figure><h2 id="博客的更新"><a href="#博客的更新" class="headerlink" title="博客的更新"></a>博客的更新</h2><p>在本地对自己的博客进行了配置修改或者文章更新后，如何将其同步到网站上呢，下面会给出答案。</p><p>1.在本地的博客根目录下打开cmd控制台</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/11/29/6566f58c724a3.png" alt="根目录.png"></p><p>2.在控制台中依次输入下面三个命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><p>清除缓存文件 <code>db.json</code> 和已生成的静态文件 <code>public</code>。(网站显示异常时可以执行这条命令试试)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><p><code>hexo g</code> 是 <code>hexo generate</code> 的缩写，作用是生成网站静态文件到默认设置的 <code>public</code> 文件夹。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><p><code>hexo d</code> 是 <code>hexo deploy</code> 的缩写，作用是自动生成网站静态文件，并部署到设定的仓库。</p><p>3.完成上面步骤后，稍等片刻，再次打开博客页面，会发现已经更新完成。</p><h2 id="图片的插入"><a href="#图片的插入" class="headerlink" title="图片的插入"></a>图片的插入</h2><p>在配置和写文章的过程中，很多时候需要图片的插入，这就涉及到图片路径以及存储位置的问题，具体操作步骤如下。</p><h3 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h3><p>如果你有图床那再好不过了，这里推荐一个我正在用的付费图床[去不图床](<a href="https://7bu.top/">去不图床 - 杜老师说旗下付费图片外链平台 (7bu.top)</a>)。</p><h3 id="本地图片"><a href="#本地图片" class="headerlink" title="本地图片"></a>本地图片</h3><p>如果选择用本地图片的方式，需要在本地blog文件夹下创建<code>source\img</code>文件夹，将图片保存进去。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/11/29/6566f58c02024.png" alt="本地图片位置.png"></p><p>在引用时使用img\xxx.jpg的路径进行引用即可，给出一个例子，这里是头像的配置路径。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/11/29/6566f58c32c03.png" alt="图片路径.png"></p><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>这里推荐以图床的方式进行图片存储，因为渲染速度会比本地的方式快一些。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>hexo的搭建方法很简单，网上的教程资料也很多，按照教程走可以很容易搭建出自己的博客。这里附上<a href="%5BHexo%5D(https://hexo.io/zh-cn/index.html)">hexo中文官方</a>的网址，有兴趣可以看看。</p><p>我的友链里关注的博主们基本都有关于hexo魔改的文章，对魔改有兴趣的读者可以关注下。</p><p>如果有问题欢迎在评论区留言或者加我联系方式一起讨论~</p>]]></content>
      
      
      <categories>
          
          <category> 技术浅谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
