<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Raft算法详解</title>
      <link href="/2025/01/24/Raft%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
      <url>/2025/01/24/Raft%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1 背景"></a><a href="#_1-%E8%83%8C%E6%99%AF">1 背景</a></h2><p>当今的数据中心和应用程序在高度动态的环境中运行，为了应对高度动态的环境，它们通过额外的服务器进行横向扩展，并且根据需求进行扩展和收缩。同时，服务器和网络故障也很常见。</p><p>因此，系统必须在正常操作期间处理服务器的上下线。它们必须对变故做出反应并在几秒钟内自动适应；对客户来说的话，明显的中断通常是不可接受的。</p><p>幸运的是，分布式共识可以帮助应对这些挑战。</p><h3 id="1-1-拜占庭将军"><a href="#1-1-拜占庭将军" class="headerlink" title="1.1 拜占庭将军"></a><a href="#_1-1-%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B">1.1 拜占庭将军</a></h3><hr><p>在介绍共识算法之前，先介绍一个简化版拜占庭将军的例子来帮助理解共识算法。</p><blockquote><p>假设多位拜占庭将军中没有叛军，信使的信息可靠但有可能被暗杀的情况下，将军们如何达成是否要进攻的一致性决定？</p></blockquote><p>解决方案大致可以理解成：先在所有的将军中选出一个大将军，用来做出所有的决定。</p><p>举例如下：假如现在一共有 3 个将军 A，B 和 C，每个将军都有一个随机时间的倒计时器，倒计时一结束，这个将军就把自己当成大将军候选人，然后派信使传递选举投票的信息给将军 B 和 C，如果将军 B 和 C 还没有把自己当作候选人（自己的倒计时还没有结束），并且没有把选举票投给其他人，它们就会把票投给将军 A，信使回到将军 A 时，将军 A 知道自己收到了足够的票数，成为大将军。在有了大将军之后，是否需要进攻就由大将军 A 决定，然后再去派信使通知另外两个将军，自己已经成为了大将军。如果一段时间还没收到将军 B 和 C 的回复（信使可能会被暗杀），那就再重派一个信使，直到收到回复。</p><h3 id="1-2-共识算法"><a href="#1-2-共识算法" class="headerlink" title="1.2 共识算法"></a><a href="#_1-2-%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95">1.2 共识算法</a></h3><p>共识是可容错系统中的一个基本问题：即使面对故障，服务器也可以在共享状态上达成一致。</p><p>共识算法允许一组节点像一个整体一样一起工作，即使其中的一些节点出现故障也能够继续工作下去，其正确性主要是源于复制状态机的性质：一组<code>Server</code>的状态机计算相同状态的副本，即使有一部分的<code>Server</code>宕机了它们仍然能够继续运行。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/03/18/67d918a2221e3.png"></p><p>一般通过使用复制日志来实现复制状态机。每个<code>Server</code>存储着一份包括命令序列的日志文件，状态机会按顺序执行这些命令。因为每个日志包含相同的命令，并且顺序也相同，所以每个状态机处理相同的命令序列。由于状态机是确定性的，所以处理相同的状态，得到相同的输出。</p><p>因此共识算法的工作就是保持复制日志的一致性。服务器上的共识模块从客户端接收命令并将它们添加到日志中。它与其他服务器上的共识模块通信，以确保即使某些服务器发生故障。每个日志最终包含相同顺序的请求。一旦命令被正确地复制，它们就被称为已提交。每个服务器的状态机按照日志顺序处理已提交的命令，并将输出返回给客户端，因此，这些服务器形成了一个单一的、高度可靠的状态机。</p><p>适用于实际系统的共识算法通常具有以下特性：</p><ul><li>安全。确保在非拜占庭条件（也就是上文中提到的简易版拜占庭）下的安全性，包括网络延迟、分区、包丢失、复制和重新排序。</li><li>高可用。只要大多数服务器都是可操作的，并且可以相互通信，也可以与客户端进行通信，那么这些服务器就可以看作完全功能可用的。因此，一个典型的由五台服务器组成的集群可以容忍任何两台服务器端故障。假设服务器因停止而发生故障；它们稍后可能会从稳定存储上的状态中恢复并重新加入集群。</li><li>一致性不依赖时序。错误的时钟和极端的消息延迟，在最坏的情况下也只会造成可用性问题，而不会产生一致性问题。</li><li>在集群中大多数服务器响应，命令就可以完成，不会被少数运行缓慢的服务器来影响整体系统性能。</li></ul><h2 id="2-基础"><a href="#2-基础" class="headerlink" title="2 基础"></a><a href="#_2-%E5%9F%BA%E7%A1%80">2 基础</a></h2><h3 id="2-1-节点类型"><a href="#2-1-节点类型" class="headerlink" title="2.1 节点类型"></a><a href="#_2-1-%E8%8A%82%E7%82%B9%E7%B1%BB%E5%9E%8B">2.1 节点类型</a></h3><p>一个 Raft 集群包括若干服务器，以典型的 5 服务器集群举例。在任意的时间，每个服务器一定会处于以下三个状态中的一个：</p><ul><li><code>Leader</code>：负责发起心跳，响应客户端，创建日志，同步日志。</li><li><code>Candidate</code>：Leader 选举过程中的临时角色，由 Follower 转化而来，发起投票参与竞选。</li><li><code>Follower</code>：接受 Leader 的心跳和日志同步数据，投票给 Candidate。</li></ul><p>在正常的情况下，只有一个服务器是 Leader，剩下的服务器是 Follower。Follower 是被动的，它们不会发送任何请求，只是响应来自 Leader 和 Candidate 的请求。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/03/18/67d918a1848c3.png"></p><h3 id="2-2-任期"><a href="#2-2-任期" class="headerlink" title="2.2 任期"></a><a href="#_2-2-%E4%BB%BB%E6%9C%9F">2.2 任期</a></h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/03/18/67d918a078494.png"></p><p>如图所示，raft 算法将时间划分为任意长度的任期（term），任期用连续的数字表示，看作当前 term 号。每一个任期的开始都是一次选举，在选举开始时，一个或多个 Candidate 会尝试成为 Leader。如果一个 Candidate 赢得了选举，它就会在该任期内担任 Leader。如果没有选出 Leader，将会开启另一个任期，并立刻开始下一次选举。raft 算法保证在给定的一个任期最少要有一个 Leader。</p><p>每个节点都会存储当前的 term 号，当服务器之间进行通信时会交换当前的 term 号；如果有服务器发现自己的 term 号比其他人小，那么他会更新到较大的 term 值。如果一个 Candidate 或者 Leader 发现自己的 term 过期了，他会立即退回成 Follower。如果一台服务器收到的请求的 term 号是过期的，那么它会拒绝此次请求。</p><h3 id="2-3-日志"><a href="#2-3-日志" class="headerlink" title="2.3 日志"></a><a href="#_2-3-%E6%97%A5%E5%BF%97">2.3 日志</a></h3><hr><ul><li><code>entry</code>：每一个事件成为 entry，只有 Leader 可以创建 entry。entry 的内容为<code>&lt;term,index,cmd&gt;</code>其中 cmd 是可以应用到状态机的操作。</li><li><code>log</code>：由 entry 构成的数组，每一个 entry 都有一个表明自己在 log 中的 index。只有 Leader 才可以改变其他节点的 log。entry 总是先被 Leader 添加到自己的 log 数组中，然后再发起共识请求，获得同意后才会被 Leader 提交给状态机。Follower 只能从 Leader 获取新日志和当前的 commitIndex，然后把对应的 entry 应用到自己的状态机中。</li></ul><h2 id="3-领导人选举"><a href="#3-领导人选举" class="headerlink" title="3 领导人选举"></a><a href="#_3-%E9%A2%86%E5%AF%BC%E4%BA%BA%E9%80%89%E4%B8%BE">3 领导人选举</a></h2><hr><p>raft 使用心跳机制来触发 Leader 的选举。</p><p>如果一台服务器能够收到来自 Leader 或者 Candidate 的有效信息，那么它会一直保持为 Follower 状态，并且刷新自己的 electionElapsed，重新计时。</p><p>Leader 会向所有的 Follower 周期性发送心跳来保证自己的 Leader 地位。如果一个 Follower 在一个周期内没有收到心跳信息，就叫做选举超时，然后它就会认为此时没有可用的 Leader，并且开始进行一次选举以选出一个新的 Leader。</p><p>为了开始新的选举，Follower 会自增自己的 term 号并且转换状态为 Candidate。然后他会向所有节点发起 RequestVoteRPC 请求， Candidate 的状态会持续到以下情况发生：</p><ul><li>赢得选举</li><li>其他节点赢得选举</li><li>一轮选举结束，无人胜出</li></ul><p>赢得选举的条件是：一个 Candidate 在一个任期内收到了来自集群内的多数选票<code>（N/2+1）</code>，就可以成为 Leader。</p><p>在 Candidate 等待选票的时候，它可能收到其他节点声明自己是 Leader 的心跳，此时有两种情况：</p><ul><li>该 Leader 的 term 号大于等于自己的 term 号，说明对方已经成为 Leader，则自己回退为 Follower。</li><li>该 Leader 的 term 号小于自己的 term 号，那么会拒绝该请求并让该节点更新 term。</li></ul><p>由于可能同一时刻出现多个 Candidate，导致没有 Candidate 获得大多数选票，如果没有其他手段来重新分配选票的话，那么可能会无限重复下去。</p><p>raft 使用了随机的选举超时时间来避免上述情况。每一个 Candidate 在发起选举后，都会随机化一个新的选举超时时间，这种机制使得各个服务器能够分散开来，在大多数情况下只有一个服务器会率先超时；它会在其他服务器超时之前赢得选举。</p><h2 id="4-日志复制"><a href="#4-日志复制" class="headerlink" title="4 日志复制"></a><a href="#_4-%E6%97%A5%E5%BF%97%E5%A4%8D%E5%88%B6">4 日志复制</a></h2><p>一旦选出了 Leader，它就开始接受客户端的请求。每一个客户端的请求都包含一条需要被复制状态机（<code>Replicated State Machine</code>）执行的命令。</p><p>Leader 收到客户端请求后，会生成一个 entry，包含<code>&lt;index,term,cmd&gt;</code>，再将这个 entry 添加到自己的日志末尾后，向所有的节点广播该 entry，要求其他服务器复制这条 entry。</p><p>如果 Follower 接受该 entry，则会将 entry 添加到自己的日志后面，同时返回给 Leader 同意。</p><p>如果 Leader 收到了多数的成功响应，Leader 会将这个 entry 应用到自己的状态机中，之后可以称这个 entry 是 committed 的，并且向客户端返回执行结果。</p><p>raft 保证以下两个性质：</p><ul><li>在两个日志里，有两个 entry 拥有相同的 index 和 term，那么它们一定有相同的 cmd</li><li>在两个日志里，有两个 entry 拥有相同的 index 和 term，那么它们前面的 entry 也一定相同</li></ul><p>通过“仅有 Leader 可以生成 entry”来保证第一个性质，第二个性质需要一致性检查来进行保证。</p><p>一般情况下，Leader 和 Follower 的日志保持一致，然后，Leader 的崩溃会导致日志不一样，这样一致性检查会产生失败。Leader 通过强制 Follower 复制自己的日志来处理日志的不一致。这就意味着，在 Follower 上的冲突日志会被领导者的日志覆盖。</p><p>为了使得 Follower 的日志和自己的日志一致，Leader 需要找到 Follower 与它日志一致的地方，然后删除 Follower 在该位置之后的日志，接着把这之后的日志发送给 Follower。</p><p><code>Leader</code> 给每一个<code>Follower</code> 维护了一个 <code>nextIndex</code>，它表示 <code>Leader</code> 将要发送给该追随者的下一条日志条目的索引。当一个 <code>Leader</code> 开始掌权时，它会将 <code>nextIndex</code> 初始化为它的最新的日志条目索引数+1。如果一个 <code>Follower</code> 的日志和 <code>Leader</code> 的不一致，<code>AppendEntries</code> 一致性检查会在下一次 <code>AppendEntries RPC</code> 时返回失败。在失败之后，<code>Leader</code> 会将 <code>nextIndex</code> 递减然后重试 <code>AppendEntries RPC</code>。最终 <code>nextIndex</code> 会达到一个 <code>Leader</code> 和 <code>Follower</code> 日志一致的地方。这时，<code>AppendEntries</code> 会返回成功，<code>Follower</code> 中冲突的日志条目都被移除了，并且添加所缺少的上了 <code>Leader</code> 的日志条目。一旦 <code>AppendEntries</code> 返回成功，<code>Follower</code> 和 <code>Leader</code> 的日志就一致了，这样的状态会保持到该任期结束。</p><h2 id="5-安全性"><a href="#5-安全性" class="headerlink" title="5 安全性"></a><a href="#_5-%E5%AE%89%E5%85%A8%E6%80%A7">5 安全性</a></h2><h3 id="5-1-选举限制"><a href="#5-1-选举限制" class="headerlink" title="5.1 选举限制"></a><a href="#_5-1-%E9%80%89%E4%B8%BE%E9%99%90%E5%88%B6">5.1 选举限制</a></h3><p>Leader 需要保证自己存储全部已经提交的日志条目。这样才可以使日志条目只有一个流向：从 Leader 流向 Follower，Leader 永远不会覆盖已经存在的日志条目。</p><p>每个 Candidate 发送 RequestVoteRPC 时，都会带上最后一个 entry 的信息。所有节点收到投票信息时，会对该 entry 进行比较，如果发现自己的更新，则拒绝投票给该 Candidate。</p><p>判断日志新旧的方式：如果两个日志的 term 不同，term 大的更新；如果 term 相同，更长的 index 更新。</p><h3 id="5-2-节点崩溃"><a href="#5-2-节点崩溃" class="headerlink" title="5.2 节点崩溃"></a><a href="#_5-2-%E8%8A%82%E7%82%B9%E5%B4%A9%E6%BA%83">5.2 节点崩溃</a></h3><p>如果 Leader 崩溃，集群中的节点在 electionTimeout 时间内没有收到 Leader 的心跳信息就会触发新一轮的选主，在选主期间整个集群对外是不可用的。</p><p>如果 Follower 和 Candidate 崩溃，处理方式会简单很多。之后发送给它的 RequestVoteRPC 和 AppendEntriesRPC 会失败。由于 raft 的所有请求都是幂等的，所以失败的话会无限的重试。如果崩溃恢复后，就可以收到新的请求，然后选择追加或者拒绝 entry。</p><h3 id="5-3-时间与可用性"><a href="#5-3-时间与可用性" class="headerlink" title="5.3 时间与可用性"></a><a href="#_5-3-%E6%97%B6%E9%97%B4%E4%B8%8E%E5%8F%AF%E7%94%A8%E6%80%A7">5.3 时间与可用性</a></h3><p>raft 的要求之一就是安全性不依赖于时间：系统不能仅仅因为一些事件发生的比预想的快一些或者慢一些就产生错误。为了保证上述要求，最好能满足以下的时间条件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">broadcastTime &lt;&lt; electionTimeout &lt;&lt; MTBF</span><br></pre></td></tr></table></figure><ul><li><code>broadcastTime</code>：向其他节点并发发送消息的平均响应时间；</li><li><code>electionTimeout</code>：选举超时时间；</li><li><code>MTBF(mean time between failures)</code>：单台机器的平均健康时间；</li></ul><p><code>broadcastTime</code>应该比<code>electionTimeout</code>小一个数量级，为的是使<code>Leader</code>能够持续发送心跳信息（heartbeat）来阻止<code>Follower</code>开始选举；</p><p><code>electionTimeout</code>也要比<code>MTBF</code>小几个数量级，为的是使得系统稳定运行。当<code>Leader</code>崩溃时，大约会在整个<code>electionTimeout</code>的时间内不可用；我们希望这种情况仅占全部时间的很小一部分。</p><p>由于<code>broadcastTime</code>和<code>MTBF</code>是由系统决定的属性，因此需要决定<code>electionTimeout</code>的时间。</p><p>一般来说，broadcastTime 一般为 <code>0.5～20ms</code>，electionTimeout 可以设置为 <code>10～500ms</code>，MTBF 一般为一两个月。</p>]]></content>
      
      
      <categories>
          
          <category> 技术浅谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPC开发11_启动机制和注解驱动</title>
      <link href="/2025/01/23/RPC%E5%BC%80%E5%8F%9111_%E5%90%AF%E5%8A%A8%E6%9C%BA%E5%88%B6%E5%92%8C%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8/"/>
      <url>/2025/01/23/RPC%E5%BC%80%E5%8F%9111_%E5%90%AF%E5%8A%A8%E6%9C%BA%E5%88%B6%E5%92%8C%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、需求分析"><a href="#一、需求分析" class="headerlink" title="一、需求分析"></a>一、需求分析</h2><p>通过前面RPC 框架的功能已经比较完善了，接下来我们就要思考如何优化这个框架。</p><p>开发者会更关注框架的这些情况：</p><ul><li>框架的知名度和用户数：尽量选主流的、用户多的，经过了充分的市场验证。</li><li>生态和社区活跃度：尽量选社区活跃的、能和其他技术兼容的。</li><li>简单易用易上手：最好能开箱即用，不用花很多时间去上手。这点可能是我们在做个人小型项目时最关注的，可以把精力聚焦到业务开发上。</li></ul><p>回归到我们的 RPC 项目，其实框架目前是不够易用的。光是示例服务提供者，就要写下面这段很长的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProviderExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ProviderBootstrap.ServiceRegisterInfo</span><br><span class="line">        <span class="comment">// RPC 框架初始化</span></span><br><span class="line">        ProviderBootstrap.init();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册服务</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> UserService.class.getName();</span><br><span class="line">        LocalRegistry.register(serviceName, UserServiceImpl.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册服务到注册中心</span></span><br><span class="line">        <span class="type">RpcConfig</span> <span class="variable">rpcConfig</span> <span class="operator">=</span> RpcApplication.getRpcConfig();</span><br><span class="line">        <span class="type">RegistryConfig</span> <span class="variable">registryConfig</span> <span class="operator">=</span> rpcConfig.getRegistryConfig();</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> RegistryFactory.getInstance(registryConfig.getRegistry());</span><br><span class="line">        <span class="type">ServiceMetaInfo</span> <span class="variable">serviceMetaInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceMetaInfo</span>();</span><br><span class="line">        serviceMetaInfo.setServiceName(serviceName);</span><br><span class="line">        serviceMetaInfo.setServiceHost(rpcConfig.getServerHost());</span><br><span class="line">        serviceMetaInfo.setServicePort(rpcConfig.getServerPort());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            registry.register(serviceMetaInfo);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动 web 服务</span></span><br><span class="line">        <span class="type">VertxTcpServer</span> <span class="variable">vertxTcpServer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VertxTcpServer</span>();</span><br><span class="line">        vertxTcpServer.doStart(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本节我们来优化框架的易用性，通过建立合适的启动机制和注解驱动机制，帮助开发者最少只用一行代码，就能轻松使用框架。</p><h2 id="二、设计方案"><a href="#二、设计方案" class="headerlink" title="二、设计方案"></a>二、设计方案</h2><p>我们先站在上帝视角思考一下：怎么能让开发者用更少的代码启动框架？</p><h3 id="启动机制设计"><a href="#启动机制设计" class="headerlink" title="启动机制设计"></a>启动机制设计</h3><p>其实很简单，把所有启动代码封装成一个 <strong>专门的启动类</strong> 或方法，然后由服务提供者 &#x2F; 服务消费者调用即可。</p><p>但有一点我们需要注意，服务提供者和服务消费者需要初始化的模块是不同的，比如服务消费者不需要启动 Web 服务器。</p><p>所以我们需要针对服务提供者和消费者分别编写一个启动类，如果是二者都需要初始化的模块，可以放到全局应用类 <code>RpcApplication</code> 中，复用代码的同时保证启动类的可维护、可扩展性。</p><p>在 Dubbo 中，就有类似的设计，参考文档：<a href="https://cn.dubbo.apache.org/zh-cn/overview/mannual/java-sdk/quick-start/api/">https://cn.dubbo.apache.org/zh-cn/overview/mannual/java-sdk/quick-start/api/</a> 。</p><h3 id="注解驱动设计"><a href="#注解驱动设计" class="headerlink" title="注解驱动设计"></a>注解驱动设计</h3><p>除了启动类外，其实还有一种更更的方法，能帮助开发者使用框架。</p><p>它的做法是 <strong>注解驱动</strong>，开发者只需要在服务提供者实现类打上一个 <code>DubboService</code> 注解，就能快速注册服务；同样的，只要在服务消费者字段打上一个 <code>DubboReference</code> 注解，就能快速使用服务。</p><p>由于现在的 Java 项目基本都使用 Spring Boot 框架，所以 Dubbo 还贴推出了 Spring Boot Starter，用更少的代码在 Spring Boot 项目中使用框架。</p><p>参考文档：<a href="https://cn.dubbo.apache.org/zh-cn/overview/mannual/java-sdk/quick-start/spring-boot/">https://cn.dubbo.apache.org/zh-cn/overview/mannual/java-sdk/quick-start/spring-boot/</a></p><p>那我们也可以创建一个 Spring Boot Starter 项目，并通过注解驱动框架的初始化，完成服务注册和获取引用。</p><p>实现注解驱动并不复杂，有 2 种常用的方式：</p><ol><li>主动扫描：让开发者指定要扫描的路径，然后遍历所有的类文件，针对有注解的类文件，执行自定义的操作。</li><li>监听 Bean 加载：在 Spring 项目中，可以通过实现 BeanPostProcessor 接口，在 Bean 初始化后执行自定义的操作。</li></ol><h2 id="三、开发实现"><a href="#三、开发实现" class="headerlink" title="三、开发实现"></a>三、开发实现</h2><h3 id="启动机制"><a href="#启动机制" class="headerlink" title="启动机制"></a>启动机制</h3><p>在 rpc 项目中新建包名 <code>bootstrap</code>，所有和框架启动初始化相关的代码都放到该包下。</p><h4 id="服务提供者启动类"><a href="#服务提供者启动类" class="headerlink" title="服务提供者启动类"></a>服务提供者启动类</h4><p>新建 <code>ProviderBootstrap</code> 类，先直接复制之前服务提供者示例项目中的初始化代码，然后略微改造，支持用户传入自己要注册的服务。</p><p>在注册服务时，我们需要填入多个字段，比如服务名称、服务实现类，参考代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册服务</span></span><br><span class="line"><span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> UserService.class.getName();</span><br><span class="line">LocalRegistry.register(serviceName, UserServiceImpl.class);</span><br></pre></td></tr></table></figure><p>我们可以将这些字段进行封装，在 <code>model</code> 包下新建 <code>ServiceRegisterInfo</code> 类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务注册信息类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceRegisterInfo</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String serviceName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>&gt; implClass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一来，服务提供者的初始化方法只需要接受封装的注册信息列表作为参数即可，简化了方法。</p><p>服务提供者完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务提供者初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProviderBootstrap</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(List&lt;ServiceRegisterInfo&lt;?&gt;&gt; serviceRegisterInfoList)</span> &#123;</span><br><span class="line">        <span class="comment">// RPC 框架初始化（配置和注册中心）</span></span><br><span class="line">        RpcApplication.init();</span><br><span class="line">        <span class="comment">// 全局配置</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">RpcConfig</span> <span class="variable">rpcConfig</span> <span class="operator">=</span> RpcApplication.getRpcConfig();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册服务</span></span><br><span class="line">        <span class="keyword">for</span> (ServiceRegisterInfo&lt;?&gt; serviceRegisterInfo : serviceRegisterInfoList) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> serviceRegisterInfo.getServiceName();</span><br><span class="line">            <span class="comment">// 本地注册</span></span><br><span class="line">            LocalRegistry.register(serviceName, serviceRegisterInfo.getImplClass());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注册服务到注册中心</span></span><br><span class="line">            <span class="type">RegistryConfig</span> <span class="variable">registryConfig</span> <span class="operator">=</span> rpcConfig.getRegistryConfig();</span><br><span class="line">            <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> RegistryFactory.getInstance(registryConfig.getRegistry());</span><br><span class="line">            <span class="type">ServiceMetaInfo</span> <span class="variable">serviceMetaInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceMetaInfo</span>();</span><br><span class="line">            serviceMetaInfo.setServiceName(serviceName);</span><br><span class="line">            serviceMetaInfo.setServiceHost(rpcConfig.getServerHost());</span><br><span class="line">            serviceMetaInfo.setServicePort(rpcConfig.getServerPort());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                registry.register(serviceMetaInfo);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(serviceName + <span class="string">&quot; 服务注册失败&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动服务器</span></span><br><span class="line">        <span class="type">VertxTcpServer</span> <span class="variable">vertxTcpServer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VertxTcpServer</span>();</span><br><span class="line">        vertxTcpServer.doStart(rpcConfig.getServerPort());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在想要在服务提供者项目中使用 RPC 框架就非常简单了。只需要定义要注册的服务列表，然后一行代码调用 <code>ProviderBootstrap.init</code> 方法即可完成初始化。</p><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务提供者示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProviderExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 要注册的服务</span></span><br><span class="line">        List&lt;ServiceRegisterInfo&gt; serviceRegisterInfoList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">ServiceRegisterInfo</span> <span class="variable">serviceRegisterInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceRegisterInfo</span>(UserService.class.getName(), UserServiceImpl.class);</span><br><span class="line">        serviceRegisterInfoList.add(serviceRegisterInfo);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 服务提供者初始化</span></span><br><span class="line">        ProviderBootstrap.init(serviceRegisterInfoList);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="服务消费者启动类"><a href="#服务消费者启动类" class="headerlink" title="服务消费者启动类"></a>服务消费者启动类</h4><p>服务消费者启动类的实现就更简单了，因为它不需要注册服务、也不需要启动 Web 服务器，只需要执行 <code> RpcApplication.init</code> 完成框架的通用初始化即可。</p><p>服务消费者启动类的完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务消费者启动类（初始化）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerBootstrap</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// RPC 框架初始化（配置和注册中心）</span></span><br><span class="line">        RpcApplication.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务消费者示例项目的代码不会有明显的变化，只不过改为调用启动类了。</p><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsumerExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 服务提供者初始化</span></span><br><span class="line">        ConsumerBootstrap.init();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取代理</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> ServiceProxyFactory.getProxy(UserService.class);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;yupi&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">newUser</span> <span class="operator">=</span> userService.getUser(user);</span><br><span class="line">        <span class="keyword">if</span> (newUser != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(newUser.getName());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;user == null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring-Boot-Starter-注解驱动"><a href="#Spring-Boot-Starter-注解驱动" class="headerlink" title="Spring Boot Starter 注解驱动"></a>Spring Boot Starter 注解驱动</h3><p><strong>为了便于学习</strong>，不要和已有项目的代码混淆，我们再来创建一个新的项目模块，专门用于实现 Spring Boot Starter 注解驱动的 RPC 框架。</p><p>Dubbo 是在框架内引入了 spring-context，会让整个框架更内聚，但是不利于学习理解。</p><h4 id="1、Spring-Boot-Starter-项目初始化"><a href="#1、Spring-Boot-Starter-项目初始化" class="headerlink" title="1、Spring Boot Starter 项目初始化"></a>1、Spring Boot Starter 项目初始化</h4><p>创建好模块后，修改 pom.xml 文件，移除无用的插件代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;version&gt;$&#123;spring-boot.version&#125;&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">        &lt;mainClass&gt;com.yupi.yurpc.springboot.starter.YuRpcSpringBootStarterApplication&lt;/mainClass&gt;</span><br><span class="line"></span><br><span class="line">        &lt;skip&gt;<span class="literal">true</span>&lt;/skip&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/configuration&gt;</span><br><span class="line"></span><br><span class="line">    &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">            &lt;id&gt;repackage&lt;/id&gt;</span><br><span class="line"></span><br><span class="line">            &lt;goals&gt;</span><br><span class="line">                &lt;goal&gt;repackage&lt;/goal&gt;</span><br><span class="line"></span><br><span class="line">            &lt;/goals&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/executions&gt;</span><br><span class="line"></span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>引入我们开发的 RPC 框架：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.yupi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>yu-rpc-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>至此，Spring Boot Starter 项目已经完成初始化。</p><h4 id="2、定义注解"><a href="#2、定义注解" class="headerlink" title="2、定义注解"></a>2、定义注解</h4><p>实现注解驱动的第一步是定义注解，要定义哪些注解？我们怎么知道应该定义哪些注解？</p><p>可以参考知名框架 Dubbo 的注解。</p><p>比如：</p><ol><li>@EnableDubbo：在 Spring Boot 主应用类上使用，用于启用 Dubbo 功能。</li><li>@DubboComponentScan：在 Spring Boot 主应用类上使用，用于指定 Dubbo 组件扫描的包路径。</li><li>@DubboReference：在消费者中使用，用于声明 Dubbo 服务引用。</li><li>@DubboService：在提供者中使用，用于声明 Dubbo 服务。</li><li>@DubboMethod：在提供者和消费者中使用，用于配置 Dubbo 方法的参数、超时时间等。</li><li>@DubboTransported：在 Dubbo 提供者和消费者中使用，用于指定传输协议和参数，例如传输协议的类型、端口等。</li></ol><p>这些注解我们不需要全部用到，遵循最小可用化原则，只需要定义 3 个注解。</p><p>在 <code>yu-rpc-spring-boot-starter</code> 项目下新建 <code>annotation</code> 包，将所有注解代码放到该包下。</p><p>1）@EnableRpc：用于全局标识项目需要引入 RPC 框架、执行初始化方法。</p><p>由于服务消费者和服务提供者初始化的模块不同，我们需要在 EnableRpc 注解中，指定是否需要启动服务器等属性。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 启用 Rpc 注解</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableRpc &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要启动 server</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">needServer</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以将 EnableRpc 注解拆分为两个注解（比如 EnableRpcProvider、EnableRpcConsumer），分别用于标识服务提供者和消费者，但可能存在模块重复初始化的可能性。</p><p>2）@RpcService：服务提供者注解，在需要注册和提供的服务类上使用。</p><p>RpcService 注解中，需要指定服务注册信息属性，比如服务接口实现类、版本号等（也可以包括服务名称）。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务提供者注解（用于注册服务）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RpcService &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务接口类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt; interfaceClass() <span class="keyword">default</span> <span class="keyword">void</span>.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 版本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">serviceVersion</span><span class="params">()</span> <span class="keyword">default</span> RpcConstant.DEFAULT_SERVICE_VERSION;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）@RpcReference：服务消费者注解，在需要注入服务代理对象的属性上使用，类似 Spring 中的 @Resource 注解。</p><p>RpcReference 注解中，需要指定调用服务相关的属性，比如服务接口类（可能存在多个接口）、版本号、负载均衡器、重试策略、是否 Mock 模拟调用等。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务消费者注解（用于注入服务）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(ElementType.FIELD)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RpcReference &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务接口类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt; interfaceClass() <span class="keyword">default</span> <span class="keyword">void</span>.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 版本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">serviceVersion</span><span class="params">()</span> <span class="keyword">default</span> RpcConstant.DEFAULT_SERVICE_VERSION;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 负载均衡器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">loadBalancer</span><span class="params">()</span> <span class="keyword">default</span> LoadBalancerKeys.ROUND_ROBIN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重试策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">retryStrategy</span><span class="params">()</span> <span class="keyword">default</span> RetryStrategyKeys.NO;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 容错策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String <span class="title function_">tolerantStrategy</span><span class="params">()</span> <span class="keyword">default</span> TolerantStrategyKeys.FAIL_FAST;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">mock</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、注解驱动"><a href="#3、注解驱动" class="headerlink" title="3、注解驱动"></a>3、注解驱动</h4><p>在 starter 项目中新建 <code>bootstrap</code> 包，并且分别针对上面定义的 3 个注解新建启动类。</p><p>1）Rpc 框架全局启动类 <code>RpcInitBootstrap</code>。</p><p>我们的需求是，在 Spring 框架初始化时，获取 <code>@EnableRpc</code> 注解的属性，并初始化 RPC 框架。</p><p>怎么获取到注解的属性呢？</p><p>可以实现 Spring 的 <code>ImportBeanDefinitionRegistrar</code> 接口，并且在 <code>registerBeanDefinitions</code> 方法中，获取到项目的注解和注解属性。</p><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Rpc 框架启动</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcInitBootstrap</span> <span class="keyword">implements</span> <span class="title class_">ImportBeanDefinitionRegistrar</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Spring 初始化时执行，初始化 RPC 框架</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> importingClassMetadata</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取 EnableRpc 注解的属性值</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">needServer</span> <span class="operator">=</span> (<span class="type">boolean</span>) importingClassMetadata.getAnnotationAttributes(EnableRpc.class.getName())</span><br><span class="line">                .get(<span class="string">&quot;needServer&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// RPC 框架初始化（配置和注册中心）</span></span><br><span class="line">        RpcApplication.init();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 全局配置</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">RpcConfig</span> <span class="variable">rpcConfig</span> <span class="operator">=</span> RpcApplication.getRpcConfig();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动服务器</span></span><br><span class="line">        <span class="keyword">if</span> (needServer) &#123;</span><br><span class="line">            <span class="type">VertxTcpServer</span> <span class="variable">vertxTcpServer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VertxTcpServer</span>();</span><br><span class="line">            vertxTcpServer.doStart(rpcConfig.getServerPort());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;不启动 server&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，我们从 Spring 元信息中获取到了 EnableRpc 注解的 needServer 属性，并通过它来判断是否要启动服务器。</p><p>2）Rpc 服务提供者启动类 <code>RpcProviderBootstrap</code>。</p><p>服务提供者启动类的作用是，获取到所有包含 <code>@RpcService</code> 注解的类，并且通过注解的属性和反射机制，获取到要注册的服务信息，并且完成服务注册。</p><p>怎么获取到所有包含 <code>@RpcService</code> 注解的类呢？</p><p>像前面设计方案中提到的，可以主动扫描包，也可以利用 Spring 的特性监听 Bean 的加载。</p><p>此处我们选择后者，实现更简单，而且能直接获取到服务提供者类的 Bean 对象。</p><p>只需要让启动类实现 <code>BeanPostProcessor</code> 接口的 <code>postProcessAfterInitialization</code> 方法，就可以在某个服务提供者 Bean 初始化后，执行注册服务等操作了。</p><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Rpc 服务提供者启动</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcProviderBootstrap</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Bean 初始化后执行，注册服务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeansException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        Class&lt;?&gt; beanClass = bean.getClass();</span><br><span class="line">        <span class="type">RpcService</span> <span class="variable">rpcService</span> <span class="operator">=</span> beanClass.getAnnotation(RpcService.class);</span><br><span class="line">        <span class="keyword">if</span> (rpcService != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 需要注册服务</span></span><br><span class="line">            <span class="comment">// 1. 获取服务基本信息</span></span><br><span class="line">            Class&lt;?&gt; interfaceClass = rpcService.interfaceClass();</span><br><span class="line">            <span class="comment">// 默认值处理</span></span><br><span class="line">            <span class="keyword">if</span> (interfaceClass == <span class="keyword">void</span>.class) &#123;</span><br><span class="line">                interfaceClass = beanClass.getInterfaces()[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> interfaceClass.getName();</span><br><span class="line">            <span class="type">String</span> <span class="variable">serviceVersion</span> <span class="operator">=</span> rpcService.serviceVersion();</span><br><span class="line">            <span class="comment">// 2. 注册服务</span></span><br><span class="line">            <span class="comment">// 本地注册</span></span><br><span class="line">            LocalRegistry.register(serviceName, beanClass);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 全局配置</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">RpcConfig</span> <span class="variable">rpcConfig</span> <span class="operator">=</span> RpcApplication.getRpcConfig();</span><br><span class="line">            <span class="comment">// 注册服务到注册中心</span></span><br><span class="line">            <span class="type">RegistryConfig</span> <span class="variable">registryConfig</span> <span class="operator">=</span> rpcConfig.getRegistryConfig();</span><br><span class="line">            <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> RegistryFactory.getInstance(registryConfig.getRegistry());</span><br><span class="line">            <span class="type">ServiceMetaInfo</span> <span class="variable">serviceMetaInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceMetaInfo</span>();</span><br><span class="line">            serviceMetaInfo.setServiceName(serviceName);</span><br><span class="line">            serviceMetaInfo.setServiceVersion(serviceVersion);</span><br><span class="line">            serviceMetaInfo.setServiceHost(rpcConfig.getServerHost());</span><br><span class="line">            serviceMetaInfo.setServicePort(rpcConfig.getServerPort());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                registry.register(serviceMetaInfo);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(serviceName + <span class="string">&quot; 服务注册失败&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> BeanPostProcessor.<span class="built_in">super</span>.postProcessAfterInitialization(bean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实上述代码中，绝大多数服务提供者初始化的代码都只需要从之前写好的启动类中复制粘贴，只不过换了一种参数获取方式罢了。</p><p>3）Rpc 服务消费者启动类 <code>RpcConsumerBootstrap</code>。</p><p>和服务提供者启动类的实现方式类似，在 Bean 初始化后，通过反射获取到 Bean 的所有属性，如果属性包含 <code>@RpcReference</code> 注解，那么就为该属性动态生成代理对象并赋值。</p><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Rpc 服务消费者启动</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcConsumerBootstrap</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Bean 初始化后执行，注入服务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> beanName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> BeansException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        Class&lt;?&gt; beanClass = bean.getClass();</span><br><span class="line">        <span class="comment">// 遍历对象的所有属性</span></span><br><span class="line">        Field[] declaredFields = beanClass.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field : declaredFields) &#123;</span><br><span class="line">            <span class="type">RpcReference</span> <span class="variable">rpcReference</span> <span class="operator">=</span> field.getAnnotation(RpcReference.class);</span><br><span class="line">            <span class="keyword">if</span> (rpcReference != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 为属性生成代理对象</span></span><br><span class="line">                Class&lt;?&gt; interfaceClass = rpcReference.interfaceClass();</span><br><span class="line">                <span class="keyword">if</span> (interfaceClass == <span class="keyword">void</span>.class) &#123;</span><br><span class="line">                    interfaceClass = field.getType();</span><br><span class="line">                &#125;</span><br><span class="line">                field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">                <span class="type">Object</span> <span class="variable">proxyObject</span> <span class="operator">=</span> ServiceProxyFactory.getProxy(interfaceClass);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    field.set(bean, proxyObject);</span><br><span class="line">                    field.setAccessible(<span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;为字段注入代理对象失败&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> BeanPostProcessor.<span class="built_in">super</span>.postProcessAfterInitialization(bean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，核心方法是 <code>beanClass.getDeclaredFields</code>，用于获取类中的所有属性。</p><p>4）注册已编写的启动类。</p><p>最后，在 Spring 中加载我们已经编写好的启动类。</p><p>如何加载？</p><p>我们的需求是，仅在用户使用 <code>@EnableRpc</code> 注解时，才启动 RPC 框架。所以可以通过给 EnableRpc 增加 <code>@Import</code> 注解，来注册我们自定义的启动类，实现灵活的可选加载。</p><p>修改后的 EnableRpc 注解代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Import(&#123;RpcInitBootstrap.class, RpcProviderBootstrap.class, RpcConsumerBootstrap.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableRpc &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要启动 server</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">needServer</span><span class="params">()</span> <span class="keyword">default</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，一个基于注解驱动的 RPC 框架 Starter 开发完成。</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RPC框架开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPC开发10_容错机制</title>
      <link href="/2025/01/21/RPC%E5%BC%80%E5%8F%9110_%E5%AE%B9%E9%94%99%E6%9C%BA%E5%88%B6/"/>
      <url>/2025/01/21/RPC%E5%BC%80%E5%8F%9110_%E5%AE%B9%E9%94%99%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="一、需求分析"><a href="#一、需求分析" class="headerlink" title="一、需求分析"></a>一、需求分析</h2><p>上节给 RPC 框架增加了重试机制，提升了服务消费端的可靠性和健壮性。</p><p>但如果重试超过了一定次数仍然失败，又该怎么处理呢？</p><p>或者说当调用出现失败时，我们一定要重试么？有没有其他的策略呢？</p><p>本节实现另一种提高服务消费端可靠性和健壮性的机制 —— 容错机制。</p><h2 id="二、设计方案"><a href="#二、设计方案" class="headerlink" title="二、设计方案"></a>二、设计方案</h2><h3 id="容错机制"><a href="#容错机制" class="headerlink" title="容错机制"></a>容错机制</h3><p>容错是指系统在出现异常情况时，可以通过一定的策略保证系统仍然稳定运行，从而提高系统的可靠性和健壮性。</p><p>在分布式系统中，容错机制尤为重要，因为分布式系统中的各个组件都可能存在网络故障、节点故障等各种异常情况。要顾全大局，尽可能消除偶发 &#x2F; 单点故障对系统带来的整体影响。</p><p>打个比方，将分布式系统类比为一家公司，如果公司某个优秀员工请假了，需要 “触发容错”，让另一个普通员工顶上，这本质上是容错机制的一种 <strong>降级</strong> 策略。</p><p>容错机制一般都是在系统出现错误时才触发的，这点没什么好讲，需要重点学习的是容错策略和容错实现方式。</p><h4 id="容错策略"><a href="#容错策略" class="headerlink" title="容错策略"></a>容错策略</h4><p>容错策略有很多种，常用的容错策略主要是以下几个：</p><p>1）Fail-Over 故障转移：一次调用失败后，切换一个其他节点再次进行调用，也算是一种重试。</p><p>2）Fail-Back 失败自动恢复：系统的某个功能出现调用失败或错误时，通过其他的方法，恢复该功能的正常。可以理解为降级，比如重试、调用其他服务等。</p><p>3）Fail-Safe 静默处理：系统出现部分非重要功能的异常时，直接忽略掉，不做任何处理，就像错误没有发生过一样。</p><p>4）Fail-Fast 快速失败：系统出现调用错误时，立刻报错，交给外层调用方处理。</p><h4 id="容错实现方式"><a href="#容错实现方式" class="headerlink" title="容错实现方式"></a>容错实现方式</h4><p>容错其实是个比较广泛的概念，除了上面几种策略外，很多技术都可以起到容错的作用。</p><p>比如：</p><p>1）重试：重试本质上也是一种容错的降级策略，系统错误后再试一次。</p><p>2）限流：当系统压力过大、已经出现部分错误时，通过限制执行操作（接受请求）的频率或数量，对系统进行保护。</p><p>3）降级：系统出现错误后，改为执行其他更稳定可用的操作。也可以叫做 “兜底” 或 “有损服务”，这种方式的本质是：即使牺牲一定的服务质量，也要保证系统的部分功能可用，保证基本的功能需求得到满足。</p><p>4）熔断：系统出现故障或异常时，暂时中断对该服务的请求，而是执行其他操作，以避免连锁故障。</p><p>5）超时控制：如果请求或操作长时间没处理完成，就进行中断，防止阻塞和资源占用。</p><p>注意，在实际项目中，根据对系统可靠性的需求，我们通常会结合多种策略或方法实现容错机制。</p><h3 id="容错方案设计"><a href="#容错方案设计" class="headerlink" title="容错方案设计"></a>容错方案设计</h3><p>回归到我们的 RPC 框架，之前已经给系统增加重试机制了，算是实现了一部分的容错能力。</p><p>现在，我们可以正式引入容错机制，通过更多策略来进一步增加系统可靠性。</p><p>容错方案的设计可以是很灵活的，建议大家先自己思考。</p><p>这里提供 2 种方案：</p><p>1）先容错再重试。</p><p>当系统发生异常时，首先会触发容错机制，比如记录日志、进行告警等，然后可以选择是否进行重试。</p><p>这种方案其实是把重试当做容错机制的一种可选方案。</p><p>2）先重试再容错。在发生错误后，首先尝试重试操作，如果重试多次仍然失败，则触发容错机制，比如记录日志、进行告警等。</p><p>这 2 种方案其实可以结合使用。</p><p>系统错误时，先通过重试操作解决一些临时性的异常，比如网络波动、服务端临时不可用等；如果重试多次后仍然失败，说明可能存在更严重的问题，这时可以触发其他的容错策略，比如调用降级服务、熔断、限流、快速失败等，来减少异常的影响，保障系统的稳定性和可靠性。</p><p>举个具体的例子：</p><ol><li>系统调用服务 A 出现网络错误，使用容错策略 - 重试。</li><li>重试 3 次失败后，使用其他容错策略 - 降级。</li><li>系统改为调用不依赖网络的服务 B，完成操作。</li></ol><h2 id="三、开发实现"><a href="#三、开发实现" class="headerlink" title="三、开发实现"></a>三、开发实现</h2><h3 id="1、多种容错策略实现"><a href="#1、多种容错策略实现" class="headerlink" title="1、多种容错策略实现"></a>1、多种容错策略实现</h3><p>下面实现 2 种最基本的容错策略：Fail-Fast 快速失败、Fail-Safe 静默处理。</p><p>在 RPC 项目中新建 <code>fault.tolerant</code> 包，将所有容错相关的代码放到该包下。</p><p>1）先编写容错策略通用接口。提供一个容错方法，使用 Map 类型的参数接受上下文信息（可用于灵活地传递容错处理需要用到的数据），并且接受一个具体的异常类参数。</p><p>由于容错是应用到发送请求操作的，所以容错方法的返回值是 RpcResponse（响应）。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 容错策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TolerantStrategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 容错</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context 上下文，用于传递数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e       异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RpcResponse <span class="title function_">doTolerant</span><span class="params">(Map&lt;String, Object&gt; context, Exception e)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）快速失败容错策略实现。</p><p>很好理解，就是遇到异常后，将异常再次抛出，交给外层处理。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快速失败 - 容错策略（立刻通知外层调用方）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FailFastTolerantStrategy</span> <span class="keyword">implements</span> <span class="title class_">TolerantStrategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> RpcResponse <span class="title function_">doTolerant</span><span class="params">(Map&lt;String, Object&gt; context, Exception e)</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;服务报错&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）静默处理容错策略实现。</p><p>也很好理解，就是遇到异常后，记录一条日志，然后正常返回一个响应对象，就好像没有出现过报错。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静默处理异常 - 容错策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FailSafeTolerantStrategy</span> <span class="keyword">implements</span> <span class="title class_">TolerantStrategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> RpcResponse <span class="title function_">doTolerant</span><span class="params">(Map&lt;String, Object&gt; context, Exception e)</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;静默处理异常&quot;</span>, e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">RpcResponse</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4）其他容错策略。</p><p>还可以自行实现更多的容错策略，比如 <code>FailBackTolerantStrategy</code> 故障恢复策略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 降级到其他服务 - 容错策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FailBackTolerantStrategy</span> <span class="keyword">implements</span> <span class="title class_">TolerantStrategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> RpcResponse <span class="title function_">doTolerant</span><span class="params">(Map&lt;String, Object&gt; context, Exception e)</span> &#123;</span><br><span class="line">        <span class="comment">// todo 可自行扩展，获取降级的服务并调用</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有 <code>FailOverTolerantStrategy</code> 故障转移策略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 转移到其他服务节点 - 容错策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FailOverTolerantStrategy</span> <span class="keyword">implements</span> <span class="title class_">TolerantStrategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> RpcResponse <span class="title function_">doTolerant</span><span class="params">(Map&lt;String, Object&gt; context, Exception e)</span> &#123;</span><br><span class="line">        <span class="comment">// todo 可自行扩展，获取其他服务节点并调用</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、支持配置和扩展容错策略"><a href="#2、支持配置和扩展容错策略" class="headerlink" title="2、支持配置和扩展容错策略"></a>2、支持配置和扩展容错策略</h3><p>一个成熟的 RPC 框架可能会支持多种不同的容错策略，像序列化器、注册中心、负载均衡器一样，我们的需求是，让开发者能够填写配置来指定使用的容错策略，并且支持自定义容错策略，让框架更易用、更利于扩展。</p><p>要实现这点，开发方式和序列化器、注册中心、负载均衡器都是一样的，都可以使用工厂创建对象、使用 SPI 动态加载自定义的注册中心。</p><p>1）容错策略常量。</p><p>在 <code>fault.tolerant</code> 包下新建 <code>TolerantStrategyKeys</code> 类，列举所有支持的容错策略键名。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 容错策略键名常量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">TolerantStrategyKeys</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 故障恢复</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">FAIL_BACK</span> <span class="operator">=</span> <span class="string">&quot;failBack&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 快速失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">FAIL_FAST</span> <span class="operator">=</span> <span class="string">&quot;failFast&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 故障转移</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">FAIL_OVER</span> <span class="operator">=</span> <span class="string">&quot;failOver&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静默处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">FAIL_SAFE</span> <span class="operator">=</span> <span class="string">&quot;failSafe&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）使用工厂模式，支持根据 key 从 SPI 获取容错策略对象实例。</p><p>在 <code>fault.tolerant</code> 包下新建 <code>TolerantStrategyFactory</code> 类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 容错策略工厂（工厂模式，用于获取容错策略对象）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TolerantStrategyFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        SpiLoader.load(TolerantStrategy.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认容错策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">TolerantStrategy</span> <span class="variable">DEFAULT_RETRY_STRATEGY</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FailFastTolerantStrategy</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取实例</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TolerantStrategy <span class="title function_">getInstance</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SpiLoader.getInstance(TolerantStrategy.class, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类可以直接复制之前的 SerializerFactory，然后略做修改。可以发现，只要跑通了一次 SPI 机制，后续的开发就很简单。</p><p>3）在 <code>META-INF</code> 的 <code>rpc/system</code> 目录下编写容错策略接口的 SPI 配置文件，文件名称为 <code>com.yupi.yurpc.fault.tolerant.TolerantStrategy</code>。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">failBack=com.yupi.yurpc.fault.tolerant.FailBackTolerantStrategy</span><br><span class="line">failFast=com.yupi.yurpc.fault.tolerant.FailFastTolerantStrategy</span><br><span class="line">failOver=com.yupi.yurpc.fault.tolerant.FailOverTolerantStrategy</span><br><span class="line">failSafe=com.yupi.yurpc.fault.tolerant.FailSafeTolerantStrategy</span><br></pre></td></tr></table></figure><p>4）为 RpcConfig 全局配置新增容错策略的配置，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 容错策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">tolerantStrategy</span> <span class="operator">=</span> TolerantStrategyKeys.FAIL_FAST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、应用容错功能"><a href="#3、应用容错功能" class="headerlink" title="3、应用容错功能"></a>3、应用容错功能</h3><p>容错功能的应用非常简单，我们只需要修改 ServiceProxy 的部分代码，在重试多次抛出异常时，从工厂中获取容错策略并执行即可。</p><p>修改的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rpc 请求</span></span><br><span class="line"><span class="comment">// 使用重试机制</span></span><br><span class="line">RpcResponse rpcResponse;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">RetryStrategy</span> <span class="variable">retryStrategy</span> <span class="operator">=</span> RetryStrategyFactory.getInstance(rpcConfig.getRetryStrategy());</span><br><span class="line">    rpcResponse = retryStrategy.doRetry(() -&gt;</span><br><span class="line">            VertxTcpClient.doRequest(rpcRequest, selectedServiceMetaInfo)</span><br><span class="line">    );</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 容错机制</span></span><br><span class="line">    <span class="type">TolerantStrategy</span> <span class="variable">tolerantStrategy</span> <span class="operator">=</span> TolerantStrategyFactory.getInstance(rpcConfig.getTolerantStrategy());</span><br><span class="line">    rpcResponse = tolerantStrategy.doTolerant(<span class="literal">null</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> rpcResponse.getData();</span><br></pre></td></tr></table></figure><p>修改后的 ServiceProxy 的完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务代理（JDK 动态代理）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用代理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 构造请求</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> method.getDeclaringClass().getName();</span><br><span class="line">        <span class="type">RpcRequest</span> <span class="variable">rpcRequest</span> <span class="operator">=</span> RpcRequest.builder()</span><br><span class="line">                .serviceName(serviceName)</span><br><span class="line">                .methodName(method.getName())</span><br><span class="line">                .parameterTypes(method.getParameterTypes())</span><br><span class="line">                .args(args)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从注册中心获取服务提供者请求地址</span></span><br><span class="line">        <span class="type">RpcConfig</span> <span class="variable">rpcConfig</span> <span class="operator">=</span> RpcApplication.getRpcConfig();</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> RegistryFactory.getInstance(rpcConfig.getRegistryConfig().getRegistry());</span><br><span class="line">        <span class="type">ServiceMetaInfo</span> <span class="variable">serviceMetaInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceMetaInfo</span>();</span><br><span class="line">        serviceMetaInfo.setServiceName(serviceName);</span><br><span class="line">        serviceMetaInfo.setServiceVersion(RpcConstant.DEFAULT_SERVICE_VERSION);</span><br><span class="line">        List&lt;ServiceMetaInfo&gt; serviceMetaInfoList = registry.serviceDiscovery(serviceMetaInfo.getServiceKey());</span><br><span class="line">        <span class="keyword">if</span> (CollUtil.isEmpty(serviceMetaInfoList)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;暂无服务地址&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 负载均衡</span></span><br><span class="line">        <span class="type">LoadBalancer</span> <span class="variable">loadBalancer</span> <span class="operator">=</span> LoadBalancerFactory.getInstance(rpcConfig.getLoadBalancer());</span><br><span class="line">        <span class="comment">// 将调用方法名（请求路径）作为负载均衡参数</span></span><br><span class="line">        Map&lt;String, Object&gt; requestParams = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        requestParams.put(<span class="string">&quot;methodName&quot;</span>, rpcRequest.getMethodName());</span><br><span class="line">        <span class="type">ServiceMetaInfo</span> <span class="variable">selectedServiceMetaInfo</span> <span class="operator">=</span> loadBalancer.select(requestParams, serviceMetaInfoList);</span><br><span class="line">        <span class="comment">// rpc 请求</span></span><br><span class="line">        <span class="comment">// 使用重试机制</span></span><br><span class="line">        RpcResponse rpcResponse;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">RetryStrategy</span> <span class="variable">retryStrategy</span> <span class="operator">=</span> RetryStrategyFactory.getInstance(rpcConfig.getRetryStrategy());</span><br><span class="line">            rpcResponse = retryStrategy.doRetry(() -&gt;</span><br><span class="line">                    VertxTcpClient.doRequest(rpcRequest, selectedServiceMetaInfo)</span><br><span class="line">            );</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 容错机制</span></span><br><span class="line">            <span class="type">TolerantStrategy</span> <span class="variable">tolerantStrategy</span> <span class="operator">=</span> TolerantStrategyFactory.getInstance(rpcConfig.getTolerantStrategy());</span><br><span class="line">            rpcResponse = tolerantStrategy.doTolerant(<span class="literal">null</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rpcResponse.getData();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RPC框架开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPC开发9_重试机制</title>
      <link href="/2025/01/20/RPC%E5%BC%80%E5%8F%919_%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6/"/>
      <url>/2025/01/20/RPC%E5%BC%80%E5%8F%919_%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="一、需求分析"><a href="#一、需求分析" class="headerlink" title="一、需求分析"></a>一、需求分析</h2><p>目前，如果使用 RPC 框架的服务消费者调用接口失败，就会直接报错。</p><p>调用接口失败可能有很多原因，有时可能是服务提供者返回了错误，但有时可能只是网络不稳定或服务提供者重启等临时性问题。这种情况下，我们可能更希望服务消费者拥有自动重试的能力，提高系统的可用性。</p><p>本节实现服务消费端的重试机制。</p><h2 id="二、设计方案"><a href="#二、设计方案" class="headerlink" title="二、设计方案"></a>二、设计方案</h2><h3 id="重试机制"><a href="#重试机制" class="headerlink" title="重试机制"></a>重试机制</h3><p>我们需要掌握的是 “如何设计重试机制”，重试机制的核心是 <strong>重试策略</strong>，一般来说，包含以下几个考虑点：</p><ol><li>什么时候、什么条件下重试？</li><li>重试时间（确定下一次的重试时间）</li><li>什么时候、什么条件下停止重试？</li><li>重试后要做什么？</li></ol><h4 id="重试条件"><a href="#重试条件" class="headerlink" title="重试条件"></a>重试条件</h4><p>首先是什么时候、什么条件下重试？</p><p>如果我们希望提高系统的可用性，可当由于网络等异常情况发生时，触发重试。</p><h4 id="重试时间"><a href="#重试时间" class="headerlink" title="重试时间"></a>重试时间</h4><p>重试时间（也叫重试等待）的策略就比较丰富了，可能会用到一些算法，主流的重试时间算法有：</p><p>1）固定重试间隔（Fixed Retry Interval）：在每次重试之间使用固定的时间间隔。</p><p>比如近 5 次重试的时间点如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1s</span><br><span class="line">2s</span><br><span class="line">3s</span><br><span class="line">4s</span><br><span class="line">5s</span><br></pre></td></tr></table></figure><p>2）指数退避重试（Exponential Backoff Retry）：在每次失败后，重试的时间间隔会以指数级增加，以避免请求过于密集。</p><p>比如近 5 次重试的时间点如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1s</span><br><span class="line">3s（多等 2s）</span><br><span class="line">7s（多等 4s）</span><br><span class="line">15s（多等 8s）</span><br><span class="line">31s（多等 16s）</span><br></pre></td></tr></table></figure><p>3）随机延迟重试（Random Delay Retry）：在每次重试之间使用随机的时间间隔，以避免请求的同时发生。</p><p>4）可变延迟重试（Variable Delay Retry）：这种策略更 “高级” 了，根据先前重试的成功或失败情况，动态调整下一次重试的延迟时间。比如，根据前一次的响应时间调整下一次重试的等待时间。</p><p>值得一提的是，以上的策略是可以组合使用的，一定要根据具体情况和需求灵活调整。比如可以先使用指数退避重试策略，如果连续多次重试失败，则切换到固定重试间隔策略。</p><h4 id="停止重试"><a href="#停止重试" class="headerlink" title="停止重试"></a>停止重试</h4><p>一般来说，重试次数是有上限的，否则随着报错的增多，系统同时发生的重试也会越来越多，造成雪崩。</p><p>主流的停止重试策略有：</p><p>1）最大尝试次数：一般重试当达到最大次数时不再重试。</p><p>2）超时停止：重试达到最大时间的时候，停止重试。</p><h4 id="重试工作"><a href="#重试工作" class="headerlink" title="重试工作"></a>重试工作</h4><p>最后一点是重试后要做什么事情？一般来说就是重复执行原本要做的操作，比如发送请求失败了，那就再发一次请求。</p><p>需要注意的是，当重试次数超过上限时，往往还要进行其他的操作，比如：</p><ol><li>通知告警：让开发者人工介入</li><li>降级容错：改为调用其他接口、或者执行其他操作</li></ol><h3 id="重试方案设计"><a href="#重试方案设计" class="headerlink" title="重试方案设计"></a>重试方案设计</h3><p>回归到我们的 RPC 框架，消费者发起调用的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// rpc 请求</span></span><br><span class="line">    <span class="type">RpcResponse</span> <span class="variable">rpcResponse</span> <span class="operator">=</span> VertxTcpClient.doRequest(rpcRequest, selectedServiceMetaInfo);</span><br><span class="line">    <span class="keyword">return</span> rpcResponse.getData();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;调用失败&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们完全可以将 <code>VertxTcpClient.doRequest</code> 封装为一个可重试的任务，如果请求失败（重试条件），系统就会自动按照重试策略再次发起请求，不用开发者关心。</p><p>对于重试算法，我们就选择主流的重试算法，Java 中可以使用 Guava-Retrying 库轻松实现多种不同的重试算法。</p><p>鱼皮之前专门写过一篇 Guava-Retrying 的教程文章：<a href="https://cloud.tencent.com/developer/article/1752086">https://cloud.tencent.com/developer/article/1752086</a></p><p>和序列化器、注册中心、负载均衡器一样，重试策略本身也可以使用 SPI + 工厂的方式，允许开发者动态配置和扩展自己的重试策略。</p><p>最后，如果重试超过一定次数，我们就停止重试，并且抛出异常。还有重试失败后的另一种选择 —— 容错机制。</p><h2 id="三、开发实现"><a href="#三、开发实现" class="headerlink" title="三、开发实现"></a>三、开发实现</h2><h3 id="1、多种重试策略实现"><a href="#1、多种重试策略实现" class="headerlink" title="1、多种重试策略实现"></a>1、多种重试策略实现</h3><p>下面实现 2 种最基本的重试策略：不重试、固定重试间隔。</p><p>在 RPC 项目中新建 <code>fault.retry</code> 包，将所有重试相关的代码放到该包下。</p><p>1）先编写重试策略通用接口。提供一个重试方法，接受一个具体的任务参数，可以使用 Callable 类代表一个任务。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重试策略</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href=&quot;https://github.com/liyupi&quot;&gt;程序员鱼皮&lt;/a&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@learn</span> &lt;a href=&quot;https://codefather.cn&quot;&gt;鱼皮的编程宝典&lt;/a&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@from</span> &lt;a href=&quot;https://yupi.icu&quot;&gt;编程导航学习圈&lt;/a&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RetryStrategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重试</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> callable</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RpcResponse <span class="title function_">doRetry</span><span class="params">(Callable&lt;RpcResponse&gt; callable)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）引入 Guava-Retrying 重试库，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:<span class="comment">//github.com/rholder/guava-retrying --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.github.rholder&lt;/groupId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;guava-retrying&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;version&gt;<span class="number">2.0</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3）不重试策略实现。</p><p>就是直接执行一次任务，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 不重试 - 重试策略</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NoRetryStrategy</span> <span class="keyword">implements</span> <span class="title class_">RetryStrategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重试</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> callable</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> RpcResponse <span class="title function_">doRetry</span><span class="params">(Callable&lt;RpcResponse&gt; callable)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> callable.call();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4）固定重试间隔策略实现。</p><p>使用 Guava-Retrying 提供的 <code>RetryerBuilder</code> 能够很方便地指定重试条件、重试等待策略、重试停止策略、重试工作等。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 固定时间间隔 - 重试策略</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href=&quot;https://github.com/liyupi&quot;&gt;程序员鱼皮&lt;/a&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@learn</span> &lt;a href=&quot;https://codefather.cn&quot;&gt;鱼皮的编程宝典&lt;/a&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@from</span> &lt;a href=&quot;https://yupi.icu&quot;&gt;编程导航学习圈&lt;/a&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FixedIntervalRetryStrategy</span> <span class="keyword">implements</span> <span class="title class_">RetryStrategy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重试</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> callable</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ExecutionException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> RetryException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> RpcResponse <span class="title function_">doRetry</span><span class="params">(Callable&lt;RpcResponse&gt; callable)</span> <span class="keyword">throws</span> ExecutionException, RetryException &#123;</span><br><span class="line">        Retryer&lt;RpcResponse&gt; retryer = RetryerBuilder.&lt;RpcResponse&gt;newBuilder()</span><br><span class="line">                .retryIfExceptionOfType(Exception.class)</span><br><span class="line">                .withWaitStrategy(WaitStrategies.fixedWait(<span class="number">3L</span>, TimeUnit.SECONDS))</span><br><span class="line">                .withStopStrategy(StopStrategies.stopAfterAttempt(<span class="number">3</span>))</span><br><span class="line">                .withRetryListener(<span class="keyword">new</span> <span class="title class_">RetryListener</span>() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="keyword">public</span> &lt;V&gt; <span class="keyword">void</span> <span class="title function_">onRetry</span><span class="params">(Attempt&lt;V&gt; attempt)</span> &#123;</span><br><span class="line">                        log.info(<span class="string">&quot;重试次数 &#123;&#125;&quot;</span>, attempt.getAttemptNumber());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> retryer.call(callable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，重试策略如下：</p><ul><li>重试条件：使用 retryIfExceptionOfType 方法指定当出现 Exception 异常时重试。</li><li>重试等待策略：使用 withWaitStrategy 方法指定策略，选择 fixedWait 固定时间间隔策略。</li><li>重试停止策略：使用 withStopStrategy 方法指定策略，选择 stopAfterAttempt 超过最大重试次数停止。</li><li>重试工作：使用 withRetryListener 监听重试，每次重试时，除了再次执行任务外，还能够打印当前的重试次数。</li></ul><p>5）可以简单编写一个单元测试，来验证不同的重试策略，这是最好的学习方式。</p><p>单元测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重试策略测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RetryStrategyTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">RetryStrategy</span> <span class="variable">retryStrategy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NoRetryStrategy</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doRetry</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">RpcResponse</span> <span class="variable">rpcResponse</span> <span class="operator">=</span> retryStrategy.doRetry(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;测试重试&quot;</span>);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;模拟重试失败&quot;</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">            System.out.println(rpcResponse);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;重试多次失败&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、支持配置和扩展重试策略"><a href="#2、支持配置和扩展重试策略" class="headerlink" title="2、支持配置和扩展重试策略"></a>2、支持配置和扩展重试策略</h3><p>一个成熟的 RPC 框架可能会支持多种不同的重试策略，像序列化器、注册中心、负载均衡器一样，我们的需求是，让开发者能够填写配置来指定使用的重试策略，并且支持自定义重试策略，让框架更易用、更利于扩展。</p><p>要实现这点，开发方式和序列化器、注册中心、负载均衡器都是一样的，都可以使用工厂创建对象、使用 SPI 动态加载自定义的注册中心。</p><p>1）重试策略常量。</p><p>在 <code>fault.retry</code> 包下新建 <code>RetryStrategyKeys</code> 类，列举所有支持的重试策略键名。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重试策略键名常量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RetryStrategyKeys</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不重试</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">NO</span> <span class="operator">=</span> <span class="string">&quot;no&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 固定时间间隔</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">FIXED_INTERVAL</span> <span class="operator">=</span> <span class="string">&quot;fixedInterval&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）使用工厂模式，支持根据 key 从 SPI 获取重试策略对象实例。</p><p>在 <code>fault.retry</code> 包下新建 <code>RetryStrategyFactory</code> 类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重试策略工厂（用于获取重试器对象）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RetryStrategyFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        SpiLoader.load(RetryStrategy.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认重试器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">RetryStrategy</span> <span class="variable">DEFAULT_RETRY_STRATEGY</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NoRetryStrategy</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取实例</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> RetryStrategy <span class="title function_">getInstance</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SpiLoader.getInstance(RetryStrategy.class, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类可以直接复制之前的 SerializerFactory，然后略做修改。可以发现，只要跑通了一次 SPI 机制，后续的开发就很简单了。</p><p>3）在 <code>META-INF</code> 的 <code>rpc/system</code> 目录下编写重试策略接口的 SPI 配置文件，文件名称为 <code>com.yupi.yurpc.fault.retry.RetryStrategy</code>。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">no=com.yupi.yurpc.fault.retry.NoRetryStrategy</span><br><span class="line">fixedInterval=com.yupi.yurpc.fault.retry.FixedIntervalRetryStrategy</span><br></pre></td></tr></table></figure><p>4）为 RpcConfig 全局配置新增重试策略的配置，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重试策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">retryStrategy</span> <span class="operator">=</span> RetryStrategyKeys.NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、应用重试功能"><a href="#3、应用重试功能" class="headerlink" title="3、应用重试功能"></a>3、应用重试功能</h3><p>现在，我们就能够愉快地使用重试功能了。修改 ServiceProxy 的代码，从工厂中获取重试器，并且将请求代码封装为一个 Callable 接口，作为重试器的参数，调用重试器即可。</p><p>修改的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用重试机制</span></span><br><span class="line"><span class="type">RetryStrategy</span> <span class="variable">retryStrategy</span> <span class="operator">=</span> RetryStrategyFactory.getInstance(rpcConfig.getRetryStrategy());</span><br><span class="line"><span class="type">RpcResponse</span> <span class="variable">rpcResponse</span> <span class="operator">=</span> retryStrategy.doRetry(() -&gt;</span><br><span class="line">        VertxTcpClient.doRequest(rpcRequest, selectedServiceMetaInfo)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>上述代码中，使用 Lambda 表达式将 <code>VertxTcpClient.doRequest</code> 封装为了一个匿名函数，简化了代码。</p><p>修改后的 ServiceProxy 的完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务代理（JDK 动态代理）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用代理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 指定序列化器</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Serializer</span> <span class="variable">serializer</span> <span class="operator">=</span> SerializerFactory.getInstance(RpcApplication.getRpcConfig().getSerializer());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造请求</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> method.getDeclaringClass().getName();</span><br><span class="line">        <span class="type">RpcRequest</span> <span class="variable">rpcRequest</span> <span class="operator">=</span> RpcRequest.builder()</span><br><span class="line">                .serviceName(serviceName)</span><br><span class="line">                .methodName(method.getName())</span><br><span class="line">                .parameterTypes(method.getParameterTypes())</span><br><span class="line">                .args(args)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 从注册中心获取服务提供者请求地址</span></span><br><span class="line">            <span class="type">RpcConfig</span> <span class="variable">rpcConfig</span> <span class="operator">=</span> RpcApplication.getRpcConfig();</span><br><span class="line">            <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> RegistryFactory.getInstance(rpcConfig.getRegistryConfig().getRegistry());</span><br><span class="line">            <span class="type">ServiceMetaInfo</span> <span class="variable">serviceMetaInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceMetaInfo</span>();</span><br><span class="line">            serviceMetaInfo.setServiceName(serviceName);</span><br><span class="line">            serviceMetaInfo.setServiceVersion(RpcConstant.DEFAULT_SERVICE_VERSION);</span><br><span class="line">            List&lt;ServiceMetaInfo&gt; serviceMetaInfoList = registry.serviceDiscovery(serviceMetaInfo.getServiceKey());</span><br><span class="line">            <span class="keyword">if</span> (CollUtil.isEmpty(serviceMetaInfoList)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;暂无服务地址&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 负载均衡</span></span><br><span class="line">            <span class="type">LoadBalancer</span> <span class="variable">loadBalancer</span> <span class="operator">=</span> LoadBalancerFactory.getInstance(rpcConfig.getLoadBalancer());</span><br><span class="line">            <span class="comment">// 将调用方法名（请求路径）作为负载均衡参数</span></span><br><span class="line">            Map&lt;String, Object&gt; requestParams = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            requestParams.put(<span class="string">&quot;methodName&quot;</span>, rpcRequest.getMethodName());</span><br><span class="line">            <span class="type">ServiceMetaInfo</span> <span class="variable">selectedServiceMetaInfo</span> <span class="operator">=</span> loadBalancer.select(requestParams, serviceMetaInfoList);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// rpc 请求</span></span><br><span class="line">            <span class="comment">// 使用重试机制</span></span><br><span class="line">            <span class="type">RetryStrategy</span> <span class="variable">retryStrategy</span> <span class="operator">=</span> RetryStrategyFactory.getInstance(rpcConfig.getRetryStrategy());</span><br><span class="line">            <span class="type">RpcResponse</span> <span class="variable">rpcResponse</span> <span class="operator">=</span> retryStrategy.doRetry(() -&gt;</span><br><span class="line">                    VertxTcpClient.doRequest(rpcRequest, selectedServiceMetaInfo)</span><br><span class="line">            );            </span><br><span class="line">            <span class="keyword">return</span> rpcResponse.getData();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;调用失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们会发现，即使引入了重试机制，整段代码并没有变得更复杂，这就是可扩展性设计的巧妙之处。</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RPC框架开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPC开发8_负载均衡</title>
      <link href="/2025/01/18/RPC%E5%BC%80%E5%8F%918_%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
      <url>/2025/01/18/RPC%E5%BC%80%E5%8F%918_%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="一、需求分析"><a href="#一、需求分析" class="headerlink" title="一、需求分析"></a>一、需求分析</h2><p>现在RPC 框架已经可以从注册中心获取到服务提供者的注册信息了，同一个服务可能会有多个服务提供者，但是目前消费者始终读取了第一个服务提供者节点发起调用，不仅会增大单个节点的压力，而且没有利用好其他节点的资源。</p><p>我们完全可以从服务提供者节点中，选择一个服务提供者发起请求，而不是每次都请求同一个服务提供者，这个操作就叫做 <strong>负载均衡</strong>。</p><p>本节为 RPC 框架支持服务消费者的负载均衡。</p><h2 id="二、负载均衡"><a href="#二、负载均衡" class="headerlink" title="二、负载均衡"></a>二、负载均衡</h2><h3 id="什么是负载均衡？"><a href="#什么是负载均衡？" class="headerlink" title="什么是负载均衡？"></a>什么是负载均衡？</h3><p>把这个词拆开来看：</p><p>1）何为负载？可以把负载理解为要处理的工作和压力，比如网络请求、事务、数据处理任务等。</p><p>2）何为均衡？把工作和压力平均地分配给多个工作者，从而分摊每个工作者的压力，保证大家正常工作。</p><p>用个比喻，假设餐厅里只有一个服务员，如果顾客非常多，他可能会忙不过来，没法及时上菜、忙中生乱；而且他的压力会越来越大，最严重的情况下就累倒了无法继续工作。而如果有多个服务员，大家能够服务更多的顾客，即使有一个服务员生病了，其他服务员也能帮忙顶上。</p><p>所以，负载均衡是一种用来分配网络或计算负载到多个资源上的技术。它的目的是确保每个资源都能够有效地处理负载、增加系统的并发量、避免某些资源过载而导致性能下降或服务不可用的情况。</p><p>回归到RPC 框架，负载均衡的作用是从一组可用的服务提供者中选择一个进行调用。</p><p>常用的负载均衡实现技术有 Nginx（七层负载均衡）、LVS（四层负载均衡）等。</p><h3 id="常见负载均衡算法"><a href="#常见负载均衡算法" class="headerlink" title="常见负载均衡算法"></a>常见负载均衡算法</h3><p>负载均衡学习的重点就是它的算法 —— 按照什么策略选择资源。</p><p>不同的负载均衡算法，适用的场景也不同，一定要根据实际情况选取，主流的负载均衡算法如下：</p><p>1）轮询（Round Robin）：按照循环的顺序将请求分配给每个服务器，适用于各服务器性能相近的情况。</p><p>假如有 5 台服务器节点，请求调用顺序如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span></span><br></pre></td></tr></table></figure><p>2）随机（Random）：随机选择一个服务器来处理请求，适用于服务器性能相近且负载均匀的情况。</p><p>假如有 5 台服务器节点，请求调用顺序如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span></span><br></pre></td></tr></table></figure><p>3）加权轮询（Weighted Round Robin）：根据服务器的性能或权重分配请求，性能更好的服务器会获得更多的请求，适用于服务器性能不均的情况。</p><p>假如有 1 台千兆带宽的服务器节点和 4 台百兆带宽的服务器节点，请求调用顺序可能如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>, <span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>, <span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>, <span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span></span><br></pre></td></tr></table></figure><p>4）加权随机（Weighted Random）：根据服务器的权重随机选择一个服务器处理请求，适用于服务器性能不均的情况。</p><p>假如有 2 台千兆带宽的服务器节点和 3 台百兆带宽的服务器节点，请求调用顺序可能如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>, <span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>, <span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span></span><br></pre></td></tr></table></figure><p>5）最小连接数（Least Connections）：选择当前连接数最少的服务器来处理请求，适用于长连接场景。</p><p>6）IP Hash：根据客户端 IP 地址的哈希值选择服务器处理请求，确保同一客户端的请求始终被分配到同一台服务器上，适用于需要保持会话一致性的场景。</p><p>当然，也可以根据请求中的其他参数进行 Hash，比如根据请求接口的地址路由到不同的服务器节点。</p><p>下面是一个很重要的分布式知识点：一致性 Hash。</p><h3 id="一致性-Hash"><a href="#一致性-Hash" class="headerlink" title="一致性 Hash"></a>一致性 Hash</h3><p>一致性哈希（Consistent Hashing）是一种经典的哈希算法，用于将请求分配到多个节点或服务器上，所以非常适用于负载均衡。</p><p>它的核心思想是将整个哈希值空间划分成一个环状结构，每个节点或服务器在环上占据一个位置，每个请求根据其哈希值映射到环上的一个点，然后顺时针寻找第一个大于或等于该哈希值的节点，将请求路由到该节点上。</p><p>一致性哈希环结构如图：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/03/10/67cee9cd3536b.jpeg"></p><p>上图中，请求 A 会交给服务器 C 来处理。</p><p>一致性哈希还解决了 <strong>节点下线</strong> 和 <strong>倾斜问题</strong>。</p><p>1）节点下线：当某个节点下线时，其负载会被平均分摊到其他节点上，而不会影响到整个系统的稳定性，因为只有部分请求会受到影响。</p><p>如下图，服务器 C 下线后，请求 A 会交给服务器 A 来处理（顺时针寻找第一个大于或等于该哈希值的节点），而服务器 B 接收到的请求保持不变。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/03/10/67cee9e95e6db.jpeg"></p><p>如果是轮询取模算法，只要节点数变了，很有可能大多数服务器处理的请求都要发生变化，对系统的影响巨大。</p><p>2）倾斜问题：通过虚拟节点的引入，将每个物理节点映射到多个虚拟节点上，使得节点在哈希环上的 <strong>分布更加均匀</strong>，减少了节点间的负载差异。</p><p>举个例子，节点很少的情况下，环的情况可能如下图：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/03/10/67cee9f758b28.jpeg"></p><p>这样就会导致绝大多数的请求都会发给服务器 C，而服务器 A 的 “领地” 非常少，几乎不会有请求。</p><p>引入虚拟节点后，环的情况变为：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/03/10/67ceea072eb64.jpeg"></p><p>这样一来，每个服务器接受到的请求会更容易平均。</p><h2 id="三、开发实现"><a href="#三、开发实现" class="headerlink" title="三、开发实现"></a>三、开发实现</h2><h3 id="1、多种负载均衡器实现"><a href="#1、多种负载均衡器实现" class="headerlink" title="1、多种负载均衡器实现"></a>1、多种负载均衡器实现</h3><p>学习负载均衡的时候，可以参考 Nginx 的负载均衡算法实现，此处实现轮询、随机、一致性 Hash 三种负载均衡算法。</p><p>在 RPC 项目中新建 <code>loadbalancer</code> 包，将所有负载均衡器相关的代码放到该包下。</p><p>1）先编写负载均衡器通用接口。提供一个选择服务方法，接受请求参数和可用服务列表，可以根据这些信息进行选择。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 负载均衡器（消费端使用）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LoadBalancer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 选择服务调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> requestParams       请求参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceMetaInfoList 可用服务列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ServiceMetaInfo <span class="title function_">select</span><span class="params">(Map&lt;String, Object&gt; requestParams, List&lt;ServiceMetaInfo&gt; serviceMetaInfoList)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）轮询负载均衡器。</p><p>使用 JUC 包的 <code>AtomicInteger</code> 实现原子计数器，防止并发冲突问题。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 轮询负载均衡器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RoundRobinLoadBalancer</span> <span class="keyword">implements</span> <span class="title class_">LoadBalancer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前轮询的下标</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">currentIndex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ServiceMetaInfo <span class="title function_">select</span><span class="params">(Map&lt;String, Object&gt; requestParams, List&lt;ServiceMetaInfo&gt; serviceMetaInfoList)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (serviceMetaInfoList.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只有一个服务，无需轮询</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> serviceMetaInfoList.size();</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> serviceMetaInfoList.get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 取模算法轮询</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> currentIndex.getAndIncrement() % size;</span><br><span class="line">        <span class="keyword">return</span> serviceMetaInfoList.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）随机负载均衡器。</p><p>使用 Java 自带的 Random 类实现随机选取即可，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 随机负载均衡器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomLoadBalancer</span> <span class="keyword">implements</span> <span class="title class_">LoadBalancer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ServiceMetaInfo <span class="title function_">select</span><span class="params">(Map&lt;String, Object&gt; requestParams, List&lt;ServiceMetaInfo&gt; serviceMetaInfoList)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> serviceMetaInfoList.size();</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只有 1 个服务，不用随机</span></span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> serviceMetaInfoList.get(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> serviceMetaInfoList.get(random.nextInt(size));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4）实现一致性 Hash 负载均衡器。</p><p>可以使用 TreeMap 实现一致性 Hash 环，该数据结构提供了 ceilingEntry 和 firstEntry 两个方法，便于获取符合算法要求的节点。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一致性哈希负载均衡器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConsistentHashLoadBalancer</span> <span class="keyword">implements</span> <span class="title class_">LoadBalancer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 一致性 Hash 环，存放虚拟节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TreeMap&lt;Integer, ServiceMetaInfo&gt; virtualNodes = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 虚拟节点数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">VIRTUAL_NODE_NUM</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ServiceMetaInfo <span class="title function_">select</span><span class="params">(Map&lt;String, Object&gt; requestParams, List&lt;ServiceMetaInfo&gt; serviceMetaInfoList)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (serviceMetaInfoList.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建虚拟节点环</span></span><br><span class="line">        <span class="keyword">for</span> (ServiceMetaInfo serviceMetaInfo : serviceMetaInfoList) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; VIRTUAL_NODE_NUM; i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> getHash(serviceMetaInfo.getServiceAddress() + <span class="string">&quot;#&quot;</span> + i);</span><br><span class="line">                virtualNodes.put(hash, serviceMetaInfo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取调用请求的 hash 值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">hash</span> <span class="operator">=</span> getHash(requestParams);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选择最接近且大于等于调用请求 hash 值的虚拟节点</span></span><br><span class="line">        Map.Entry&lt;Integer, ServiceMetaInfo&gt; entry = virtualNodes.ceilingEntry(hash);</span><br><span class="line">        <span class="keyword">if</span> (entry == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果没有大于等于调用请求 hash 值的虚拟节点，则返回环首部的节点</span></span><br><span class="line">            entry = virtualNodes.firstEntry();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> entry.getValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Hash 算法，可自行实现</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getHash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> key.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，注意两点：</p><ol><li>根据 requestParams 对象计算 Hash 值，这里只是简单地调用了对象的 hashCode 方法，也可以根据需求实现自己的 Hash 算法。</li><li>每次调用负载均衡器时，都会重新构造 Hash 环，这是为了能够即时处理节点的变化。</li></ol><h3 id="2、支持配置和扩展负载均衡器"><a href="#2、支持配置和扩展负载均衡器" class="headerlink" title="2、支持配置和扩展负载均衡器"></a>2、支持配置和扩展负载均衡器</h3><p>一个成熟的 RPC 框架可能会支持多个负载均衡器，像序列化器和注册中心一样，我们的需求是，让开发者能够填写配置来指定使用的负载均衡器，并且支持自定义负载均衡器，让框架更易用、更利于扩展。</p><p>要实现这点，开发方式和序列化器、注册中心都是一样的，都可以使用工厂创建对象、使用 SPI 动态加载自定义的注册中心。</p><p>1）负载均衡器常量。</p><p>在 loadbalancer 包下新建 <code>LoadBalancerKeys</code> 类，列举所有支持的负载均衡器键名。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 负载均衡器键名常量</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href=&quot;https://github.com/liyupi&quot;&gt;程序员鱼皮&lt;/a&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@learn</span> &lt;a href=&quot;https://codefather.cn&quot;&gt;鱼皮的编程宝典&lt;/a&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@from</span> &lt;a href=&quot;https://yupi.icu&quot;&gt;编程导航学习圈&lt;/a&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">LoadBalancerKeys</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 轮询</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">ROUND_ROBIN</span> <span class="operator">=</span> <span class="string">&quot;roundRobin&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">RANDOM</span> <span class="operator">=</span> <span class="string">&quot;random&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">CONSISTENT_HASH</span> <span class="operator">=</span> <span class="string">&quot;consistentHash&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）使用工厂模式，支持根据 key 从 SPI 获取负载均衡器对象实例。</p><p>在 loadbalancer 包下新建 <code>LoadBalancerFactory</code> 类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 负载均衡器工厂（工厂模式，用于获取负载均衡器对象）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href=&quot;https://github.com/liyupi&quot;&gt;程序员鱼皮&lt;/a&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@learn</span> &lt;a href=&quot;https://codefather.cn&quot;&gt;编程宝典&lt;/a&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@from</span> &lt;a href=&quot;https://yupi.icu&quot;&gt;编程导航知识星球&lt;/a&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoadBalancerFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        SpiLoader.load(LoadBalancer.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认负载均衡器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">LoadBalancer</span> <span class="variable">DEFAULT_LOAD_BALANCER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RoundRobinLoadBalancer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取实例</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LoadBalancer <span class="title function_">getInstance</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SpiLoader.getInstance(LoadBalancer.class, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类可以直接复制之前的 SerializerFactory，然后略做修改。可以发现，只要跑通了一次 SPI 机制，后续的开发就很简单了~</p><p>3）在 <code>META-INF</code> 的 <code>rpc/system</code> 目录下编写负载均衡器接口的 SPI 配置文件，文件名称为 <code>com.yupi.yurpc.loadbalancer.LoadBalancer</code>。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">roundRobin=com.yupi.yurpc.loadbalancer.RoundRobinLoadBalancer</span><br><span class="line">random=com.yupi.yurpc.loadbalancer.RandomLoadBalancer</span><br><span class="line">consistentHash=com.yupi.yurpc.loadbalancer.ConsistentHashLoadBalancer</span><br></pre></td></tr></table></figure><p>4）为 RpcConfig 全局配置新增负载均衡器的配置，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcConfig</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 负载均衡器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">loadBalancer</span> <span class="operator">=</span> LoadBalancerKeys.ROUND_ROBIN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、应用负载均衡器"><a href="#3、应用负载均衡器" class="headerlink" title="3、应用负载均衡器"></a>3、应用负载均衡器</h3><p>现在，我们就能使用负载均衡器了。修改 ServiceProxy 的代码，将 “固定调用第一个服务节点” 改为 “调用负载均衡器获取一个服务节点”。</p><p>修改后的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用代理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 指定序列化器</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Serializer</span> <span class="variable">serializer</span> <span class="operator">=</span> SerializerFactory.getInstance(RpcApplication.getRpcConfig().getSerializer());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造请求</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> method.getDeclaringClass().getName();</span><br><span class="line">        <span class="type">RpcRequest</span> <span class="variable">rpcRequest</span> <span class="operator">=</span> RpcRequest.builder()</span><br><span class="line">                .serviceName(serviceName)</span><br><span class="line">                .methodName(method.getName())</span><br><span class="line">                .parameterTypes(method.getParameterTypes())</span><br><span class="line">                .args(args)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 从注册中心获取服务提供者请求地址</span></span><br><span class="line">            <span class="type">RpcConfig</span> <span class="variable">rpcConfig</span> <span class="operator">=</span> RpcApplication.getRpcConfig();</span><br><span class="line">            <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> RegistryFactory.getInstance(rpcConfig.getRegistryConfig().getRegistry());</span><br><span class="line">            <span class="type">ServiceMetaInfo</span> <span class="variable">serviceMetaInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceMetaInfo</span>();</span><br><span class="line">            serviceMetaInfo.setServiceName(serviceName);</span><br><span class="line">            serviceMetaInfo.setServiceVersion(RpcConstant.DEFAULT_SERVICE_VERSION);</span><br><span class="line">            List&lt;ServiceMetaInfo&gt; serviceMetaInfoList = registry.serviceDiscovery(serviceMetaInfo.getServiceKey());</span><br><span class="line">            <span class="keyword">if</span> (CollUtil.isEmpty(serviceMetaInfoList)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;暂无服务地址&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 负载均衡</span></span><br><span class="line">            <span class="type">LoadBalancer</span> <span class="variable">loadBalancer</span> <span class="operator">=</span> LoadBalancerFactory.getInstance(rpcConfig.getLoadBalancer());</span><br><span class="line">            <span class="comment">// 将调用方法名（请求路径）作为负载均衡参数</span></span><br><span class="line">            Map&lt;String, Object&gt; requestParams = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            requestParams.put(<span class="string">&quot;methodName&quot;</span>, rpcRequest.getMethodName());</span><br><span class="line">            <span class="type">ServiceMetaInfo</span> <span class="variable">selectedServiceMetaInfo</span> <span class="operator">=</span> loadBalancer.select(requestParams, serviceMetaInfoList);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// rpc 请求</span></span><br><span class="line">            <span class="type">RpcResponse</span> <span class="variable">rpcResponse</span> <span class="operator">=</span> VertxTcpClient.doRequest(rpcRequest, selectedServiceMetaInfo);</span><br><span class="line">            <span class="keyword">return</span> rpcResponse.getData();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;调用失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，给负载均衡器传入了一个 requestParams HashMap，并且将请求方法名作为参数放到了 Map 中。如果使用的是一致性 Hash 算法，那么会根据 requestParams 计算 Hash 值，调用相同方法的请求 Hash 值肯定相同，所以总会请求到同一个服务器节点上。</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RPC框架开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPC开发7_自定义协议</title>
      <link href="/2025/01/17/RPC%E5%BC%80%E5%8F%917_%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE/"/>
      <url>/2025/01/17/RPC%E5%BC%80%E5%8F%917_%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="一、需求分析"><a href="#一、需求分析" class="headerlink" title="一、需求分析"></a>一、需求分析</h2><p>目前的 RPC 框架，我们使用 Vert.x 的 HttpServer 作为服务提供者的服务器，代码实现比较简单，其底层网络传输使用的是 HTTP 协议。</p><p>问题来了，使用 HTTP 协议会有什么问题么？或者说，有没有更好的选择？</p><p>一般情况下，RPC 框架会比较注重性能，而 HTTP 协议中的头部信息、请求响应格式较 “重”，会影响网络传输性能。</p><p>举个例子，利用浏览器网络控制台随便查看一个请求，能看到大量的请求和响应标头。</p><p>所以，我们需要自己自定义一套 RPC 协议，比如利用 TCP 等传输层协议、自己定义请求响应结构，来实现性能更高、更灵活、更安全的 RPC 框架。</p><p>本节会自定义 RPC 协议，巩固计算机网络知识，并提升自己的系统设计能力。</p><h2 id="二、设计方案"><a href="#二、设计方案" class="headerlink" title="二、设计方案"></a>二、设计方案</h2><p>自定义 RPC 协议可以分为 2 大核心部分：</p><ul><li>自定义网络传输</li><li>自定义消息结构</li></ul><h3 id="1、网络传输设计"><a href="#1、网络传输设计" class="headerlink" title="1、网络传输设计"></a>1、网络传输设计</h3><p>网络传输设计的目标是：选择一个能够高性能通信的网络协议和传输方式。</p><p>需求分析中已经提到了，HTTP 协议的头信息是比较大的，会影响传输性能。但其实除了这点外，HTTP 本身属于无状态协议，这意味着每个 HTTP 请求都是独立的，每次请求 &#x2F; 响应都要重新建立和关闭连接，也会影响性能。</p><p>考虑到这点，在 HTTP&#x2F;1.1 中引入了持久连接（Keep-Alive），允许在单个 TCP 连接上发送多个 HTTP 请求和响应，避免了每次请求都要重新建立和关闭连接的开销。</p><p>虽然如此，HTTP 本身是应用层协议，我们现在设计的 RPC 协议也是应用层协议，性能肯定是不如底层（传输层）的 TCP 协议要高的。所以我们想要追求更高的性能，还是选择使用 TCP 协议完成网络传输，有更多的自主设计空间。</p><h3 id="2、消息结构设计"><a href="#2、消息结构设计" class="headerlink" title="2、消息结构设计"></a>2、消息结构设计</h3><p>消息结构设计的目标是：用 <strong>最少的</strong> 空间传递 <strong>需要的</strong> 信息。</p><p>1）如何使用最少的空间呢？</p><p>之前接触到的数据类型可能都是整型、长整型、浮点数类型等等，这些类型其实都比较 “重”，占用的字节数较多。比如整型要占用 4 个字节、32 个 bit 位。</p><p>我们在自定义消息结构时，想要节省空间，就要尽可能使用更轻量的类型，比如 byte 字节类型，只占用 1 个字节、8 个 bit 位。</p><p>需要注意的是，Java 中实现 bit 位运算拼接相对比较麻烦，所以权衡开发成本，我们设计消息结构时，尽量给每个数据凑到整个字节。</p><p>2）消息内需要哪些信息呢？</p><p>目标肯定是能够完成请求嘛，那我们何不从之前的 HTTP 请求方式中，找到一些线索？</p><p>分析 HTTP 请求结构，我们能够得到 RPC 消息所需的信息：</p><ul><li>魔数：作用是安全校验，防止服务器处理了非框架发来的乱七八糟的消息（类似 HTTPS 的安全证书）</li><li>版本号：保证请求和响应的一致性（类似 HTTP 协议有 1.0&#x2F;2.0 等版本）</li><li>序列化方式：来告诉服务端和客户端如何解析数据（类似 HTTP 的 Content-Type 内容类型）</li><li>类型：标识是请求还是响应？或者是心跳检测等其他用途。（类似 HTTP 有请求头和响应头）</li><li>状态：如果是响应，记录响应的结果（类似 HTTP 的 200 状态代码）</li></ul><p>此外，还需要有请求 id，唯一标识某个请求，因为 TCP 是双向通信的，需要有个唯一标识来追踪每个请求。</p><p>最后，也是最重要的，要发送 body 内容数据。我们暂时称它为 <strong>请求体</strong>，类似于我们之前 HTTP 请求中发送的 RpcRequest。</p><p>如果是 HTTP 这种协议，有专门的 key &#x2F; value 结构，很容易找到完整的 body 数据。但基于 TCP 协议，想要获取到完整的 body 内容数据，就需要一些 “小心思” 了，因为 TCP 协议本身会存在半包和粘包问题，每次传输的数据可能是不完整的，具体的后面会讲。</p><p>所以我们需要在消息头中新增一个字段 <code>请求体数据长度</code>，保证能够完整地获取 body 内容信息。</p><p>基于以上的思考，我们可以得到最终的消息结构设计，如下图：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/03/10/67cee75b81fb3.png"></p><p>实际上，这些数据应该是紧凑的，请求头信息总长 17 个字节。也就是说，上述消息结构，本质上就是拼接在一起的一个字节数组。我们后续实现时，需要有 <strong>消息编码器</strong> 和 <strong>消息解码器</strong>，编码器先 new 一个空的 Buffer 缓冲区，然后按照顺序向缓冲区依次写入这些数据；解码器在读取时也按照顺序依次读取，就能还原出编码前的数据。</p><p>通过这种约定的方式，我们就不用记录头信息了。比如 magic 魔数，不用存储 “magic” 这个字符串，而是读取第一个字节（前 8 bit）就能获取到。</p><p>Redis 底层很多数据结构都是这种设计。</p><p>明确了设计后，我们来开发实现，就比较简单了。</p><h2 id="三、开发实现"><a href="#三、开发实现" class="headerlink" title="三、开发实现"></a>三、开发实现</h2><h3 id="1、消息结构"><a href="#1、消息结构" class="headerlink" title="1、消息结构"></a>1、消息结构</h3><p>新建 <code>protocol</code> 包，将所有和自定义协议有关的代码都放到该包下。</p><p>1）新建协议消息类 <code>ProtocolMessage</code>。</p><p>将消息头单独封装为一个内部类，消息体可以使用泛型类型，完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 协议消息结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProtocolMessage</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息头</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Header header;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息体（请求或响应对象）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T body;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 协议消息头</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Header</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 魔数，保证安全性</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">byte</span> magic;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 版本号</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">byte</span> version;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 序列化器</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">byte</span> serializer;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 消息类型（请求 / 响应）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">byte</span> type;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 状态</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">byte</span> status;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 请求 id</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">long</span> requestId;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 消息体长度</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> bodyLength;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）新建协议常量类 <code>ProtocolConstant</code>。</p><p>记录了和自定义协议有关的关键信息，比如消息头长度、魔数、版本号。</p><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yupi.yurpc.protocol;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 协议常量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ProtocolConstant</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息头长度</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">MESSAGE_HEADER_LENGTH</span> <span class="operator">=</span> <span class="number">17</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 协议魔数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">byte</span> <span class="variable">PROTOCOL_MAGIC</span> <span class="operator">=</span> <span class="number">0x1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 协议版本号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">byte</span> <span class="variable">PROTOCOL_VERSION</span> <span class="operator">=</span> <span class="number">0x1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）新建消息字段的枚举类，比如：</p><p>协议状态枚举，暂时只定义成功、请求失败、响应失败三种枚举值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 协议消息的状态枚举</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ProtocolMessageStatusEnum</span> &#123;</span><br><span class="line"></span><br><span class="line">    OK(<span class="string">&quot;ok&quot;</span>, <span class="number">20</span>),</span><br><span class="line">    BAD_REQUEST(<span class="string">&quot;badRequest&quot;</span>, <span class="number">40</span>),</span><br><span class="line">    BAD_RESPONSE(<span class="string">&quot;badResponse&quot;</span>, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String text;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    ProtocolMessageStatusEnum(String text, <span class="type">int</span> value) &#123;</span><br><span class="line">        <span class="built_in">this</span>.text = text;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 value 获取枚举</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ProtocolMessageStatusEnum <span class="title function_">getEnumByValue</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (ProtocolMessageStatusEnum anEnum : ProtocolMessageStatusEnum.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (anEnum.value == value) &#123;</span><br><span class="line">                <span class="keyword">return</span> anEnum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>协议消息类型枚举，包括请求、响应、心跳、其他。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 协议消息的类型枚举</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href=&quot;https://github.com/liyupi&quot;&gt;程序员鱼皮&lt;/a&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@from</span> &lt;a href=&quot;https://yupi.icu&quot;&gt;编程导航学习圈&lt;/a&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@learn</span> &lt;a href=&quot;https://codefather.cn&quot;&gt;鱼皮的编程宝典&lt;/a&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ProtocolMessageTypeEnum</span> &#123;</span><br><span class="line"></span><br><span class="line">    REQUEST(<span class="number">0</span>),</span><br><span class="line">    RESPONSE(<span class="number">1</span>),</span><br><span class="line">    HEART_BEAT(<span class="number">2</span>),</span><br><span class="line">    OTHERS(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> key;</span><br><span class="line"></span><br><span class="line">    ProtocolMessageTypeEnum(<span class="type">int</span> key) &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 key 获取枚举</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ProtocolMessageTypeEnum <span class="title function_">getEnumByKey</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (ProtocolMessageTypeEnum anEnum : ProtocolMessageTypeEnum.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (anEnum.key == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> anEnum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>协议消息的序列化器枚举，跟 RPC 框架已支持的序列化器对应。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 协议消息的序列化器枚举</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">ProtocolMessageSerializerEnum</span> &#123;</span><br><span class="line"></span><br><span class="line">    JDK(<span class="number">0</span>, <span class="string">&quot;jdk&quot;</span>),</span><br><span class="line">    JSON(<span class="number">1</span>, <span class="string">&quot;json&quot;</span>),</span><br><span class="line">    KRYO(<span class="number">2</span>, <span class="string">&quot;kryo&quot;</span>),</span><br><span class="line">    HESSIAN(<span class="number">3</span>, <span class="string">&quot;hessian&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String value;</span><br><span class="line"></span><br><span class="line">    ProtocolMessageSerializerEnum(<span class="type">int</span> key, String value) &#123;</span><br><span class="line">        <span class="built_in">this</span>.key = key;</span><br><span class="line">        <span class="built_in">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取值列表</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">getValues</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(values()).map(item -&gt; item.value).collect(Collectors.toList());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 key 获取枚举</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ProtocolMessageSerializerEnum <span class="title function_">getEnumByKey</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (ProtocolMessageSerializerEnum anEnum : ProtocolMessageSerializerEnum.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (anEnum.key == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> anEnum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据 value 获取枚举</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ProtocolMessageSerializerEnum <span class="title function_">getEnumByValue</span><span class="params">(String value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ObjectUtil.isEmpty(value)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (ProtocolMessageSerializerEnum anEnum : ProtocolMessageSerializerEnum.values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (anEnum.value.equals(value)) &#123;</span><br><span class="line">                <span class="keyword">return</span> anEnum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、网络传输"><a href="#2、网络传输" class="headerlink" title="2、网络传输"></a>2、网络传输</h3><p>RPC 框架使用了高性能的 Vert.x 作为网络传输服务器，之前用的是 HttpServer。同样，Vert.x 也支持 TCP 服务器，相比于 Netty 或者自己写 Socket 代码，更加简单易用。</p><p>首先新建 <code>server.tcp</code> 包，将所有 TCP 服务相关的代码放到该包中。</p><p>1）TCP 服务器实现。</p><p>新建 <code>VertxTcpServer</code> 类，跟之前写的 <code>VertxHttpServer</code> 类似，先创建 Vert.x 的服务器实例，然后定义处理请求的方法，比如回复 “Hello, client!”，最后启动服务器。</p><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VertxTcpServer</span> <span class="keyword">implements</span> <span class="title class_">HttpServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] handleRequest(<span class="type">byte</span>[] requestData) &#123;</span><br><span class="line">        <span class="comment">// 在这里编写处理请求的逻辑，根据 requestData 构造响应数据并返回</span></span><br><span class="line">        <span class="comment">// 这里只是一个示例，实际逻辑需要根据具体的业务需求来实现</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, client!&quot;</span>.getBytes();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doStart</span><span class="params">(<span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 Vert.x 实例</span></span><br><span class="line">        <span class="type">Vertx</span> <span class="variable">vertx</span> <span class="operator">=</span> Vertx.vertx();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 TCP 服务器</span></span><br><span class="line">        <span class="type">NetServer</span> <span class="variable">server</span> <span class="operator">=</span> vertx.createNetServer();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理请求</span></span><br><span class="line">        server.connectHandler(socket -&gt; &#123;</span><br><span class="line">            <span class="comment">// 处理连接</span></span><br><span class="line">            socket.handler(buffer -&gt; &#123;</span><br><span class="line">                <span class="comment">// 处理接收到的字节数组</span></span><br><span class="line">                <span class="type">byte</span>[] requestData = buffer.getBytes();</span><br><span class="line">                <span class="comment">// 在这里进行自定义的字节数组处理逻辑，比如解析请求、调用服务、构造响应等</span></span><br><span class="line">                <span class="type">byte</span>[] responseData = handleRequest(requestData);</span><br><span class="line">                <span class="comment">// 发送响应</span></span><br><span class="line">                socket.write(Buffer.buffer(responseData));</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动 TCP 服务器并监听指定端口</span></span><br><span class="line">        server.listen(port, result -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (result.succeeded()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;TCP server started on port &quot;</span> + port);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;Failed to start TCP server: &quot;</span> + result.cause());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">VertxTcpServer</span>().doStart(<span class="number">8888</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中的 <code>socket.write</code> 方法，就是在向连接到服务器的客户端发送数据。注意发送的数据格式为 Buffer，这是 Vert.x 为我们提供的字节数组缓冲区实现。</p><p>2）TCP 客户端实现。</p><p>新建 <code>VertxTcpClient</code> 类，先创建 Vert.x 的客户端实例，然后定义处理请求的方法，比如回复 “Hello, server!”，并建立连接。</p><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VertxTcpClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 Vert.x 实例</span></span><br><span class="line">        <span class="type">Vertx</span> <span class="variable">vertx</span> <span class="operator">=</span> Vertx.vertx();</span><br><span class="line"></span><br><span class="line">        vertx.createNetClient().connect(<span class="number">8888</span>, <span class="string">&quot;localhost&quot;</span>, result -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (result.succeeded()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Connected to TCP server&quot;</span>);</span><br><span class="line">                io.vertx.core.net.<span class="type">NetSocket</span> <span class="variable">socket</span> <span class="operator">=</span> result.result();</span><br><span class="line">                <span class="comment">// 发送数据</span></span><br><span class="line">                socket.write(<span class="string">&quot;Hello, server!&quot;</span>);</span><br><span class="line">                <span class="comment">// 接收响应</span></span><br><span class="line">                socket.handler(buffer -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Received response from server: &quot;</span> + buffer.toString());</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;Failed to connect to TCP server&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">VertxTcpClient</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、编码-解码器"><a href="#3、编码-解码器" class="headerlink" title="3、编码 &#x2F; 解码器"></a>3、编码 &#x2F; 解码器</h3><p>在上一步中，我们也注意到了，Vert.x 的 TCP 服务器收发的消息是 Buffer 类型，不能直接写入一个对象。因此，我们需要编码器和解码器，将 Java 的消息对象和 Buffer 进行相互转换。</p><p>下图演示了整个请求和响应的过程，可以了解编码器和解码器的作用。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/03/10/67cee7f94a44d.jpeg"></p><p>之前 HTTP 请求和响应时，直接从请求 body 处理器中获取到 body 字节数组，再通过序列化（反序列化）得到 RpcRequest 或 RpcResponse 对象。使用 TCP 服务器后，只不过改为从 Buffer 中获取字节数组，然后编解码为 RpcRequest 或 RpcResponse 对象。其他的后续处理流程都是可复用的。</p><p>1）首先实现消息编码器。</p><p>在 protocol 包下新建 <code>ProtocolMessageEncoder</code>，核心流程是依次向 Buffer 缓冲区写入消息对象里的字段。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProtocolMessageEncoder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编码</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> protocolMessage</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Buffer <span class="title function_">encode</span><span class="params">(ProtocolMessage&lt;?&gt; protocolMessage)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (protocolMessage == <span class="literal">null</span> || protocolMessage.getHeader() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Buffer.buffer();</span><br><span class="line">        &#125;</span><br><span class="line">        ProtocolMessage.<span class="type">Header</span> <span class="variable">header</span> <span class="operator">=</span> protocolMessage.getHeader();</span><br><span class="line">        <span class="comment">// 依次向缓冲区写入字节</span></span><br><span class="line">        <span class="type">Buffer</span> <span class="variable">buffer</span> <span class="operator">=</span> Buffer.buffer();</span><br><span class="line">        buffer.appendByte(header.getMagic());</span><br><span class="line">        buffer.appendByte(header.getVersion());</span><br><span class="line">        buffer.appendByte(header.getSerializer());</span><br><span class="line">        buffer.appendByte(header.getType());</span><br><span class="line">        buffer.appendByte(header.getStatus());</span><br><span class="line">        buffer.appendLong(header.getRequestId());</span><br><span class="line">        <span class="comment">// 获取序列化器</span></span><br><span class="line">        <span class="type">ProtocolMessageSerializerEnum</span> <span class="variable">serializerEnum</span> <span class="operator">=</span> ProtocolMessageSerializerEnum.getEnumByKey(header.getSerializer());</span><br><span class="line">        <span class="keyword">if</span> (serializerEnum == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;序列化协议不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Serializer</span> <span class="variable">serializer</span> <span class="operator">=</span> SerializerFactory.getInstance(serializerEnum.getValue());</span><br><span class="line">        <span class="type">byte</span>[] bodyBytes = serializer.serialize(protocolMessage.getBody());</span><br><span class="line">        <span class="comment">// 写入 body 长度和数据</span></span><br><span class="line">        buffer.appendInt(bodyBytes.length);</span><br><span class="line">        buffer.appendBytes(bodyBytes);</span><br><span class="line">        <span class="keyword">return</span> buffer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）实现消息解码器。</p><p>在 protocol 包下新建 <code>ProtocolMessageDecoder</code>，核心流程是依次从 Buffer 缓冲区的指定位置读取字段，构造出完整的消息对象。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 协议消息解码器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProtocolMessageDecoder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解码</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> buffer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ProtocolMessage&lt;?&gt; decode(Buffer buffer) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 分别从指定位置读出 Buffer</span></span><br><span class="line">        ProtocolMessage.<span class="type">Header</span> <span class="variable">header</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProtocolMessage</span>.Header();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">magic</span> <span class="operator">=</span> buffer.getByte(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 校验魔数</span></span><br><span class="line">        <span class="keyword">if</span> (magic != ProtocolConstant.PROTOCOL_MAGIC) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;消息 magic 非法&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        header.setMagic(magic);</span><br><span class="line">        header.setVersion(buffer.getByte(<span class="number">1</span>));</span><br><span class="line">        header.setSerializer(buffer.getByte(<span class="number">2</span>));</span><br><span class="line">        header.setType(buffer.getByte(<span class="number">3</span>));</span><br><span class="line">        header.setStatus(buffer.getByte(<span class="number">4</span>));</span><br><span class="line">        header.setRequestId(buffer.getLong(<span class="number">5</span>));</span><br><span class="line">        header.setBodyLength(buffer.getInt(<span class="number">13</span>));</span><br><span class="line">        <span class="comment">// 解决粘包问题，只读指定长度的数据</span></span><br><span class="line">        <span class="type">byte</span>[] bodyBytes = buffer.getBytes(<span class="number">17</span>, <span class="number">17</span> + header.getBodyLength());</span><br><span class="line">        <span class="comment">// 解析消息体</span></span><br><span class="line">        <span class="type">ProtocolMessageSerializerEnum</span> <span class="variable">serializerEnum</span> <span class="operator">=</span> ProtocolMessageSerializerEnum.getEnumByKey(header.getSerializer());</span><br><span class="line">        <span class="keyword">if</span> (serializerEnum == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;序列化消息的协议不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Serializer</span> <span class="variable">serializer</span> <span class="operator">=</span> SerializerFactory.getInstance(serializerEnum.getValue());</span><br><span class="line">        <span class="type">ProtocolMessageTypeEnum</span> <span class="variable">messageTypeEnum</span> <span class="operator">=</span> ProtocolMessageTypeEnum.getEnumByKey(header.getType());</span><br><span class="line">        <span class="keyword">if</span> (messageTypeEnum == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;序列化消息的类型不存在&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (messageTypeEnum) &#123;</span><br><span class="line">            <span class="keyword">case</span> REQUEST:</span><br><span class="line">                <span class="type">RpcRequest</span> <span class="variable">request</span> <span class="operator">=</span> serializer.deserialize(bodyBytes, RpcRequest.class);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProtocolMessage</span>&lt;&gt;(header, request);</span><br><span class="line">            <span class="keyword">case</span> RESPONSE:</span><br><span class="line">                <span class="type">RpcResponse</span> <span class="variable">response</span> <span class="operator">=</span> serializer.deserialize(bodyBytes, RpcResponse.class);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ProtocolMessage</span>&lt;&gt;(header, response);</span><br><span class="line">            <span class="keyword">case</span> HEART_BEAT:</span><br><span class="line">            <span class="keyword">case</span> OTHERS:</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;暂不支持该消息类型&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）编写单元测试类，先编码再解码，以测试编码器和解码器的正确性。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProtocolMessageTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testEncodeAndDecode</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 构造消息</span></span><br><span class="line">        ProtocolMessage&lt;RpcRequest&gt; protocolMessage = <span class="keyword">new</span> <span class="title class_">ProtocolMessage</span>&lt;&gt;();</span><br><span class="line">        ProtocolMessage.<span class="type">Header</span> <span class="variable">header</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProtocolMessage</span>.Header();</span><br><span class="line">        header.setMagic(ProtocolConstant.PROTOCOL_MAGIC);</span><br><span class="line">        header.setVersion(ProtocolConstant.PROTOCOL_VERSION);</span><br><span class="line">        header.setSerializer((<span class="type">byte</span>) ProtocolMessageSerializerEnum.JDK.getKey());</span><br><span class="line">        header.setType((<span class="type">byte</span>) ProtocolMessageTypeEnum.REQUEST.getKey());</span><br><span class="line">        header.setStatus((<span class="type">byte</span>) ProtocolMessageStatusEnum.OK.getValue());</span><br><span class="line">        header.setRequestId(IdUtil.getSnowflakeNextId());</span><br><span class="line">        header.setBodyLength(<span class="number">0</span>);</span><br><span class="line">        <span class="type">RpcRequest</span> <span class="variable">rpcRequest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RpcRequest</span>();</span><br><span class="line">        rpcRequest.setServiceName(<span class="string">&quot;myService&quot;</span>);</span><br><span class="line">        rpcRequest.setMethodName(<span class="string">&quot;myMethod&quot;</span>);</span><br><span class="line">        rpcRequest.setServiceVersion(RpcConstant.DEFAULT_SERVICE_VERSION);</span><br><span class="line">        rpcRequest.setParameterTypes(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;);</span><br><span class="line">        rpcRequest.setArgs(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;aaa&quot;</span>, <span class="string">&quot;bbb&quot;</span>&#125;);</span><br><span class="line">        protocolMessage.setHeader(header);</span><br><span class="line">        protocolMessage.setBody(rpcRequest);</span><br><span class="line"></span><br><span class="line">        <span class="type">Buffer</span> <span class="variable">encodeBuffer</span> <span class="operator">=</span> ProtocolMessageEncoder.encode(protocolMessage);</span><br><span class="line">        ProtocolMessage&lt;?&gt; message = ProtocolMessageDecoder.decode(encodeBuffer);</span><br><span class="line">        Assert.assertNotNull(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、请求处理器（服务提供者）"><a href="#4、请求处理器（服务提供者）" class="headerlink" title="4、请求处理器（服务提供者）"></a>4、请求处理器（服务提供者）</h3><p>可以使用 netty 的 pipeline 组合多个 handler（比如编码 &#x3D;&gt; 解码 &#x3D;&gt; 请求 &#x2F; 响应处理）</p><p>请求处理器的作用是接受请求，然后通过反射调用服务实现类。</p><p>类似之前的 HttpServerHandler，我们需要开发一个 TcpServerHandler，用于处理请求。和 HttpServerHandler 的区别只是在获取请求、写入响应的方式上，需要调用上面开发好的编码器和解码器。</p><p>通过实现 Vert.x 提供的 <code>Handler&lt;NetSocket&gt;</code> 接口，可以定义 TCP 请求处理器。</p><p>完整代码如下，大多数代码都是从之前写好的 HttpServerHandler 复制来的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TcpServerHandler</span> <span class="keyword">implements</span> <span class="title class_">Handler</span>&lt;NetSocket&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(NetSocket netSocket)</span> &#123;</span><br><span class="line">        <span class="comment">// 处理连接</span></span><br><span class="line">        netSocket.handler(buffer -&gt; &#123;</span><br><span class="line">            <span class="comment">// 接受请求，解码</span></span><br><span class="line">            ProtocolMessage&lt;RpcRequest&gt; protocolMessage;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                protocolMessage = (ProtocolMessage&lt;RpcRequest&gt;) ProtocolMessageDecoder.decode(buffer);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;协议消息解码错误&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">RpcRequest</span> <span class="variable">rpcRequest</span> <span class="operator">=</span> protocolMessage.getBody();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理请求</span></span><br><span class="line">            <span class="comment">// 构造响应结果对象</span></span><br><span class="line">            <span class="type">RpcResponse</span> <span class="variable">rpcResponse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RpcResponse</span>();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获取要调用的服务实现类，通过反射调用</span></span><br><span class="line">                Class&lt;?&gt; implClass = LocalRegistry.get(rpcRequest.getServiceName());</span><br><span class="line">                <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> implClass.getMethod(rpcRequest.getMethodName(), rpcRequest.getParameterTypes());</span><br><span class="line">                <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(implClass.newInstance(), rpcRequest.getArgs());</span><br><span class="line">                <span class="comment">// 封装返回结果</span></span><br><span class="line">                rpcResponse.setData(result);</span><br><span class="line">                rpcResponse.setDataType(method.getReturnType());</span><br><span class="line">                rpcResponse.setMessage(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                rpcResponse.setMessage(e.getMessage());</span><br><span class="line">                rpcResponse.setException(e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送响应，编码</span></span><br><span class="line">            ProtocolMessage.<span class="type">Header</span> <span class="variable">header</span> <span class="operator">=</span> protocolMessage.getHeader();</span><br><span class="line">            header.setType((<span class="type">byte</span>) ProtocolMessageTypeEnum.RESPONSE.getKey());</span><br><span class="line">            ProtocolMessage&lt;RpcResponse&gt; responseProtocolMessage = <span class="keyword">new</span> <span class="title class_">ProtocolMessage</span>&lt;&gt;(header, rpcResponse);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">Buffer</span> <span class="variable">encode</span> <span class="operator">=</span> ProtocolMessageEncoder.encode(responseProtocolMessage);</span><br><span class="line">                netSocket.write(encode);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;协议消息编码错误&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5、请求发送（服务消费者）"><a href="#5、请求发送（服务消费者）" class="headerlink" title="5、请求发送（服务消费者）"></a>5、请求发送（服务消费者）</h3><p>调整服务消费者发送请求的代码，改 HTTP 请求为 TCP 请求。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务代理（JDK 动态代理）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href=&quot;https://github.com/liyupi&quot;&gt;程序员鱼皮&lt;/a&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@learn</span> &lt;a href=&quot;https://codefather.cn&quot;&gt;编程宝典&lt;/a&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@from</span> &lt;a href=&quot;https://yupi.icu&quot;&gt;编程导航知识星球&lt;/a&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用代理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 指定序列化器</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Serializer</span> <span class="variable">serializer</span> <span class="operator">=</span> SerializerFactory.getInstance(RpcApplication.getRpcConfig().getSerializer());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造请求</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> method.getDeclaringClass().getName();</span><br><span class="line">        <span class="type">RpcRequest</span> <span class="variable">rpcRequest</span> <span class="operator">=</span> RpcRequest.builder()</span><br><span class="line">                .serviceName(serviceName)</span><br><span class="line">                .methodName(method.getName())</span><br><span class="line">                .parameterTypes(method.getParameterTypes())</span><br><span class="line">                .args(args)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 序列化</span></span><br><span class="line">            <span class="type">byte</span>[] bodyBytes = serializer.serialize(rpcRequest);</span><br><span class="line">            <span class="comment">// 从注册中心获取服务提供者请求地址</span></span><br><span class="line">            <span class="type">RpcConfig</span> <span class="variable">rpcConfig</span> <span class="operator">=</span> RpcApplication.getRpcConfig();</span><br><span class="line">            <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> RegistryFactory.getInstance(rpcConfig.getRegistryConfig().getRegistry());</span><br><span class="line">            <span class="type">ServiceMetaInfo</span> <span class="variable">serviceMetaInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceMetaInfo</span>();</span><br><span class="line">            serviceMetaInfo.setServiceName(serviceName);</span><br><span class="line">            serviceMetaInfo.setServiceVersion(RpcConstant.DEFAULT_SERVICE_VERSION);</span><br><span class="line">           List&lt;ServiceMetaInfo&gt; serviceMetaInfoList = registry.serviceDiscovery(serviceMetaInfo.getServiceKey());</span><br><span class="line">           <span class="keyword">if</span> (CollUtil.isEmpty(serviceMetaInfoList)) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;暂无服务地址&quot;</span>);</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="type">ServiceMetaInfo</span> <span class="variable">selectedServiceMetaInfo</span> <span class="operator">=</span> serviceMetaInfoList.get(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 发送 TCP 请求</span></span><br><span class="line">            <span class="type">Vertx</span> <span class="variable">vertx</span> <span class="operator">=</span> Vertx.vertx();</span><br><span class="line">            <span class="type">NetClient</span> <span class="variable">netClient</span> <span class="operator">=</span> vertx.createNetClient();</span><br><span class="line">            CompletableFuture&lt;RpcResponse&gt; responseFuture = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line">            netClient.connect(selectedServiceMetaInfo.getServicePort(), selectedServiceMetaInfo.getServiceHost(),</span><br><span class="line">                    result -&gt; &#123;</span><br><span class="line">                        <span class="keyword">if</span> (result.succeeded()) &#123;</span><br><span class="line">                            System.out.println(<span class="string">&quot;Connected to TCP server&quot;</span>);</span><br><span class="line">                            io.vertx.core.net.<span class="type">NetSocket</span> <span class="variable">socket</span> <span class="operator">=</span> result.result();</span><br><span class="line">                            <span class="comment">// 发送数据</span></span><br><span class="line">                            <span class="comment">// 构造消息</span></span><br><span class="line">                            ProtocolMessage&lt;RpcRequest&gt; protocolMessage = <span class="keyword">new</span> <span class="title class_">ProtocolMessage</span>&lt;&gt;();</span><br><span class="line">                            ProtocolMessage.<span class="type">Header</span> <span class="variable">header</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProtocolMessage</span>.Header();</span><br><span class="line">                            header.setMagic(ProtocolConstant.PROTOCOL_MAGIC);</span><br><span class="line">                            header.setVersion(ProtocolConstant.PROTOCOL_VERSION);</span><br><span class="line">                            header.setSerializer((<span class="type">byte</span>) ProtocolMessageSerializerEnum.getEnumByValue(RpcApplication.getRpcConfig().getSerializer()).getKey());</span><br><span class="line">                            header.setType((<span class="type">byte</span>) ProtocolMessageTypeEnum.REQUEST.getKey());</span><br><span class="line">                            header.setRequestId(IdUtil.getSnowflakeNextId());</span><br><span class="line">                            protocolMessage.setHeader(header);</span><br><span class="line">                            protocolMessage.setBody(rpcRequest);</span><br><span class="line">                            <span class="comment">// 编码请求</span></span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="type">Buffer</span> <span class="variable">encodeBuffer</span> <span class="operator">=</span> ProtocolMessageEncoder.encode(protocolMessage);</span><br><span class="line">                                socket.write(encodeBuffer);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;协议消息编码错误&quot;</span>);</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 接收响应</span></span><br><span class="line">                            socket.handler(buffer -&gt; &#123;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    ProtocolMessage&lt;RpcResponse&gt; rpcResponseProtocolMessage = (ProtocolMessage&lt;RpcResponse&gt;) ProtocolMessageDecoder.decode(buffer);</span><br><span class="line">                                    responseFuture.complete(rpcResponseProtocolMessage.getBody());</span><br><span class="line">                                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;协议消息解码错误&quot;</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            System.err.println(<span class="string">&quot;Failed to connect to TCP server&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="type">RpcResponse</span> <span class="variable">rpcResponse</span> <span class="operator">=</span> responseFuture.get();</span><br><span class="line">            <span class="comment">// 记得关闭连接</span></span><br><span class="line">            netClient.close();</span><br><span class="line">            <span class="keyword">return</span> rpcResponse.getData();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的代码看着比较复杂，但只需要关注上述代码中注释了 “发送 TCP 请求” 的部分即可。由于 Vert.x 提供的请求处理器是异步、反应式的，我们为了更方便地获取结果，可以使用 <code>CompletableFuture</code> 转异步为同步，参考代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CompletableFuture&lt;RpcResponse&gt; responseFuture = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line">netClient.connect(xxx,</span><br><span class="line">    result -&gt; &#123;</span><br><span class="line">        <span class="comment">// 完成了响应</span></span><br><span class="line">        responseFuture.complete(rpcResponseProtocolMessage.getBody());</span><br><span class="line">    &#125;);</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 阻塞，直到响应完成，才会继续向下执行</span></span><br><span class="line"><span class="type">RpcResponse</span> <span class="variable">rpcResponse</span> <span class="operator">=</span> responseFuture.get();</span><br></pre></td></tr></table></figure><h2 id="四、测试"><a href="#四、测试" class="headerlink" title="四、测试"></a>四、测试</h2><p>编写好上述代码后，就可以先测试请求响应流程是否跑通了。</p><p>修改服务提供者 <code>ProviderExample</code> 代码，改为启动 TCP 服务器。完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务提供者示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProviderExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// RPC 框架初始化</span></span><br><span class="line">        RpcApplication.init();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册服务</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> UserService.class.getName();</span><br><span class="line">        LocalRegistry.register(serviceName, UserServiceImpl.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注册服务到注册中心</span></span><br><span class="line">        <span class="type">RpcConfig</span> <span class="variable">rpcConfig</span> <span class="operator">=</span> RpcApplication.getRpcConfig();</span><br><span class="line">        <span class="type">RegistryConfig</span> <span class="variable">registryConfig</span> <span class="operator">=</span> rpcConfig.getRegistryConfig();</span><br><span class="line">        <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> RegistryFactory.getInstance(registryConfig.getRegistry());</span><br><span class="line">        <span class="type">ServiceMetaInfo</span> <span class="variable">serviceMetaInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceMetaInfo</span>();</span><br><span class="line">        serviceMetaInfo.setServiceName(serviceName);</span><br><span class="line">        serviceMetaInfo.setServiceHost(rpcConfig.getServerHost());</span><br><span class="line">        serviceMetaInfo.setServicePort(rpcConfig.getServerPort());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            registry.register(serviceMetaInfo);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动 TCP 服务</span></span><br><span class="line">        <span class="type">VertxTcpServer</span> <span class="variable">vertxTcpServer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VertxTcpServer</span>();</span><br><span class="line">        vertxTcpServer.doStart(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后启动消费者示例项目，应该能够正常完成调用。如果不能，那可能就是出现了粘包半包问题。</p><h2 id="五、粘包半包问题解决"><a href="#五、粘包半包问题解决" class="headerlink" title="五、粘包半包问题解决"></a>五、粘包半包问题解决</h2><h3 id="什么是粘包和半包？"><a href="#什么是粘包和半包？" class="headerlink" title="什么是粘包和半包？"></a>什么是粘包和半包？</h3><p>使用 TCP 协议网络通讯时，可能会出现半包和粘包问题。</p><p>举个例子。</p><p>理想情况下，假如我们客户端 <strong>连续 2 次</strong> 要发送的消息是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次</span></span><br><span class="line">Hello, server!Hello, server!Hello, server!Hello, server!</span><br><span class="line"><span class="comment">// 第二次</span></span><br><span class="line">Hello, server!Hello, server!Hello, server!Hello, server!</span><br></pre></td></tr></table></figure><p>但服务端收到的消息情况可能是：</p><p>1）每次收到的数据更少了，这种情况叫做 <code>半包</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次</span></span><br><span class="line">Hello, server!Hello, server!</span><br><span class="line"><span class="comment">// 第二次</span></span><br><span class="line">Hello, server!Hello, server!Hello, server!</span><br></pre></td></tr></table></figure><p>2）每次收到的数据更多了，这种情况叫做 <code>粘包</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第三次</span></span><br><span class="line">Hello, server!Hello, server!Hello, server!Hello, server!Hello, server!</span><br></pre></td></tr></table></figure><h3 id="半包粘包问题演示"><a href="#半包粘包问题演示" class="headerlink" title="半包粘包问题演示"></a>半包粘包问题演示</h3><p>为了更好地理解半包和粘包，可以编写代码来测试。</p><p>1）修改 TCP 客户端代码，连续发送 1000 次消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VertxTcpClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 Vert.x 实例</span></span><br><span class="line">        <span class="type">Vertx</span> <span class="variable">vertx</span> <span class="operator">=</span> Vertx.vertx();</span><br><span class="line"></span><br><span class="line">        vertx.createNetClient().connect(<span class="number">8888</span>, <span class="string">&quot;localhost&quot;</span>, result -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (result.succeeded()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Connected to TCP server&quot;</span>);</span><br><span class="line">                io.vertx.core.net.<span class="type">NetSocket</span> <span class="variable">socket</span> <span class="operator">=</span> result.result();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                    <span class="comment">// 发送数据</span></span><br><span class="line">                    socket.write(<span class="string">&quot;Hello, server!Hello, server!Hello, server!Hello, server!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 接收响应</span></span><br><span class="line">                socket.handler(buffer -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Received response from server: &quot;</span> + buffer.toString());</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;Failed to connect to TCP server&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">VertxTcpClient</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）修改 TCP 服务端代码，打印出每次收到的消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VertxTcpServer</span> <span class="keyword">implements</span> <span class="title class_">HttpServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doStart</span><span class="params">(<span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 Vert.x 实例</span></span><br><span class="line">        <span class="type">Vertx</span> <span class="variable">vertx</span> <span class="operator">=</span> Vertx.vertx();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 TCP 服务器</span></span><br><span class="line">        <span class="type">NetServer</span> <span class="variable">server</span> <span class="operator">=</span> vertx.createNetServer();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理请求</span></span><br><span class="line"><span class="comment">//        server.connectHandler(new TcpServerHandler());</span></span><br><span class="line">        server.connectHandler(socket -&gt; &#123;</span><br><span class="line">            socket.handler(buffer -&gt; &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">testMessage</span> <span class="operator">=</span> <span class="string">&quot;Hello, server!Hello, server!Hello, server!Hello, server!&quot;</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">messageLength</span> <span class="operator">=</span> testMessage.getBytes().length;</span><br><span class="line">                <span class="keyword">if</span> (buffer.getBytes().length &lt; messageLength) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;半包, length = &quot;</span> + buffer.getBytes().length);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (buffer.getBytes().length &gt; messageLength) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;粘包, length = &quot;</span> + buffer.getBytes().length);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer.getBytes(<span class="number">0</span>, messageLength));</span><br><span class="line">                System.out.println(str);</span><br><span class="line">                <span class="keyword">if</span> (testMessage.equals(str)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;good&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动 TCP 服务器并监听指定端口</span></span><br><span class="line">        server.listen(port, result -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (result.succeeded()) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;TCP server started on port &quot;</span> + port);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;Failed to start TCP server: &quot;</span> + result.cause());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">VertxTcpServer</span>().doStart(<span class="number">8888</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）测试运行，查看服务端控制台，发现服务端接受消息时，出现了半包和粘包：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/03/10/67cee88c16dcc.png"></p><p>下面分别解决半包和粘包问题。</p><h3 id="如何解决半包？"><a href="#如何解决半包？" class="headerlink" title="如何解决半包？"></a>如何解决半包？</h3><p>解决半包的核心思路是：在消息头中设置请求体的长度，服务端接收时，判断每次消息的长度是否符合预期，不完整就不读，留到下一次接收到消息时再读取。</p><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (buffer == <span class="literal">null</span> || buffer.length() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;消息 buffer 为空&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (buffer.getBytes().length &lt; ProtocolConstant.MESSAGE_HEADER_LENGTH) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;出现了半包问题&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="如何解决粘包？"><a href="#如何解决粘包？" class="headerlink" title="如何解决粘包？"></a>如何解决粘包？</h3><p>解决粘包的核心思路也是类似的：每次只读取指定长度的数据，超过长度的留着下一次接收到消息时再读取。</p><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解决粘包问题，只读指定长度的数据</span></span><br><span class="line"><span class="type">byte</span>[] bodyBytes = buffer.getBytes(<span class="number">17</span>, <span class="number">17</span> + header.getBodyLength());</span><br></pre></td></tr></table></figure><p>听上去简单，但实现起来还是比较麻烦的，要记录每次接收到的消息位置，维护字节数组缓存。有没有更简单的方式呢？</p><h3 id="Vert-x-解决半包和粘包"><a href="#Vert-x-解决半包和粘包" class="headerlink" title="Vert.x 解决半包和粘包"></a>Vert.x 解决半包和粘包</h3><p>在 Vert.x 框架中，可以使用内置的 <code>RecordParser</code> 完美解决半包粘包，它的作用是：保证下次读取到 <strong>特定长度</strong> 的字符。</p><p>先学会该类库的使用，跑通测试流程，再引入到业务代码中。</p><h4 id="基础代码"><a href="#基础代码" class="headerlink" title="基础代码"></a>基础代码</h4><p>1）先使用 <code>RecordParser</code> 来读取固定长度的消息，示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VertxTcpServer</span> <span class="keyword">implements</span> <span class="title class_">HttpServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doStart</span><span class="params">(<span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 Vert.x 实例</span></span><br><span class="line">        <span class="type">Vertx</span> <span class="variable">vertx</span> <span class="operator">=</span> Vertx.vertx();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 TCP 服务器</span></span><br><span class="line">        <span class="type">NetServer</span> <span class="variable">server</span> <span class="operator">=</span> vertx.createNetServer();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理请求</span></span><br><span class="line"><span class="comment">//        server.connectHandler(new TcpServerHandler());</span></span><br><span class="line">        server.connectHandler(socket -&gt; &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">testMessage</span> <span class="operator">=</span> <span class="string">&quot;Hello, server!Hello, server!Hello, server!Hello, server!&quot;</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">messageLength</span> <span class="operator">=</span> testMessage.getBytes().length;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 构造parser</span></span><br><span class="line">            <span class="type">RecordParser</span> <span class="variable">parser</span> <span class="operator">=</span> RecordParser.newFixed(messageLength);</span><br><span class="line">            parser.setOutput(<span class="keyword">new</span> <span class="title class_">Handler</span>&lt;Buffer&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(Buffer buffer)</span> &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(buffer.getBytes());</span><br><span class="line">                    System.out.println(str);</span><br><span class="line">                    <span class="keyword">if</span> (testMessage.equals(str)) &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;good&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            socket.handler(parser);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动 TCP 服务器并监听指定端口</span></span><br><span class="line">        server.listen(port, result -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (result.succeeded()) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;TCP server started on port &quot;</span> + port);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;Failed to start TCP server: &quot;</span> + result.cause());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">VertxTcpServer</span>().doStart(<span class="number">8888</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的核心是 <code>RecordParser.newFixed(messageLength)</code>，为 Parser 指定每次读取固定值长度的内容。</p><p>测试发现，这次的输出结果非常整齐，解决了半包和粘包：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/03/10/67cee8d050cd4.png"></p><p>2）实际运用中，消息体的长度是不固定的，所以要通过调整 RecordParser 的固定长度（变长）来解决。</p><p>那我们的思路可以是，将读取完整的消息拆分为 2 次：</p><ol><li>先完整读取请求头信息，由于请求头信息长度是固定的，可以使用 <code>RecordParser</code> 保证每次都完整读取。</li><li>再根据请求头长度信息更改 <code>RecordParser</code> 的固定长度，保证完整获取到请求体。</li></ol><p>修改测试 TCP Server 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VertxTcpServer</span> <span class="keyword">implements</span> <span class="title class_">HttpServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doStart</span><span class="params">(<span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 Vert.x 实例</span></span><br><span class="line">        <span class="type">Vertx</span> <span class="variable">vertx</span> <span class="operator">=</span> Vertx.vertx();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 TCP 服务器</span></span><br><span class="line">        <span class="type">NetServer</span> <span class="variable">server</span> <span class="operator">=</span> vertx.createNetServer();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理请求</span></span><br><span class="line">        server.connectHandler(socket -&gt; &#123;</span><br><span class="line">            <span class="comment">// 构造 parser</span></span><br><span class="line">            <span class="type">RecordParser</span> <span class="variable">parser</span> <span class="operator">=</span> RecordParser.newFixed(<span class="number">8</span>);</span><br><span class="line">            parser.setOutput(<span class="keyword">new</span> <span class="title class_">Handler</span>&lt;Buffer&gt;() &#123;</span><br><span class="line">                <span class="comment">// 初始化</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 一次完整的读取（头 + 体）</span></span><br><span class="line">                <span class="type">Buffer</span> <span class="variable">resultBuffer</span> <span class="operator">=</span> Buffer.buffer();</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(Buffer buffer)</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (-<span class="number">1</span> == size) &#123;</span><br><span class="line">                        <span class="comment">// 读取消息体长度</span></span><br><span class="line">                        size = buffer.getInt(<span class="number">4</span>);</span><br><span class="line">                        parser.fixedSizeMode(size);</span><br><span class="line">                        <span class="comment">// 写入头信息到结果</span></span><br><span class="line">                        resultBuffer.appendBuffer(buffer);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 写入体信息到结果</span></span><br><span class="line">                        resultBuffer.appendBuffer(buffer);</span><br><span class="line">                        System.out.println(resultBuffer.toString());</span><br><span class="line">                        <span class="comment">// 重置一轮</span></span><br><span class="line">                        parser.fixedSizeMode(<span class="number">8</span>);</span><br><span class="line">                        size = -<span class="number">1</span>;</span><br><span class="line">                        resultBuffer = Buffer.buffer();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            socket.handler(parser);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动 TCP 服务器并监听指定端口</span></span><br><span class="line">        server.listen(port, result -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (result.succeeded()) &#123;</span><br><span class="line">                log.info(<span class="string">&quot;TCP server started on port &quot;</span> + port);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.info(<span class="string">&quot;Failed to start TCP server: &quot;</span> + result.cause());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">VertxTcpServer</span>().doStart(<span class="number">8888</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改测试 TCP client 代码如下，自己构造了一个变长、长度信息不在 Buffer 最开头（而是有一定偏移量）的消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VertxTcpClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 Vert.x 实例</span></span><br><span class="line">        <span class="type">Vertx</span> <span class="variable">vertx</span> <span class="operator">=</span> Vertx.vertx();</span><br><span class="line"></span><br><span class="line">        vertx.createNetClient().connect(<span class="number">8888</span>, <span class="string">&quot;localhost&quot;</span>, result -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (result.succeeded()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Connected to TCP server&quot;</span>);</span><br><span class="line">                io.vertx.core.net.<span class="type">NetSocket</span> <span class="variable">socket</span> <span class="operator">=</span> result.result();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                    <span class="comment">// 发送数据</span></span><br><span class="line">                    <span class="type">Buffer</span> <span class="variable">buffer</span> <span class="operator">=</span> Buffer.buffer();</span><br><span class="line">                    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;Hello, server!Hello, server!Hello, server!Hello, server!&quot;</span>;</span><br><span class="line">                    buffer.appendInt(<span class="number">0</span>);</span><br><span class="line">                    buffer.appendInt(str.getBytes().length);</span><br><span class="line">                    buffer.appendBytes(str.getBytes());</span><br><span class="line">                    socket.write(buffer);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 接收响应</span></span><br><span class="line">                socket.handler(buffer -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Received response from server: &quot;</span> + buffer.toString());</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;Failed to connect to TCP server&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">VertxTcpClient</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果应该也是能够正常读取到消息的，不会出现半包和粘包。</p><h4 id="封装半包粘包处理器"><a href="#封装半包粘包处理器" class="headerlink" title="封装半包粘包处理器"></a>封装半包粘包处理器</h4><p>我们会发现，解决半包粘包问题还是有一定的代码量的，而且由于 ServiceProxy（消费者）和请求 Handler（提供者）都需要接受 Buffer，所以都需要半包粘包问题处理。</p><p>那我们就应该要想到：需要对代码进行封装复用了。</p><p>这里我们可以使用设计模式中的 <strong>装饰者模式</strong>，使用 RecordParser 对原有的 Buffer 处理器的能力进行增强。</p><p>装饰者模式可以简单理解为给对象穿装备，增强对象的能力。</p><p>在 <code>server.tcp</code> 包下新建 <code>TcpBufferHandlerWrapper</code> 类，实现并增强 <code>Handler&lt;Buffer&gt;</code> 接口。</p><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 装饰者模式（使用 recordParser 对原有的 buffer 处理能力进行增强）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TcpBufferHandlerWrapper</span> <span class="keyword">implements</span> <span class="title class_">Handler</span>&lt;Buffer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RecordParser recordParser;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TcpBufferHandlerWrapper</span><span class="params">(Handler&lt;Buffer&gt; bufferHandler)</span> &#123;</span><br><span class="line">        recordParser = initRecordParser(bufferHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(Buffer buffer)</span> &#123;</span><br><span class="line">        recordParser.handle(buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RecordParser <span class="title function_">initRecordParser</span><span class="params">(Handler&lt;Buffer&gt; bufferHandler)</span> &#123;</span><br><span class="line">        <span class="comment">// 构造 parser</span></span><br><span class="line">        <span class="type">RecordParser</span> <span class="variable">parser</span> <span class="operator">=</span> RecordParser.newFixed(ProtocolConstant.MESSAGE_HEADER_LENGTH);</span><br><span class="line"></span><br><span class="line">        parser.setOutput(<span class="keyword">new</span> <span class="title class_">Handler</span>&lt;Buffer&gt;() &#123;</span><br><span class="line">            <span class="comment">// 初始化</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 一次完整的读取（头 + 体）</span></span><br><span class="line">            <span class="type">Buffer</span> <span class="variable">resultBuffer</span> <span class="operator">=</span> Buffer.buffer();</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(Buffer buffer)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (-<span class="number">1</span> == size) &#123;</span><br><span class="line">                    <span class="comment">// 读取消息体长度</span></span><br><span class="line">                    size = buffer.getInt(<span class="number">13</span>);</span><br><span class="line">                    parser.fixedSizeMode(size);</span><br><span class="line">                    <span class="comment">// 写入头信息到结果</span></span><br><span class="line">                    resultBuffer.appendBuffer(buffer);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 写入体信息到结果</span></span><br><span class="line">                    resultBuffer.appendBuffer(buffer);</span><br><span class="line">                    <span class="comment">// 已拼接为完整 Buffer，执行处理</span></span><br><span class="line">                    bufferHandler.handle(resultBuffer);</span><br><span class="line">                    <span class="comment">// 重置一轮</span></span><br><span class="line">                    parser.fixedSizeMode(ProtocolConstant.MESSAGE_HEADER_LENGTH);</span><br><span class="line">                    size = -<span class="number">1</span>;</span><br><span class="line">                    resultBuffer = Buffer.buffer();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> parser;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是把 RecordParser 的代码粘了过来，当调用处理器的 <code>handle</code> 方法时，改为调用 <code>recordParser.handle</code>。</p><h3 id="优化客户端调用代码"><a href="#优化客户端调用代码" class="headerlink" title="优化客户端调用代码"></a>优化客户端调用代码</h3><p>有了半包粘包处理器，我们就可以很轻松地在业务代码中运用它了。</p><p>1）修改 TCP 请求处理器。</p><p>使用 <code>TcpBufferHandlerWrapper</code> 来封装之前处理请求的代码，请求逻辑不用变，需要修改的部分代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TCP 请求处理器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href=&quot;https://github.com/liyupi&quot;&gt;程序员鱼皮&lt;/a&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@learn</span> &lt;a href=&quot;https://codefather.cn&quot;&gt;编程宝典&lt;/a&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@from</span> &lt;a href=&quot;https://yupi.icu&quot;&gt;编程导航知识星球&lt;/a&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TcpServerHandler</span> <span class="keyword">implements</span> <span class="title class_">Handler</span>&lt;NetSocket&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理请求</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> socket the event to handle</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(NetSocket socket)</span> &#123;</span><br><span class="line">        <span class="type">TcpBufferHandlerWrapper</span> <span class="variable">bufferHandlerWrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TcpBufferHandlerWrapper</span>(buffer -&gt; &#123;</span><br><span class="line">            <span class="comment">// 处理请求代码</span></span><br><span class="line">        &#125;);</span><br><span class="line">        socket.handler(bufferHandlerWrapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是使用一个 Wrapper 对象 <strong>包装</strong> 了之前的代码，就解决了半包粘包。</p><p>2）修改客户端处理响应的代码。</p><p>之前我们是把所有发送请求、处理响应的代码都写到了 <code>ServiceProxy</code> 中，使得这个类的代码 “臃肿不堪”。</p><p>我们干脆做个优化，把所有的请求响应逻辑提取出来，封装为单独的 <code>VertxTcpClient</code> 类，放在 <code>server.tcp</code> 包下。</p><p>VertxTcpClient 的完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Vertx TCP 请求客户端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VertxTcpClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送请求</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rpcRequest</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceMetaInfo</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ExecutionException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> RpcResponse <span class="title function_">doRequest</span><span class="params">(RpcRequest rpcRequest, ServiceMetaInfo serviceMetaInfo)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException &#123;</span><br><span class="line">        <span class="comment">// 发送 TCP 请求</span></span><br><span class="line">        <span class="type">Vertx</span> <span class="variable">vertx</span> <span class="operator">=</span> Vertx.vertx();</span><br><span class="line">        <span class="type">NetClient</span> <span class="variable">netClient</span> <span class="operator">=</span> vertx.createNetClient();</span><br><span class="line">        CompletableFuture&lt;RpcResponse&gt; responseFuture = <span class="keyword">new</span> <span class="title class_">CompletableFuture</span>&lt;&gt;();</span><br><span class="line">        netClient.connect(serviceMetaInfo.getServicePort(), serviceMetaInfo.getServiceHost(),</span><br><span class="line">                result -&gt; &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!result.succeeded()) &#123;</span><br><span class="line">                        System.err.println(<span class="string">&quot;Failed to connect to TCP server&quot;</span>);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">NetSocket</span> <span class="variable">socket</span> <span class="operator">=</span> result.result();</span><br><span class="line">                    <span class="comment">// 发送数据</span></span><br><span class="line">                    <span class="comment">// 构造消息</span></span><br><span class="line">                    ProtocolMessage&lt;RpcRequest&gt; protocolMessage = <span class="keyword">new</span> <span class="title class_">ProtocolMessage</span>&lt;&gt;();</span><br><span class="line">                    ProtocolMessage.<span class="type">Header</span> <span class="variable">header</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProtocolMessage</span>.Header();</span><br><span class="line">                    header.setMagic(ProtocolConstant.PROTOCOL_MAGIC);</span><br><span class="line">                    header.setVersion(ProtocolConstant.PROTOCOL_VERSION);</span><br><span class="line">                    header.setSerializer((<span class="type">byte</span>) ProtocolMessageSerializerEnum.getEnumByValue(RpcApplication.getRpcConfig().getSerializer()).getKey());</span><br><span class="line">                    header.setType((<span class="type">byte</span>) ProtocolMessageTypeEnum.REQUEST.getKey());</span><br><span class="line">                    <span class="comment">// 生成全局请求 ID</span></span><br><span class="line">                    header.setRequestId(IdUtil.getSnowflakeNextId());</span><br><span class="line">                    protocolMessage.setHeader(header);</span><br><span class="line">                    protocolMessage.setBody(rpcRequest);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 编码请求</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="type">Buffer</span> <span class="variable">encodeBuffer</span> <span class="operator">=</span> ProtocolMessageEncoder.encode(protocolMessage);</span><br><span class="line">                        socket.write(encodeBuffer);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;协议消息编码错误&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 接收响应</span></span><br><span class="line">                    <span class="type">TcpBufferHandlerWrapper</span> <span class="variable">bufferHandlerWrapper</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TcpBufferHandlerWrapper</span>(</span><br><span class="line">                            buffer -&gt; &#123;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    ProtocolMessage&lt;RpcResponse&gt; rpcResponseProtocolMessage =</span><br><span class="line">                                            (ProtocolMessage&lt;RpcResponse&gt;) ProtocolMessageDecoder.decode(buffer);</span><br><span class="line">                                    responseFuture.complete(rpcResponseProtocolMessage.getBody());</span><br><span class="line">                                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;协议消息解码错误&quot;</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                    );</span><br><span class="line">                    socket.handler(bufferHandlerWrapper);</span><br><span class="line"></span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">RpcResponse</span> <span class="variable">rpcResponse</span> <span class="operator">=</span> responseFuture.get();</span><br><span class="line">        <span class="comment">// 记得关闭连接</span></span><br><span class="line">        netClient.close();</span><br><span class="line">        <span class="keyword">return</span> rpcResponse;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，上述代码中，也使用了 <code>TcpBufferHandlerWrapper</code> 对处理响应的代码进行了封装。</p><p>修改 ServiceProxy 代码，调用 VertxTcpClient，修改后的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务代理（JDK 动态代理）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用代理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 指定序列化器</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Serializer</span> <span class="variable">serializer</span> <span class="operator">=</span> SerializerFactory.getInstance(RpcApplication.getRpcConfig().getSerializer());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造请求</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> method.getDeclaringClass().getName();</span><br><span class="line">        <span class="type">RpcRequest</span> <span class="variable">rpcRequest</span> <span class="operator">=</span> RpcRequest.builder()</span><br><span class="line">                .serviceName(serviceName)</span><br><span class="line">                .methodName(method.getName())</span><br><span class="line">                .parameterTypes(method.getParameterTypes())</span><br><span class="line">                .args(args)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 从注册中心获取服务提供者请求地址</span></span><br><span class="line">            <span class="type">RpcConfig</span> <span class="variable">rpcConfig</span> <span class="operator">=</span> RpcApplication.getRpcConfig();</span><br><span class="line">            <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> RegistryFactory.getInstance(rpcConfig.getRegistryConfig().getRegistry());</span><br><span class="line">            <span class="type">ServiceMetaInfo</span> <span class="variable">serviceMetaInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceMetaInfo</span>();</span><br><span class="line">            serviceMetaInfo.setServiceName(serviceName);</span><br><span class="line">            serviceMetaInfo.setServiceVersion(RpcConstant.DEFAULT_SERVICE_VERSION);</span><br><span class="line">            List&lt;ServiceMetaInfo&gt; serviceMetaInfoList = registry.serviceDiscovery(serviceMetaInfo.getServiceKey());</span><br><span class="line">            <span class="keyword">if</span> (CollUtil.isEmpty(serviceMetaInfoList)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;暂无服务地址&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ServiceMetaInfo</span> <span class="variable">selectedServiceMetaInfo</span> <span class="operator">=</span> serviceMetaInfoList.get(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 发送 TCP 请求</span></span><br><span class="line">            <span class="type">RpcResponse</span> <span class="variable">rpcResponse</span> <span class="operator">=</span> VertxTcpClient.doRequest(rpcRequest, selectedServiceMetaInfo);</span><br><span class="line">            <span class="keyword">return</span> rpcResponse.getData();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;调用失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RPC框架开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPC开发6_注册中心优化</title>
      <link href="/2025/01/16/RPC%E5%BC%80%E5%8F%916_%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E4%BC%98%E5%8C%96/"/>
      <url>/2025/01/16/RPC%E5%BC%80%E5%8F%916_%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="一、需求分析"><a href="#一、需求分析" class="headerlink" title="一、需求分析"></a>一、需求分析</h2><p>上节基于 Etcd 完成了基础的注册中心，能够注册和获取服务和节点信息。</p><p>但目前系统仅仅是处于可用的程度，还有很多需要解决的问题和可优化点：</p><ol><li>数据一致性：服务提供者如果下线了，注册中心需要即时更新，剔除下线节点。否则消费者可能会调用到已经下线的节点。</li><li>性能优化：服务消费者每次都需要从注册中心获取服务，可以使用缓存进行优化。</li><li>高可用性：保证注册中心本身不会宕机。</li><li>可扩展性：实现更多其他种类的注册中心。</li></ol><p>本节将实践 4 个注册中心的优化点：</p><ol><li>心跳检测和续期机制</li><li>服务节点下线机制</li><li>消费端服务缓存</li><li>基于 ZooKeeper 的注册中心实现</li></ol><h2 id="二、注册中心优化"><a href="#二、注册中心优化" class="headerlink" title="二、注册中心优化"></a>二、注册中心优化</h2><h3 id="心跳检测和续期机制"><a href="#心跳检测和续期机制" class="headerlink" title="心跳检测和续期机制"></a>心跳检测和续期机制</h3><h4 id="心跳检测介绍"><a href="#心跳检测介绍" class="headerlink" title="心跳检测介绍"></a>心跳检测介绍</h4><p>心跳检测（俗称 heartBeat）是一种用于监测系统是否正常工作的机制。它通过定期发送 <strong>心跳信号</strong>（请求）来检测目标系统的状态。</p><p>如果接收方在一定时间内没有收到心跳信号或者未能正常响应请求，就会认为目标系统故障或不可用，从而触发相应的处理或告警机制。</p><p>心跳检测的应用场景非常广泛，尤其是在分布式、微服务系统中，比如集群管理、服务健康检查等。</p><p>我们怎么检测自己做的 web 后端是否正常运行呢？</p><p>一个最简单的方法，就是写一个心跳检测接口，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HealthCheckController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 健康检查接口</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/actuator/health&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">healthCheck</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 在这里可以添加其他健康检查逻辑，例如检查数据库连接、第三方服务等</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回一个简单的健康状态</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;OK&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后只需要执行一个脚本，定期调用这个接口，如果调用失败，就知道系统故障了。</p><h4 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h4><p>1）从心跳检测的概念来看，实现心跳检测一般需要 2 个关键：定时、网络请求。</p><p>但是使用 Etcd 实现心跳检测会更简单一些，因为 Etcd 自带了 key 过期机制，我们不妨换个思路：给节点注册信息一个 “生命倒计时”，让节点定期 <strong>续期</strong>，重置 <strong>自己的</strong> 倒计时。如果节点已宕机，一直不续期，Etcd 就会对 key 进行过期删除。</p><p>一句话总结：到时间还不续期就是寄了。</p><p>在 Etcd 中，我们要实现心跳检测和续期机制，可以遵循如下步骤：</p><ol><li>服务提供者向 Etcd 注册自己的服务信息，并在注册时设置 TTL（生存时间）。</li><li>Etcd 在接收到服务提供者的注册信息后，会自动维护服务信息的 TTL，并在 TTL 过期时删除该服务信息。</li><li>服务提供者定期请求 Etcd 续签自己的注册信息，重写 TTL。</li></ol><p>需要注意的是，续期时间一定要小于过期时间，允许一次容错的机会。</p><p>2）每个服务提供者都需要找到自己注册的节点、续期自己的节点，但问题是，怎么找到当前服务提供者项目自己的节点呢？</p><p>那就充分利用本地的特性，在服务提供者本地维护一个 <strong>已注册节点集合</strong>，注册时添加节点 key 到集合中，只需要续期集合内的 key 即可。</p><h4 id="开发实现"><a href="#开发实现" class="headerlink" title="开发实现"></a>开发实现</h4><p>1）给注册中心 <code>Registry</code> 接口补充心跳检测方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注册中心</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Registry</span> &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 心跳检测（服务端）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">heartBeat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）维护续期节点集合。</p><p>定义一个本机注册的节点 key 集合，用于维护续期：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本机注册的节点 key 集合（用于维护续期）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; localRegisterNodeKeySet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>在服务注册时，需要将节点添加到集合中，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(ServiceMetaInfo serviceMetaInfo)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 创建 Lease 和 KV 客户端</span></span><br><span class="line">    <span class="type">Lease</span> <span class="variable">leaseClient</span> <span class="operator">=</span> client.getLeaseClient();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 30 秒的租约</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">leaseId</span> <span class="operator">=</span> leaseClient.grant(<span class="number">30</span>).get().getID();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置要存储的键值对</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">registerKey</span> <span class="operator">=</span> ETCD_ROOT_PATH + serviceMetaInfo.getServiceNodeKey();</span><br><span class="line">    <span class="type">ByteSequence</span> <span class="variable">key</span> <span class="operator">=</span> ByteSequence.from(registerKey, StandardCharsets.UTF_8);</span><br><span class="line">    <span class="type">ByteSequence</span> <span class="variable">value</span> <span class="operator">=</span> ByteSequence.from(JSONUtil.toJsonStr(serviceMetaInfo), StandardCharsets.UTF_8);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将键值对与租约关联起来，并设置过期时间</span></span><br><span class="line">    <span class="type">PutOption</span> <span class="variable">putOption</span> <span class="operator">=</span> PutOption.builder().withLeaseId(leaseId).build();</span><br><span class="line">    kvClient.put(key, value, putOption).get();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加节点信息到本地缓存</span></span><br><span class="line">    localRegisterNodeKeySet.add(registerKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，在服务注销时，也要从集合中移除对应节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unRegister</span><span class="params">(ServiceMetaInfo serviceMetaInfo)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">registerKey</span> <span class="operator">=</span> ETCD_ROOT_PATH + serviceMetaInfo.getServiceNodeKey();</span><br><span class="line">    kvClient.delete(ByteSequence.from(registerKey, StandardCharsets.UTF_8));</span><br><span class="line">    <span class="comment">// 也要从本地缓存移除</span></span><br><span class="line">    localRegisterNodeKeySet.remove(registerKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）在 <code>EtcdRegistry</code> 中实现 heartBeat 方法。</p><p>可以使用 Hutool 工具类的 CronUtil 实现定时任务，对所有集合中的节点执行 <strong>重新注册</strong> 操作，这是一个小 trick，就相当于续签了。</p><p>心跳检测方法的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">heartBeat</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 10 秒续签一次</span></span><br><span class="line">    CronUtil.schedule(<span class="string">&quot;*/10 * * * * *&quot;</span>, <span class="keyword">new</span> <span class="title class_">Task</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 遍历本节点所有的 key</span></span><br><span class="line">            <span class="keyword">for</span> (String key : localRegisterNodeKeySet) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    List&lt;KeyValue&gt; keyValues = kvClient.get(ByteSequence.from(key, StandardCharsets.UTF_8))</span><br><span class="line">                            .get()</span><br><span class="line">                            .getKvs();</span><br><span class="line">                    <span class="comment">// 该节点已过期（需要重启节点才能重新注册）</span></span><br><span class="line">                    <span class="keyword">if</span> (CollUtil.isEmpty(keyValues)) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 节点未过期，重新注册（相当于续签）</span></span><br><span class="line">                    <span class="type">KeyValue</span> <span class="variable">keyValue</span> <span class="operator">=</span> keyValues.get(<span class="number">0</span>);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> keyValue.getValue().toString(StandardCharsets.UTF_8);</span><br><span class="line">                    <span class="type">ServiceMetaInfo</span> <span class="variable">serviceMetaInfo</span> <span class="operator">=</span> JSONUtil.toBean(value, ServiceMetaInfo.class);</span><br><span class="line">                    register(serviceMetaInfo);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(key + <span class="string">&quot;续签失败&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 支持秒级别定时任务</span></span><br><span class="line">    CronUtil.setMatchSecond(<span class="literal">true</span>);</span><br><span class="line">    CronUtil.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用这种实现方案的好处是，即时 Etcd 注册中心的数据出现了丢失，通过心跳检测机制也会重新注册节点信息。</p><p>4）开启 heartBeat。</p><p>在注册中心初始化的 init 方法中，调用 heartBeat 方法即可。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(RegistryConfig registryConfig)</span> &#123;</span><br><span class="line">    client = Client.builder()</span><br><span class="line">            .endpoints(registryConfig.getAddress())</span><br><span class="line">            .connectTimeout(Duration.ofMillis(registryConfig.getTimeout()))</span><br><span class="line">            .build();</span><br><span class="line">    kvClient = client.getKVClient();</span><br><span class="line">    heartBeat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="服务节点下线机制"><a href="#服务节点下线机制" class="headerlink" title="服务节点下线机制"></a>服务节点下线机制</h3><p>当服务提供者节点宕机时，应该从注册中心移除掉已注册的节点，否则会影响消费端调用。所以我们需要设计一套服务节点下线机制。</p><h4 id="方案设计-1"><a href="#方案设计-1" class="headerlink" title="方案设计"></a>方案设计</h4><p>服务节点下线又分为：</p><ul><li>主动下线：服务提供者项目正常退出时，主动从注册中心移除注册信息。</li><li>被动下线：服务提供者项目异常推出时，利用 Etcd 的 key 过期机制自动移除。</li></ul><p>被动下线已经可以利用 Etcd 的机制实现了，我们主要开发主动下线。</p><p>问题是，怎么在 Java 项目正常退出时，执行某个操作呢？</p><p>其实非常简单，利用 JVM 的 ShutdownHook 就能实现。</p><p>JVM 的 ShutdownHook 是 Java 虚拟机提供的一种机制，允许开发者在 JVM 即将关闭之前执行一些清理工作或其他必要的操作，例如关闭数据库连接、释放资源、保存临时数据等。</p><p>Spring Boot 也提供了类似的停机能力。</p><h4 id="开发实现-1"><a href="#开发实现-1" class="headerlink" title="开发实现"></a>开发实现</h4><p>1）完善 Etcd 注册中心的 <code>destroy</code> 方法，补充下线节点的逻辑。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;当前节点下线&quot;</span>);</span><br><span class="line">    <span class="comment">// 下线节点</span></span><br><span class="line">    <span class="comment">// 遍历本节点所有的 key</span></span><br><span class="line">    <span class="keyword">for</span> (String key : localRegisterNodeKeySet) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            kvClient.delete(ByteSequence.from(key, StandardCharsets.UTF_8)).get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(key + <span class="string">&quot;节点下线失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">if</span> (kvClient != <span class="literal">null</span>) &#123;</span><br><span class="line">        kvClient.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (client != <span class="literal">null</span>) &#123;</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）在 <code>RpcApplication</code> 的 init 方法中，注册 Shutdown Hook，当程序正常退出时会执行注册中心的 destroy 方法。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(RpcConfig newRpcConfig)</span> &#123;</span><br><span class="line">    rpcConfig = newRpcConfig;</span><br><span class="line">    log.info(<span class="string">&quot;rpc init, config = &#123;&#125;&quot;</span>, newRpcConfig.toString());</span><br><span class="line">    <span class="comment">// 注册中心初始化</span></span><br><span class="line">    <span class="type">RegistryConfig</span> <span class="variable">registryConfig</span> <span class="operator">=</span> rpcConfig.getRegistryConfig();</span><br><span class="line">    <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> RegistryFactory.getInstance(registryConfig.getRegistry());</span><br><span class="line">    registry.init(registryConfig);</span><br><span class="line">    log.info(<span class="string">&quot;registry init, config = &#123;&#125;&quot;</span>, registryConfig);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建并注册 Shutdown Hook，JVM 退出时执行操作</span></span><br><span class="line">    Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> <span class="title class_">Thread</span>(registry::destroy));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消费端服务缓存"><a href="#消费端服务缓存" class="headerlink" title="消费端服务缓存"></a>消费端服务缓存</h3><p>正常情况下，服务节点信息列表的更新频率是不高的，所以在服务消费者从注册中心获取到服务节点信息列表后，完全可以 <strong>缓存在本地</strong>，下次就不用再请求注册中心获取了，能够提高性能。</p><h4 id="1、增加本地缓存"><a href="#1、增加本地缓存" class="headerlink" title="1、增加本地缓存"></a>1、增加本地缓存</h4><p>本地缓存的实现很简单，用一个列表来存储服务信息即可，提供操作列表的基本方法，包括：写缓存、读缓存、清空缓存。</p><p>暂时先只考虑单服务（相同 serviceKey）的缓存。如果要实现多服务缓存，可以改为使用 Map 接口。</p><p>在 <code>registry</code> 包下新增缓存类 <code>RegistryServiceCache</code>，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注册中心服务本地缓存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegistryServiceCache</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;ServiceMetaInfo&gt; serviceCache;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newServiceCache</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">writeCache</span><span class="params">(List&lt;ServiceMetaInfo&gt; newServiceCache)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.serviceCache = newServiceCache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读缓存</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;ServiceMetaInfo&gt; <span class="title function_">readCache</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.serviceCache;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 清空缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">clearCache</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.serviceCache = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、使用本地缓存"><a href="#2、使用本地缓存" class="headerlink" title="2、使用本地缓存"></a>2、使用本地缓存</h4><p>1）修改 <code>EtcdRegisty</code> 的代码，使用本地缓存对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注册中心服务缓存</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">RegistryServiceCache</span> <span class="variable">registryServiceCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RegistryServiceCache</span>();</span><br></pre></td></tr></table></figure><p>2）修改服务发现逻辑，优先从缓存获取服务；如果没有缓存，再从注册中心获取，并且设置到缓存中。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> List&lt;ServiceMetaInfo&gt; <span class="title function_">serviceDiscovery</span><span class="params">(String serviceKey)</span> &#123;</span><br><span class="line">    <span class="comment">// 优先从缓存获取服务</span></span><br><span class="line">    List&lt;ServiceMetaInfo&gt; cachedServiceMetaInfoList = registryServiceCache.readCache();</span><br><span class="line">    <span class="keyword">if</span> (cachedServiceMetaInfoList != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cachedServiceMetaInfoList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前缀搜索，结尾一定要加 &#x27;/&#x27;</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">searchPrefix</span> <span class="operator">=</span> ETCD_ROOT_PATH + serviceKey + <span class="string">&quot;/&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 前缀查询</span></span><br><span class="line">        <span class="type">GetOption</span> <span class="variable">getOption</span> <span class="operator">=</span> GetOption.builder().isPrefix(<span class="literal">true</span>).build();</span><br><span class="line">        List&lt;KeyValue&gt; keyValues = kvClient.get(</span><br><span class="line">                        ByteSequence.from(searchPrefix, StandardCharsets.UTF_8),</span><br><span class="line">                        getOption)</span><br><span class="line">                .get()</span><br><span class="line">                .getKvs();</span><br><span class="line">        <span class="comment">// 解析服务信息</span></span><br><span class="line">        List&lt;ServiceMetaInfo&gt; serviceMetaInfoList = keyValues.stream()</span><br><span class="line">                .map(keyValue -&gt; &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyValue.getKey().toString(StandardCharsets.UTF_8);</span><br><span class="line">                    <span class="comment">// 监听 key 的变化</span></span><br><span class="line">                    watch(key);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> keyValue.getValue().toString(StandardCharsets.UTF_8);</span><br><span class="line">                    <span class="keyword">return</span> JSONUtil.toBean(value, ServiceMetaInfo.class);</span><br><span class="line">                &#125;)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 写入服务缓存</span></span><br><span class="line">        registryServiceCache.writeCache(serviceMetaInfoList);</span><br><span class="line">        <span class="keyword">return</span> serviceMetaInfoList;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;获取服务列表失败&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、服务缓存更新-监听机制"><a href="#3、服务缓存更新-监听机制" class="headerlink" title="3、服务缓存更新 - 监听机制"></a>3、服务缓存更新 - 监听机制</h4><p>当服务注册信息发生变更（比如节点下线）时，需要即时更新消费端缓存。</p><p>问题是，怎么知道服务注册信息什么时候发生变更呢？</p><p>这就需要我们使用 Etcd 的 watch 监听机制，当监听的某个 key 发生修改或删除时，就会触发事件来通知监听者。</p><p>什么时候去创建 watch 监听器呢？</p><p>首先要明确 watch 监听是服务消费者还是服务提供者执行的。由于我们的目标是更新缓存，缓存是在服务消费端维护和使用的，所以也应该是服务消费端去 watch。</p><p>也就是说，只有服务消费者执行的方法中，可以创建 watch 监听器，那么比较合适的位置就是服务发现方法（serviceDiscovery）。可以对本次获取到的所有服务节点 key 进行监听。</p><p>还需要防止重复监听同一个 key，可以通过定义一个已监听 key 的集合来实现。</p><p>下面开发编码。</p><p>1）Registry 注册中心接口补充监听 key 的方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注册中心</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href=&quot;https://github.com/liyupi&quot;&gt;程序员鱼皮&lt;/a&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@learn</span> &lt;a href=&quot;https://codefather.cn&quot;&gt;编程宝典&lt;/a&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@from</span> &lt;a href=&quot;https://yupi.icu&quot;&gt;编程导航知识星球&lt;/a&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Registry</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听（消费端）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceNodeKey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">watch</span><span class="params">(String serviceNodeKey)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）<code>EtcdRegistry</code> 类中，新增监听 key 的集合。</p><p>可以使用 <code>ConcurrentHashSet</code> 防止并发冲突，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 正在监听的 key 集合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; watchingKeySet = <span class="keyword">new</span> <span class="title class_">ConcurrentHashSet</span>&lt;&gt;();</span><br></pre></td></tr></table></figure><p>3）在 <code>EtcdRegistry</code> 类中实现监听 key 的方法。</p><p>通过调用 Etcd 的 <code>WatchClient</code> 实现监听，如果出现了 <code>DELETE</code> key 删除事件，则清理服务注册缓存。</p><p>注意，即使 key 在注册中心被删除后再重新设置，之前的监听依旧生效。所以我们只监听首次加入到监听集合的 key，防止重复。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 监听（消费端）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> serviceNodeKey</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">watch</span><span class="params">(String serviceNodeKey)</span> &#123;</span><br><span class="line">    <span class="type">Watch</span> <span class="variable">watchClient</span> <span class="operator">=</span> client.getWatchClient();</span><br><span class="line">    <span class="comment">// 之前未被监听，开启监听</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">newWatch</span> <span class="operator">=</span> watchingKeySet.add(serviceNodeKey);</span><br><span class="line">    <span class="keyword">if</span> (newWatch) &#123;</span><br><span class="line">        watchClient.watch(ByteSequence.from(serviceNodeKey, StandardCharsets.UTF_8), response -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (WatchEvent event : response.getEvents()) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (event.getEventType()) &#123;</span><br><span class="line">                    <span class="comment">// key 删除时触发</span></span><br><span class="line">                    <span class="keyword">case</span> DELETE:</span><br><span class="line">                        <span class="comment">// 清理注册服务缓存</span></span><br><span class="line">                        registryServiceCache.clearCache();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> PUT:</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4）在消费端获取服务时调用 watch 方法，对获取到的服务节点 key 进行监听。</p><p>修改服务发现方法的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;ServiceMetaInfo&gt; <span class="title function_">serviceDiscovery</span><span class="params">(String serviceKey)</span> &#123;</span><br><span class="line">    <span class="comment">// 优先从缓存获取服务</span></span><br><span class="line">    List&lt;ServiceMetaInfo&gt; cachedServiceMetaInfoList = registryServiceCache.readCache();</span><br><span class="line">    <span class="keyword">if</span> (cachedServiceMetaInfoList != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cachedServiceMetaInfoList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前缀搜索，结尾一定要加 &#x27;/&#x27;</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">searchPrefix</span> <span class="operator">=</span> ETCD_ROOT_PATH + serviceKey + <span class="string">&quot;/&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 前缀查询</span></span><br><span class="line">        <span class="type">GetOption</span> <span class="variable">getOption</span> <span class="operator">=</span> GetOption.builder().isPrefix(<span class="literal">true</span>).build();</span><br><span class="line">        List&lt;KeyValue&gt; keyValues = kvClient.get(</span><br><span class="line">                        ByteSequence.from(searchPrefix, StandardCharsets.UTF_8),</span><br><span class="line">                        getOption)</span><br><span class="line">                .get()</span><br><span class="line">                .getKvs();</span><br><span class="line">        <span class="comment">// 解析服务信息</span></span><br><span class="line">        List&lt;ServiceMetaInfo&gt; serviceMetaInfoList = keyValues.stream()</span><br><span class="line">                .map(keyValue -&gt; &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> keyValue.getKey().toString(StandardCharsets.UTF_8);</span><br><span class="line">                    <span class="comment">// 监听 key 的变化</span></span><br><span class="line">                    watch(key);</span><br><span class="line">                    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> keyValue.getValue().toString(StandardCharsets.UTF_8);</span><br><span class="line">                    <span class="keyword">return</span> JSONUtil.toBean(value, ServiceMetaInfo.class);</span><br><span class="line">                &#125;)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        <span class="comment">// 写入服务缓存</span></span><br><span class="line">        registryServiceCache.writeCache(serviceMetaInfoList);</span><br><span class="line">        <span class="keyword">return</span> serviceMetaInfoList;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;获取服务列表失败&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ZooKeeper-注册中心实现"><a href="#ZooKeeper-注册中心实现" class="headerlink" title="ZooKeeper 注册中心实现"></a>ZooKeeper 注册中心实现</h3><blockquote><p>这部分不作为学习重点，理解了一种注册中心的实现方式，再用其他技术实现注册中心就很简单了。</p></blockquote><p>和 Etcd 注册中心的实现方式极其相似，步骤如下：</p><ol><li>安装 ZooKeeper</li><li>引入客户端依赖</li><li>实现接口</li><li>SPI 补充 ZooKeeper 注册中心</li></ol><p>1）本地下载并启动 ZooKeeper。</p><p>下载链接：<a href="https://dlcdn.apache.org/zookeeper/zookeeper-3.8.4/apache-zookeeper-3.8.4-bin.tar.gz">https://dlcdn.apache.org/zookeeper/zookeeper-3.8.4/apache-zookeeper-3.8.4-bin.tar.gz</a></p><p>正常启动 ZooKeeper 后，默认会占用几个端口号，比如 2181（客户端）、8080（管理端）等。</p><p>2）引入客户端依赖。</p><p>一般会使用 Apache Curator 来操作 ZooKeeper，可以参考官方文档：<a href="https://curator.apache.org/docs/getting-started">https://curator.apache.org/docs/getting-started</a> 。</p><p>引入的依赖代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- zookeeper --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-x-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3）ZooKeeper 注册中心实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * zookeeper 注册中心</span></span><br><span class="line"><span class="comment"> * 操作文档：&lt;a href=&quot;https://curator.apache.org/docs/getting-started&quot;&gt;Apache Curator&lt;/a&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 代码示例：&lt;a href=&quot;https://github.com/apache/curator/blob/master/curator-examples/src/main/java/discovery/DiscoveryExample.java&quot;&gt;DiscoveryExample.java&lt;/a&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 监听 key 示例：&lt;a href=&quot;https://github.com/apache/curator/blob/master/curator-examples/src/main/java/cache/CuratorCacheExample.java&quot;&gt;CuratorCacheExample.java&lt;/a&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href=&quot;https://github.com/liyupi&quot;&gt;coder_yupi&lt;/a&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@from</span> &lt;a href=&quot;https://yupi.icu&quot;&gt;编程导航学习圈&lt;/a&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@learn</span> &lt;a href=&quot;https://codefather.cn&quot;&gt;yupi 的编程宝典&lt;/a&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZooKeeperRegistry</span> <span class="keyword">implements</span> <span class="title class_">Registry</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CuratorFramework client;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServiceDiscovery&lt;ServiceMetaInfo&gt; serviceDiscovery;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 本机注册的节点 key 集合（用于维护续期）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; localRegisterNodeKeySet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册中心服务缓存</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">RegistryServiceCache</span> <span class="variable">registryServiceCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RegistryServiceCache</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 正在监听的 key 集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; watchingKeySet = <span class="keyword">new</span> <span class="title class_">ConcurrentHashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ZK_ROOT_PATH</span> <span class="operator">=</span> <span class="string">&quot;/rpc/zk&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(RegistryConfig registryConfig)</span> &#123;</span><br><span class="line">        <span class="comment">// 构建 client 实例</span></span><br><span class="line">        client = CuratorFrameworkFactory</span><br><span class="line">                .builder()</span><br><span class="line">                .connectString(registryConfig.getAddress())</span><br><span class="line">                .retryPolicy(<span class="keyword">new</span> <span class="title class_">ExponentialBackoffRetry</span>(Math.toIntExact(registryConfig.getTimeout()), <span class="number">3</span>))</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建 serviceDiscovery 实例</span></span><br><span class="line">        serviceDiscovery = ServiceDiscoveryBuilder.builder(ServiceMetaInfo.class)</span><br><span class="line">                .client(client)</span><br><span class="line">                .basePath(ZK_ROOT_PATH)</span><br><span class="line">                .serializer(<span class="keyword">new</span> <span class="title class_">JsonInstanceSerializer</span>&lt;&gt;(ServiceMetaInfo.class))</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 启动 client 和 serviceDiscovery</span></span><br><span class="line">            client.start();</span><br><span class="line">            serviceDiscovery.start();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(ServiceMetaInfo serviceMetaInfo)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 注册到 zk 里</span></span><br><span class="line">        serviceDiscovery.registerService(buildServiceInstance(serviceMetaInfo));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 添加节点信息到本地缓存</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">registerKey</span> <span class="operator">=</span> ZK_ROOT_PATH + <span class="string">&quot;/&quot;</span> + serviceMetaInfo.getServiceNodeKey();</span><br><span class="line">        localRegisterNodeKeySet.add(registerKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unRegister</span><span class="params">(ServiceMetaInfo serviceMetaInfo)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            serviceDiscovery.unregisterService(buildServiceInstance(serviceMetaInfo));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从本地缓存移除</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">registerKey</span> <span class="operator">=</span> ZK_ROOT_PATH + <span class="string">&quot;/&quot;</span> + serviceMetaInfo.getServiceNodeKey();</span><br><span class="line">        localRegisterNodeKeySet.remove(registerKey);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;ServiceMetaInfo&gt; <span class="title function_">serviceDiscovery</span><span class="params">(String serviceKey)</span> &#123;</span><br><span class="line">        <span class="comment">// 优先从缓存获取服务</span></span><br><span class="line">        List&lt;ServiceMetaInfo&gt; cachedServiceMetaInfoList = registryServiceCache.readCache();</span><br><span class="line">        <span class="keyword">if</span> (cachedServiceMetaInfoList != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> cachedServiceMetaInfoList;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 查询服务信息</span></span><br><span class="line">            Collection&lt;ServiceInstance&lt;ServiceMetaInfo&gt;&gt; serviceInstanceList = serviceDiscovery.queryForInstances(serviceKey);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 解析服务信息</span></span><br><span class="line">            List&lt;ServiceMetaInfo&gt; serviceMetaInfoList = serviceInstanceList.stream()</span><br><span class="line">                    .map(ServiceInstance::getPayload)</span><br><span class="line">                    .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 写入服务缓存</span></span><br><span class="line">            registryServiceCache.writeCache(serviceMetaInfoList);</span><br><span class="line">            <span class="keyword">return</span> serviceMetaInfoList;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;获取服务列表失败&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">heartBeat</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 不需要心跳机制，建立了临时节点，如果服务器故障，则临时节点直接丢失</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听（消费端）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceNodeKey 服务节点 key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">watch</span><span class="params">(String serviceNodeKey)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">watchKey</span> <span class="operator">=</span> ZK_ROOT_PATH + <span class="string">&quot;/&quot;</span> + serviceNodeKey;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">newWatch</span> <span class="operator">=</span> watchingKeySet.add(watchKey);</span><br><span class="line">        <span class="keyword">if</span> (newWatch) &#123;</span><br><span class="line">            <span class="type">CuratorCache</span> <span class="variable">curatorCache</span> <span class="operator">=</span> CuratorCache.build(client, watchKey);</span><br><span class="line">            curatorCache.start();</span><br><span class="line">            curatorCache.listenable().addListener(</span><br><span class="line">                    CuratorCacheListener</span><br><span class="line">                            .builder()</span><br><span class="line">                            .forDeletes(childData -&gt; registryServiceCache.clearCache())</span><br><span class="line">                            .forChanges(((oldNode, node) -&gt; registryServiceCache.clearCache()))</span><br><span class="line">                            .build()</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;当前节点下线&quot;</span>);</span><br><span class="line">        <span class="comment">// 下线节点（这一步可以不做，因为都是临时节点，服务下线，自然就被删掉了）</span></span><br><span class="line">        <span class="keyword">for</span> (String key : localRegisterNodeKeySet) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                client.delete().guaranteed().forPath(key);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(key + <span class="string">&quot;节点下线失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        <span class="keyword">if</span> (client != <span class="literal">null</span>) &#123;</span><br><span class="line">            client.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServiceInstance&lt;ServiceMetaInfo&gt; <span class="title function_">buildServiceInstance</span><span class="params">(ServiceMetaInfo serviceMetaInfo)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">serviceAddress</span> <span class="operator">=</span> serviceMetaInfo.getServiceHost() + <span class="string">&quot;:&quot;</span> + serviceMetaInfo.getServicePort();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> ServiceInstance</span><br><span class="line">                    .&lt;ServiceMetaInfo&gt;builder()</span><br><span class="line">                    .id(serviceAddress)</span><br><span class="line">                    .name(serviceMetaInfo.getServiceKey())</span><br><span class="line">                    .address(serviceAddress)</span><br><span class="line">                    .payload(serviceMetaInfo)</span><br><span class="line">                    .build();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4）SPI 增加对 ZooKeeper 的支持：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">etcd=com.yupi.yurpc.registry.EtcdRegistry</span><br><span class="line">zookeeper=com.yupi.yurpc.registry.ZooKeeperRegistry</span><br></pre></td></tr></table></figure><p>5）最后，可以更改服务提供者和消费者的注册中心配置来测试。</p><p>更改的配置如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpc.registryConfig.registry=zookeeper</span><br><span class="line">rpc.registryConfig.address=localhost:<span class="number">2181</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RPC框架开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPC开发5_注册中心基本实现</title>
      <link href="/2025/01/15/RPC%E5%BC%80%E5%8F%915_%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0/"/>
      <url>/2025/01/15/RPC%E5%BC%80%E5%8F%915_%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="一、需求分析"><a href="#一、需求分析" class="headerlink" title="一、需求分析"></a>一、需求分析</h2><p>RPC 框架的一个核心模块是注册中心，目的是帮助服务消费者获取到服务提供者的调用地址，而不是将调用地址硬编码到项目中。</p><p>本节先实现一个具有基本功能的注册中心，跑通注册中心的流程，之后再优化。</p><h2 id="二、设计方案"><a href="#二、设计方案" class="headerlink" title="二、设计方案"></a>二、设计方案</h2><h3 id="注册中心核心能力"><a href="#注册中心核心能力" class="headerlink" title="注册中心核心能力"></a>注册中心核心能力</h3><p>我们先明确注册中心的几个实现关键（核心能力）：</p><ol><li>数据分布式存储：集中的注册信息数据存储、读取和共享</li><li>服务注册：服务提供者上报服务信息到注册中心</li><li>服务发现：服务消费者从注册中心拉取服务信息</li><li>心跳检测：定期检查服务提供者的存活状态</li><li>服务注销：手动剔除节点、或者自动剔除失效节点</li><li>更多优化点：比如注册中心本身的容错、服务消费者缓存等。</li></ol><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><p>明确了注册中心的核心能力后，我们可以根据这些能力进行技术选型。</p><p>第一点是最重要的，我们首先需要一个能够集中存储和读取数据的中间件。此外，它还需要有数据过期、数据监听的能力，便于我们移除失效节点、更新节点列表等。</p><p>此外，对于注册中心的技术选型，我们还要考虑它的性能、高可用性、高可靠性、稳定性、数据一致性、社区的生态和活跃度等。注册中心的可用性和可靠性尤其重要，因为一旦注册中心本身都挂了，会影响到所有服务的调用。</p><p>主流的注册中心实现中间件有 ZooKeeper、Redis 等。这里使用一种更新颖的、更适合存储元信息（注册信息）的云原生中间件 Etcd，来实现注册中心。</p><h3 id="Etcd-入门"><a href="#Etcd-入门" class="headerlink" title="Etcd 入门"></a>Etcd 入门</h3><h4 id="Etcd-介绍"><a href="#Etcd-介绍" class="headerlink" title="Etcd 介绍"></a>Etcd 介绍</h4><p>GitHub：<a href="https://github.com/etcd-io/etcd">https://github.com/etcd-io/etcd</a></p><p>Etcd 是一个 Go 语言实现的、开源的、<strong>分布式</strong> 的键值存储系统，它主要用于分布式系统中的服务发现、配置管理和分布式锁等场景。</p><p>提到 Go 语言实现，有经验的同学应该就能想到，Etcd 的性能是很高的，而且它和云原生有着密切的关系，通常被作为云原生应用的基础设施，存储一些元信息。比如经典的容器管理平台 k8s 就使用了 Etcd 来存储集群配置信息、状态信息、节点信息等。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/03/10/67cee0989c4bd.png"></p><p>除了性能之外，Etcd 采用 Raft 一致性算法来保证数据的一致性和可靠性，具有高可用性、强一致性、分布式特性等特点。</p><p>Etcd 还非常简单易用，提供了简单的 API、数据的过期机制、数据的监听和通知机制等，完美满足注册中心的实现诉求。</p><p>Etcd 的入门成本是极低的，只要学过 Redis、ZooKeeper 或者对象存储中的一个，就能够很快理解 Etcd 并投入实战运用。</p><h4 id="Etcd-数据结构与特性"><a href="#Etcd-数据结构与特性" class="headerlink" title="Etcd 数据结构与特性"></a>Etcd 数据结构与特性</h4><p>Etcd 在其数据模型和组织结构上更接近于 ZooKeeper 和对象存储，而不是 Redis。它使用层次化的键值对来存储数据，支持类似于文件系统路径的层次结构，能够很灵活地单 key 查询、按前缀查询、按范围查询。</p><p>如下图：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/03/10/67cee0cc2dde0.png"></p><p>Etcd 的核心数据结构包括：</p><ol><li>Key（键）：Etcd 中的基本数据单元，类似于文件系统中的文件名。每个键都唯一标识一个值，并且可以包含子键，形成类似于路径的层次结构。</li><li>Value（值）：与键关联的数据，可以是任意类型的数据，通常是字符串形式。</li></ol><p>只有 key、value，比 Redis 好理解多了。我们可以将数据序列化后写入 value。</p><p>Etcd 有很多核心特性，其中，应用较多的特性是：</p><ol><li>Lease（租约）：用于对键值对进行 TTL 超时设置，即设置键值对的过期时间。当租约过期时，相关的键值对将被自动删除。</li><li>Watch（监听）：可以监视特定键的变化，当键的值发生变化时，会触发相应的通知。</li></ol><p>有了这些特性，我们就能够实现注册中心的服务提供者节点过期和监听了。</p><p>此外，Etcd 的一大优势就是能够保证数据的强一致性。</p><h4 id="Etcd-如何保证数据一致性？"><a href="#Etcd-如何保证数据一致性？" class="headerlink" title="Etcd 如何保证数据一致性？"></a>Etcd 如何保证数据一致性？</h4><p>从表层来看，Etcd 支持事务操作，能够保证数据一致性。</p><p>从底层来看，Etcd 使用 Raft 一致性算法来保证数据的一致性。</p><p>Raft 是一种分布式一致性算法，它确保了分布式系统中的所有节点在任何时间点都能达成一致的数据视图。</p><p>具体来说，Raft 算法通过选举机制选举出一个领导者（Leader）节点，领导者负责接收客户端的写请求，并将写操作复制到其他节点上。当客户端发送写请求时，领导者首先将写操作写入自己的日志中，并将写操作的日志条目分发给其他节点，其他节点收到日志后也将其写入自己的日志中。一旦 <strong>大多数节点</strong>（即半数以上的节点）都将该日志条目成功写入到自己的日志中，该日志条目就被视为已提交，领导者会向客户端发送成功响应。在领导者发送成功响应后，该写操作就被视为已提交，从而保证了数据的一致性。</p><p>如果领导者节点宕机或失去联系，Raft 算法会在其他节点中 <strong>选举出新的领导者</strong>，从而保证系统的可用性和一致性。新的领导者会继续接收客户端的写请求，并负责将写操作复制到其他节点上，从而保持数据的一致性。</p><p>可以使用官方提供的 Etcd Playground 来可视化操作 Etcd，便于学习。Playground 地址：<a href="http://play.etcd.io/play">http://play.etcd.io/play</a></p><p>比如我们可以尝试停止主节点，其余节点为从节点：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/03/10/67cee10195c80.png"></p><p>然后会发现主节点挂掉后，并没有新的从节点成为主节点，因为还剩 2 个节点，一人一票，谁都不服谁！这种现象也称为 “脑裂”。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/03/10/67cee16b6fce5.png"></p><p>然后我们启动 node4，会发现 node3 成为了主节点，因为 3 个节点，不会出现选举主节点时的平票情况。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/03/10/67cee11dbb1c6.png"></p><h4 id="Etcd-基本操作"><a href="#Etcd-基本操作" class="headerlink" title="Etcd 基本操作"></a>Etcd 基本操作</h4><p>和所有数据存储中间件一样，基本操作无非就是：增删改查。</p><p>可以用可视化界面模拟操作，比如 write 写数据（更新数据）：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/03/10/67cee1930ca3d.png"></p><p>然后读取数据：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/03/10/67cee1a5e3ec5.png"></p><p>还支持根据前缀搜索数据：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/03/10/67cee1cebffac.png"></p><p>还有一些其他操作，比如租约、监听等。</p><h4 id="Etcd-安装"><a href="#Etcd-安装" class="headerlink" title="Etcd 安装"></a>Etcd 安装</h4><p>进入 Etcd 官方的下载页：<a href="https://github.com/etcd-io/etcd/releases">https://github.com/etcd-io/etcd/releases</a></p><p>安装完成后，会得到 3 个脚本：</p><ul><li>etcd：etcd 服务本身</li><li>etcdctl：客户端，用于操作 etcd，比如读写数据</li><li>etcdutl：备份恢复工具</li></ul><p>执行 etcd 脚本后，可以启动 etcd 服务，服务默认占用 2379 和 2380 端口，作用分别如下：</p><ul><li>2379：提供 HTTP API 服务，和 etcdctl 交互</li><li>2380：集群中节点间通讯</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./img/VBfm0jl6cZzTkzHC/1728313927725-57d68d9e-62f8-4669-a82f-ffc6404221af-336360.png" alt="1709033851762-d1c8194a-9e99-411b-929d-9b47283c6369-20240309122416154.png"></p><h4 id="Etcd-可视化工具"><a href="#Etcd-可视化工具" class="headerlink" title="Etcd 可视化工具"></a>Etcd 可视化工具</h4><p>一般情况下，我们使用数据存储中间件时，一定要有一个可视化工具，能够更直观清晰地管理已经存储的数据。比如 Redis 的 Redis Desktop Manager。</p><p>同样的，Etcd 也有一些可视化工具，比如：</p><ul><li>etcdkeeper：️<a href="https://github.com/evildecay/etcdkeeper/">https://github.com/evildecay/etcdkeeper/</a></li><li>kstone：<a href="https://github.com/kstone-io/kstone/tree/master/charts">https://github.com/kstone-io/kstone/tree/master/charts</a></li></ul><p>更推荐 etcdkeeper，安装成本更低，学习使用更方便。</p><p>安装后，执行命令，可以在指定端口启动可视化界面（默认是 8080 端口），比如在 8081 端口启动。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./etcdkeeper -p <span class="number">8081</span></span><br></pre></td></tr></table></figure><p>安装后，访问本地 [<a href="http://127.0.0.1:8081/etcdkeeper/%EF%BC%8C%E5%B0%B1%E8%83%BD%E7%9C%8B%E5%88%B0%E5%8F%AF%E8%A7%86%E5%8C%96%E9%A1%B5%E9%9D%A2%E4%BA%86%E3%80%82">http://127.0.0.1:8081/etcdkeeper/，就能看到可视化页面了。</a></p><h4 id="Etcd-Java-客户端"><a href="#Etcd-Java-客户端" class="headerlink" title="Etcd Java 客户端"></a>Etcd Java 客户端</h4><p>所谓客户端，就是操作 Etcd 的工具。</p><p>etcd 主流的 Java 客户端是 jetcd：<a href="https://github.com/etcd-io/jetcd%E3%80%82">https://github.com/etcd-io/jetcd。</a></p><p><strong>注意，Java 版本必须大于 11！</strong></p><p>用法非常简单，就像 curator 能够操作 ZooKeeper、jedis 能够操作 Redis 一样。</p><p>1）首先在项目中引入 jetcd：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- https:<span class="comment">//mvnrepository.com/artifact/io.etcd/jetcd-core --&gt;</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.etcd&lt;/groupId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;artifactId&gt;jetcd-core&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">    &lt;version&gt;<span class="number">0.7</span><span class="number">.7</span>&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2）按照官方文档的示例写 Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EtcdRegistry</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">// create client using endpoints</span></span><br><span class="line">        <span class="type">Client</span> <span class="variable">client</span> <span class="operator">=</span> Client.builder().endpoints(<span class="string">&quot;http://localhost:2379&quot;</span>)</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="type">KV</span> <span class="variable">kvClient</span> <span class="operator">=</span> client.getKVClient();</span><br><span class="line">        <span class="type">ByteSequence</span> <span class="variable">key</span> <span class="operator">=</span> ByteSequence.from(<span class="string">&quot;test_key&quot;</span>.getBytes());</span><br><span class="line">        <span class="type">ByteSequence</span> <span class="variable">value</span> <span class="operator">=</span> ByteSequence.from(<span class="string">&quot;test_value&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// put the key-value</span></span><br><span class="line">        kvClient.put(key, value).get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// get the CompletableFuture</span></span><br><span class="line">        CompletableFuture&lt;GetResponse&gt; getFuture = kvClient.get(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// get the value from CompletableFuture</span></span><br><span class="line">        <span class="type">GetResponse</span> <span class="variable">response</span> <span class="operator">=</span> getFuture.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// delete the key</span></span><br><span class="line">        kvClient.delete(key).get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，我们使用 KVClient 来操作 etcd 写入和读取数据。除了 KVClient 客户端外，Etcd 还提供了很多其他客户端。</p><p>常用的客户端和作用如下：</p><ol><li>kvClient：用于对 etcd 中的键值对进行操作。通过 kvClient 可以进行设置值、获取值、删除值、列出目录等操作。</li><li>leaseClient：用于管理 etcd 的租约机制。租约是 etcd 中的一种时间片，用于为键值对分配生存时间，并在租约到期时自动删除相关的键值对。通过 leaseClient 可以创建、获取、续约和撤销租约。</li><li>watchClient：用于监视 etcd 中键的变化，并在键的值发生变化时接收通知。</li><li>clusterClient：用于与 etcd 集群进行交互，包括添加、移除、列出成员、设置选举、获取集群的健康状态、获取成员列表信息等操作。</li><li>authClient：用于管理 etcd 的身份验证和授权。通过 authClient 可以添加、删除、列出用户、角色等身份信息，以及授予或撤销用户或角色的权限。</li><li>maintenanceClient：用于执行 etcd 的维护操作，如健康检查、数据库备份、成员维护、数据库快照、数据库压缩等。</li><li>lockClient：用于实现分布式锁功能，通过 lockClient 可以在 etcd 上创建、获取、释放锁，能够轻松实现并发控制。</li><li>electionClient：用于实现分布式选举功能，可以在 etcd 上创建选举、提交选票、监视选举结果等。</li></ol><p>绝大多数情况下，用前 3 个客户端就足够了。</p><p>3）使用 Debug 执行上述代码，观察 Etcd 的数据结构。</p><p>发现除了 key 和 value 外，还能看到版本、创建版本、修改版本字段。这是因为 etcd 中的每个键都有一个与之关联的版本号，用于跟踪键的修改历史。当一个键的值发生变化时，其版本号也会增加。</p><p>通过使用 etcd 的 Watch API，可以监视键的变化，并在发生变化时接收通知。这种版本机制使得 etcd 在分布式系统中能够实现乐观并发控制、一致性和可靠性的数据访问。</p><hr><p>了解了 Etcd 的基础用法后，我们还要设计服务注册信息如何存储在注册中心内。</p><h3 id="存储结构设计"><a href="#存储结构设计" class="headerlink" title="存储结构设计"></a>存储结构设计</h3><p>存储结构设计的几个要点：</p><ol><li>key 如何设计？</li><li>value 如何设计？</li><li>key 什么时候过期？</li></ol><p>由于一个服务可能有多个服务提供者（负载均衡），我们可以有两种结构设计：</p><p>1）层级结构。将服务理解为文件夹、将服务对应的多个节点理解为文件夹下的文件，那么可以通过服务名称，用前缀查询的方式查询到某个服务的所有节点。</p><p>键名的规则可以是 <code>/业务前缀/服务名/服务节点地址</code>：</p><p>2）列表结构。将所有的服务节点以列表的形式整体作为 value。</p><p>选择哪种存储结构？这个也会跟技术选型有关。对于 ZooKeeper 和 Etcd 这种支持层级查询的中间件，用第一种结构会更清晰；对于 Redis，由于本身就支持列表数据结构，可以选择第二种结构。</p><p>最后，一定要给 key 设置过期时间，比如默认 30 秒过期，这样如果服务提供者宕机了，也可以超时后自动移除。</p><p>做好整体的方案设计后，下面开发实现。</p><h2 id="三、开发实现"><a href="#三、开发实现" class="headerlink" title="三、开发实现"></a>三、开发实现</h2><h3 id="1、注册中心开发"><a href="#1、注册中心开发" class="headerlink" title="1、注册中心开发"></a>1、注册中心开发</h3><p>1）注册信息定义。</p><p>在 model 包下新建 <code>ServiceMetaInfo</code> 类，封装服务的注册信息，包括服务名称、服务版本号、服务地址（域名和端口号）、服务分组等。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务元信息（注册信息）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceMetaInfo</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String serviceName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务版本号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">serviceVersion</span> <span class="operator">=</span> <span class="string">&quot;1.0&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务域名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String serviceHost;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务端口号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer servicePort;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务分组（暂未实现）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">serviceGroup</span> <span class="operator">=</span> <span class="string">&quot;default&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要给 <code>ServiceMetaInfo</code> 增加一些工具方法，用于获取服务注册键名、获取服务注册节点键名等。</p><p>可以把版本号和分组都放到服务键名中，就可以在查询时根据这些参数获取对应版本和分组的服务了。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取服务键名</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getServiceKey</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 后续可扩展服务分组</span></span><br><span class="line">    <span class="comment">// return String.format(&quot;%s:%s:%s&quot;, serviceName, serviceVersion, serviceGroup);</span></span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">&quot;%s:%s&quot;</span>, serviceName, serviceVersion);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取服务注册节点键名</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getServiceNodeKey</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">&quot;%s/%s:%s&quot;</span>, getServiceKey(), serviceHost, servicePort);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于注册信息里包含了服务版本号字段，所以我们也可以给 RpcRequest 对象补充服务版本号字段，可以先作为预留字段，默认值为 “1.0”，后续再自行实现。</p><p>在 RpcConstant 常量类中补充默认服务版本常量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RPC 相关常量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RpcConstant</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认配置文件加载前缀</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">DEFAULT_CONFIG_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;rpc&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认服务版本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">DEFAULT_SERVICE_VERSION</span> <span class="operator">=</span> <span class="string">&quot;1.0&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 RpcRequest 请求类中使用该常量，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RPC 请求</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href=&quot;https://github.com/liyupi&quot;&gt;程序员鱼皮&lt;/a&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@learn</span> &lt;a href=&quot;https://codefather.cn&quot;&gt;编程宝典&lt;/a&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@from</span> &lt;a href=&quot;https://yupi.icu&quot;&gt;编程导航知识星球&lt;/a&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcRequest</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String serviceName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务版本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">serviceVersion</span> <span class="operator">=</span> RpcConstant.DEFAULT_SERVICE_VERSION;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数类型列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] parameterTypes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object[] args;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）注册中心配置。</p><p>在 config 包下编写注册中心配置类 <code>RegistryConfig</code>，让用户配置连接注册中心所需的信息，比如注册中心类别、注册中心地址、用户名、密码、连接超时时间等。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RPC 框架注册中心配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegistryConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册中心类别</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">registry</span> <span class="operator">=</span> <span class="string">&quot;etcd&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册中心地址</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">address</span> <span class="operator">=</span> <span class="string">&quot;http://localhost:2380&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 密码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 超时时间（单位毫秒）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Long</span> <span class="variable">timeout</span> <span class="operator">=</span> <span class="number">10000L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还要为 RpcConfig 全局配置补充注册中心配置，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcConfig</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册中心配置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">RegistryConfig</span> <span class="variable">registryConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RegistryConfig</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）注册中心接口。</p><p>遵循可扩展设计，我们先写一个注册中心接口，后续可以实现多种不同的注册中心，并且和序列化器一样，可以使用 SPI 机制动态加载。</p><p>注册中心接口代码如下，主要是提供了初始化、注册服务、注销服务、服务发现（获取服务节点列表）、服务销毁等方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注册中心</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href=&quot;https://github.com/liyupi&quot;&gt;程序员鱼皮&lt;/a&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@learn</span> &lt;a href=&quot;https://codefather.cn&quot;&gt;编程宝典&lt;/a&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@from</span> &lt;a href=&quot;https://yupi.icu&quot;&gt;编程导航知识星球&lt;/a&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Registry</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registryConfig</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(RegistryConfig registryConfig)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册服务（服务端）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceMetaInfo</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(ServiceMetaInfo serviceMetaInfo)</span> <span class="keyword">throws</span> Exception;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注销服务（服务端）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceMetaInfo</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">unRegister</span><span class="params">(ServiceMetaInfo serviceMetaInfo)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务发现（获取某服务的所有节点，消费端）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceKey 服务键名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;ServiceMetaInfo&gt; <span class="title function_">serviceDiscovery</span><span class="params">(String serviceKey)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务销毁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4）Etcd 注册中心实现。</p><p>在 registry 目录下新建 <code>EtcdRegistry</code> 类，实现注册中心接口，先完成初始化方法，读取注册中心配置并初始化客户端对象。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EtcdRegistry</span> <span class="keyword">implements</span> <span class="title class_">Registry</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Client client;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> KV kvClient;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ETCD_ROOT_PATH</span> <span class="operator">=</span> <span class="string">&quot;/rpc/&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(RegistryConfig registryConfig)</span> &#123;</span><br><span class="line">        client = Client.builder().endpoints(registryConfig.getAddress()).connectTimeout(Duration.ofMillis(registryConfig.getTimeout())).build();</span><br><span class="line">        kvClient = client.getKVClient();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，我们定义 Etcd 键存储的根路径为 <code>/rpc/</code>，为了区分不同的项目。</p><p>依次实现不同的方法，首先是服务注册，创建 key 并设置过期时间，value 为服务注册信息的 JSON 序列化。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(ServiceMetaInfo serviceMetaInfo)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 创建 Lease 和 KV 客户端</span></span><br><span class="line">    <span class="type">Lease</span> <span class="variable">leaseClient</span> <span class="operator">=</span> client.getLeaseClient();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个 30 秒的租约</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">leaseId</span> <span class="operator">=</span> leaseClient.grant(<span class="number">30</span>).get().getID();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置要存储的键值对</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">registerKey</span> <span class="operator">=</span> ETCD_ROOT_PATH + serviceMetaInfo.getServiceNodeKey();</span><br><span class="line">    <span class="type">ByteSequence</span> <span class="variable">key</span> <span class="operator">=</span> ByteSequence.from(registerKey, StandardCharsets.UTF_8);</span><br><span class="line">    <span class="type">ByteSequence</span> <span class="variable">value</span> <span class="operator">=</span> ByteSequence.from(JSONUtil.toJsonStr(serviceMetaInfo), StandardCharsets.UTF_8);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将键值对与租约关联起来，并设置过期时间</span></span><br><span class="line">    <span class="type">PutOption</span> <span class="variable">putOption</span> <span class="operator">=</span> PutOption.builder().withLeaseId(leaseId).build();</span><br><span class="line">    kvClient.put(key, value, putOption).get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是服务注销，删除 key：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unRegister</span><span class="params">(ServiceMetaInfo serviceMetaInfo)</span> &#123;</span><br><span class="line">    kvClient.delete(ByteSequence.from(ETCD_ROOT_PATH + serviceMetaInfo.getServiceNodeKey(), StandardCharsets.UTF_8));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是服务发现，根据服务名称作为前缀，从 Etcd 获取服务下的节点列表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;ServiceMetaInfo&gt; <span class="title function_">serviceDiscovery</span><span class="params">(String serviceKey)</span> &#123;</span><br><span class="line">    <span class="comment">// 前缀搜索，结尾一定要加 &#x27;/&#x27;</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">searchPrefix</span> <span class="operator">=</span> ETCD_ROOT_PATH + serviceKey + <span class="string">&quot;/&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 前缀查询</span></span><br><span class="line">        <span class="type">GetOption</span> <span class="variable">getOption</span> <span class="operator">=</span> GetOption.builder().isPrefix(<span class="literal">true</span>).build();</span><br><span class="line">        List&lt;KeyValue&gt; keyValues = kvClient.get(</span><br><span class="line">                        ByteSequence.from(searchPrefix, StandardCharsets.UTF_8),</span><br><span class="line">                        getOption)</span><br><span class="line">                .get()</span><br><span class="line">                .getKvs();</span><br><span class="line">        <span class="comment">// 解析服务信息</span></span><br><span class="line">        <span class="keyword">return</span> keyValues.stream()</span><br><span class="line">                .map(keyValue -&gt; &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> keyValue.getValue().toString(StandardCharsets.UTF_8);</span><br><span class="line">                    <span class="keyword">return</span> JSONUtil.toBean(value, ServiceMetaInfo.class);</span><br><span class="line">                &#125;)</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;获取服务列表失败&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是注册中心销毁，用于项目关闭后释放资源：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;当前节点下线&quot;</span>);</span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    <span class="keyword">if</span> (kvClient != <span class="literal">null</span>) &#123;</span><br><span class="line">        kvClient.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (client != <span class="literal">null</span>) &#123;</span><br><span class="line">        client.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册中心实现类的完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EtcdRegistry</span> <span class="keyword">implements</span> <span class="title class_">Registry</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Client client;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> KV kvClient;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ETCD_ROOT_PATH</span> <span class="operator">=</span> <span class="string">&quot;/rpc/&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(RegistryConfig registryConfig)</span> &#123;</span><br><span class="line">        client = Client.builder().endpoints(registryConfig.getAddress()).connectTimeout(Duration.ofMillis(registryConfig.getTimeout())).build();</span><br><span class="line">        kvClient = client.getKVClient();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(ServiceMetaInfo serviceMetaInfo)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 创建 Lease 和 KV 客户端</span></span><br><span class="line">        <span class="type">Lease</span> <span class="variable">leaseClient</span> <span class="operator">=</span> client.getLeaseClient();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个 30 秒的租约</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">leaseId</span> <span class="operator">=</span> leaseClient.grant(<span class="number">30</span>).get().getID();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置要存储的键值对</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">registerKey</span> <span class="operator">=</span> ETCD_ROOT_PATH + serviceMetaInfo.getServiceNodeKey();</span><br><span class="line">        <span class="type">ByteSequence</span> <span class="variable">key</span> <span class="operator">=</span> ByteSequence.from(registerKey, StandardCharsets.UTF_8);</span><br><span class="line">        <span class="type">ByteSequence</span> <span class="variable">value</span> <span class="operator">=</span> ByteSequence.from(JSONUtil.toJsonStr(serviceMetaInfo), StandardCharsets.UTF_8);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将键值对与租约关联起来，并设置过期时间</span></span><br><span class="line">        <span class="type">PutOption</span> <span class="variable">putOption</span> <span class="operator">=</span> PutOption.builder().withLeaseId(leaseId).build();</span><br><span class="line">        kvClient.put(key, value, putOption).get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unRegister</span><span class="params">(ServiceMetaInfo serviceMetaInfo)</span> &#123;</span><br><span class="line">        kvClient.delete(ByteSequence.from(ETCD_ROOT_PATH + serviceMetaInfo.getServiceNodeKey(), StandardCharsets.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;ServiceMetaInfo&gt; <span class="title function_">serviceDiscovery</span><span class="params">(String serviceKey)</span> &#123;</span><br><span class="line">        <span class="comment">// 前缀搜索，结尾一定要加 &#x27;/&#x27;</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">searchPrefix</span> <span class="operator">=</span> ETCD_ROOT_PATH + serviceKey + <span class="string">&quot;/&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 前缀查询</span></span><br><span class="line">            <span class="type">GetOption</span> <span class="variable">getOption</span> <span class="operator">=</span> GetOption.builder().isPrefix(<span class="literal">true</span>).build();</span><br><span class="line">            List&lt;KeyValue&gt; keyValues = kvClient.get(</span><br><span class="line">                            ByteSequence.from(searchPrefix, StandardCharsets.UTF_8),</span><br><span class="line">                            getOption)</span><br><span class="line">                    .get()</span><br><span class="line">                    .getKvs();</span><br><span class="line">            <span class="comment">// 解析服务信息</span></span><br><span class="line">            <span class="keyword">return</span> keyValues.stream()</span><br><span class="line">                    .map(keyValue -&gt; &#123;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> keyValue.getValue().toString(StandardCharsets.UTF_8);</span><br><span class="line">                        <span class="keyword">return</span> JSONUtil.toBean(value, ServiceMetaInfo.class);</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .collect(Collectors.toList());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;获取服务列表失败&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;当前节点下线&quot;</span>);</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        <span class="keyword">if</span> (kvClient != <span class="literal">null</span>) &#123;</span><br><span class="line">            kvClient.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (client != <span class="literal">null</span>) &#123;</span><br><span class="line">            client.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、支持配置和扩展注册中心"><a href="#2、支持配置和扩展注册中心" class="headerlink" title="2、支持配置和扩展注册中心"></a>2、支持配置和扩展注册中心</h3><p>一个成熟的 RPC 框架可能会支持多个注册中心，像序列化器一样，我们的需求是，让开发者能够填写配置来指定使用的注册中心，并且支持自定义注册中心，让框架更易用、更利于扩展。</p><p>要实现这点，开发方式和序列化器也是一样的，都可以使用工厂创建对象、使用 SPI 动态加载自定义的注册中心。</p><p>1）注册中心常量。</p><p>在 registry 包下新建 <code>RegistryKeys</code> 类，列举所有支持的注册中心键名。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注册中心键名常量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RegistryKeys</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">ETCD</span> <span class="operator">=</span> <span class="string">&quot;etcd&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">ZOOKEEPER</span> <span class="operator">=</span> <span class="string">&quot;zookeeper&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）使用工厂模式，支持根据 key 从 SPI 获取注册中心对象实例。</p><p>在 registry 包下新建 <code>RegistryFactory</code> 类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注册中心工厂（用于获取注册中心对象）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href=&quot;https://github.com/liyupi&quot;&gt;程序员鱼皮&lt;/a&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@learn</span> &lt;a href=&quot;https://codefather.cn&quot;&gt;编程宝典&lt;/a&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@from</span> &lt;a href=&quot;https://yupi.icu&quot;&gt;编程导航知识星球&lt;/a&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegistryFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        SpiLoader.load(Registry.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认注册中心</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Registry</span> <span class="variable">DEFAULT_REGISTRY</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EtcdRegistry</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取实例</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Registry <span class="title function_">getInstance</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SpiLoader.getInstance(Registry.class, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类可以直接复制之前的 SerializerFactory，然后略做修改。可以发现，只要跑通了 SPI 机制，后续的开发就很简单了~</p><p>3）在 <code>META-INF</code> 的 <code>rpc/system</code> 目录下编写注册中心接口的 SPI 配置文件，文件名称为 <code>com.yupi.yurpc.registry.Registry</code>。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">etcd=com.yupi.yurpc.registry.EtcdRegistry</span><br></pre></td></tr></table></figure><p>4）最后，我们需要一个位置来初始化注册中心。由于服务提供者和服务消费者都需要和注册中心建立连接，是一个 RPC 框架启动必不可少的环节，所以可以将初始化流程放在 <code>RpcApplication</code> 类中。</p><p>修改其 <code>init</code> 方法代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 框架初始化，支持传入自定义配置</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> newRpcConfig</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(RpcConfig newRpcConfig)</span> &#123;</span><br><span class="line">    rpcConfig = newRpcConfig;</span><br><span class="line">    log.info(<span class="string">&quot;rpc init, config = &#123;&#125;&quot;</span>, newRpcConfig.toString());</span><br><span class="line">    <span class="comment">// 注册中心初始化</span></span><br><span class="line">    <span class="type">RegistryConfig</span> <span class="variable">registryConfig</span> <span class="operator">=</span> rpcConfig.getRegistryConfig();</span><br><span class="line">    <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> RegistryFactory.getInstance(registryConfig.getRegistry());</span><br><span class="line">    registry.init(registryConfig);</span><br><span class="line">    log.info(<span class="string">&quot;registry init, config = &#123;&#125;&quot;</span>, registryConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、完成调用流程"><a href="#3、完成调用流程" class="headerlink" title="3、完成调用流程"></a>3、完成调用流程</h3><p>下面我们要改造服务消费者调用服务的代码，跑通整个动态获取节点并调用的流程。</p><p>1）服务消费者需要先从注册中心获取节点信息，再得到调用地址并执行。</p><p>需要给 <code>ServiceMetaInfo</code> 类增加一个方法，便于获取可调用的地址，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取完整服务地址</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getServiceAddress</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!StrUtil.contains(serviceHost, <span class="string">&quot;http&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(<span class="string">&quot;http://%s:%s&quot;</span>, serviceHost, servicePort);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> String.format(<span class="string">&quot;%s:%s&quot;</span>, serviceHost, servicePort);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）修改服务代理 <code>ServiceProxy</code> 类，更改调用逻辑。</p><p>修改的部分代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化</span></span><br><span class="line"><span class="type">byte</span>[] bodyBytes = serializer.serialize(rpcRequest);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从注册中心获取服务提供者请求地址</span></span><br><span class="line"><span class="type">RpcConfig</span> <span class="variable">rpcConfig</span> <span class="operator">=</span> RpcApplication.getRpcConfig();</span><br><span class="line"><span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> RegistryFactory.getInstance(rpcConfig.getRegistryConfig().getRegistry());</span><br><span class="line"><span class="type">ServiceMetaInfo</span> <span class="variable">serviceMetaInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceMetaInfo</span>();</span><br><span class="line">serviceMetaInfo.setServiceName(serviceName);</span><br><span class="line">serviceMetaInfo.setServiceVersion(RpcConstant.DEFAULT_SERVICE_VERSION);</span><br><span class="line">List&lt;ServiceMetaInfo&gt; serviceMetaInfoList = registry.serviceDiscovery(serviceMetaInfo.getServiceKey());</span><br><span class="line"><span class="keyword">if</span> (CollUtil.isEmpty(serviceMetaInfoList)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;暂无服务地址&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 暂时先取第一个</span></span><br><span class="line"><span class="type">ServiceMetaInfo</span> <span class="variable">selectedServiceMetaInfo</span> <span class="operator">=</span> serviceMetaInfoList.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送请求</span></span><br><span class="line"><span class="keyword">try</span> (<span class="type">HttpResponse</span> <span class="variable">httpResponse</span> <span class="operator">=</span> HttpRequest.post(selectedServiceMetaInfo.getServiceAddress())</span><br><span class="line">        .body(bodyBytes)</span><br><span class="line">        .execute()) &#123;</span><br><span class="line">    <span class="type">byte</span>[] result = httpResponse.bodyBytes();</span><br><span class="line">    <span class="comment">// 反序列化</span></span><br><span class="line">    <span class="type">RpcResponse</span> <span class="variable">rpcResponse</span> <span class="operator">=</span> serializer.deserialize(result, RpcResponse.class);</span><br><span class="line">    <span class="keyword">return</span> rpcResponse.getData();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>注意，从注册中心获取到的服务节点地址可能是多个。上述代码中，我们为了方便，暂时先取第一个，之后会带大家对这里的代码进行优化。</p><p><code>ServiceProxy</code> 的完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务代理（JDK 动态代理）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href=&quot;https://github.com/liyupi&quot;&gt;程序员鱼皮&lt;/a&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@learn</span> &lt;a href=&quot;https://codefather.cn&quot;&gt;编程宝典&lt;/a&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@from</span> &lt;a href=&quot;https://yupi.icu&quot;&gt;编程导航知识星球&lt;/a&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用代理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 指定序列化器</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Serializer</span> <span class="variable">serializer</span> <span class="operator">=</span> SerializerFactory.getInstance(RpcApplication.getRpcConfig().getSerializer());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造请求</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">serviceName</span> <span class="operator">=</span> method.getDeclaringClass().getName();</span><br><span class="line">        <span class="type">RpcRequest</span> <span class="variable">rpcRequest</span> <span class="operator">=</span> RpcRequest.builder()</span><br><span class="line">                .serviceName(serviceName)</span><br><span class="line">                .methodName(method.getName())</span><br><span class="line">                .parameterTypes(method.getParameterTypes())</span><br><span class="line">                .args(args)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 序列化</span></span><br><span class="line">            <span class="type">byte</span>[] bodyBytes = serializer.serialize(rpcRequest);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 从注册中心获取服务提供者请求地址</span></span><br><span class="line">            <span class="type">RpcConfig</span> <span class="variable">rpcConfig</span> <span class="operator">=</span> RpcApplication.getRpcConfig();</span><br><span class="line">            <span class="type">Registry</span> <span class="variable">registry</span> <span class="operator">=</span> RegistryFactory.getInstance(rpcConfig.getRegistryConfig().getRegistry());</span><br><span class="line">            <span class="type">ServiceMetaInfo</span> <span class="variable">serviceMetaInfo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceMetaInfo</span>();</span><br><span class="line">            serviceMetaInfo.setServiceName(serviceName);</span><br><span class="line">            serviceMetaInfo.setServiceVersion(RpcConstant.DEFAULT_SERVICE_VERSION);</span><br><span class="line">            List&lt;ServiceMetaInfo&gt; serviceMetaInfoList = registry.serviceDiscovery(serviceMetaInfo.getServiceKey());</span><br><span class="line">            <span class="keyword">if</span> (CollUtil.isEmpty(serviceMetaInfoList)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;暂无服务地址&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ServiceMetaInfo</span> <span class="variable">selectedServiceMetaInfo</span> <span class="operator">=</span> serviceMetaInfoList.get(<span class="number">0</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 发送请求</span></span><br><span class="line">            <span class="keyword">try</span> (<span class="type">HttpResponse</span> <span class="variable">httpResponse</span> <span class="operator">=</span> HttpRequest.post(selectedServiceMetaInfo.getServiceAddress())</span><br><span class="line">                    .body(bodyBytes)</span><br><span class="line">                    .execute()) &#123;</span><br><span class="line">                <span class="type">byte</span>[] result = httpResponse.bodyBytes();</span><br><span class="line">                <span class="comment">// 反序列化</span></span><br><span class="line">                <span class="type">RpcResponse</span> <span class="variable">rpcResponse</span> <span class="operator">=</span> serializer.deserialize(result, RpcResponse.class);</span><br><span class="line">                <span class="keyword">return</span> rpcResponse.getData();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RPC框架开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPC开发4_序列化器与SPI机制</title>
      <link href="/2025/01/13/RPC%E5%BC%80%E5%8F%914_%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8%E4%B8%8ESPI%E6%9C%BA%E5%88%B6/"/>
      <url>/2025/01/13/RPC%E5%BC%80%E5%8F%914_%E5%BA%8F%E5%88%97%E5%8C%96%E5%99%A8%E4%B8%8ESPI%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="一、需求分析"><a href="#一、需求分析" class="headerlink" title="一、需求分析"></a>一、需求分析</h2><p>前面已经讨论过序列化器的作用：无论是请求或响应，都会涉及参数的传输。而 Java 对象是存活在 JVM 虚拟机中的，如果想在其他位置存储并访问、或者在网络中进行传输，就需要进行序列化和反序列化。</p><p>此外还编写了通用的序列化器接口，并且已经实现了基于 Java 原生序列化的序列化器。但是对于一个完善的 RPC 框架，我们还要思考以下 3 个问题：</p><ol><li>有没有更好的序列化器实现方式？</li><li>如何让使用框架的开发者指定使用的序列化器？</li><li>如何让使用框架的开发者自己定制序列化器？</li></ol><h2 id="二、设计方案"><a href="#二、设计方案" class="headerlink" title="二、设计方案"></a>二、设计方案</h2><p>依次分析这三个问题的实现方案。</p><h3 id="1、序列化器实现方式"><a href="#1、序列化器实现方式" class="headerlink" title="1、序列化器实现方式"></a>1、序列化器实现方式</h3><p>我们所追求的 “更好的” 序列化器，可以是具有更高的性能、或者更小的序列化结果，这样就能够更快地完成 RPC 的请求和响应。</p><p>之前是为了方便，我们使用 Java 原生序列化实现序列化器，但这未必是最好的。市面上还有很多种主流的序列化方式，比如 JSON、Hessian、Kryo、protobuf 等。</p><p>下面简单列举它们的优缺点：</p><h4 id="主流序列化方式对比"><a href="#主流序列化方式对比" class="headerlink" title="主流序列化方式对比"></a>主流序列化方式对比</h4><p>1）JSON</p><p>优点：</p><ul><li>易读性好，可读性强，便于人类理解和调试。</li><li>跨语言支持广泛，几乎所有编程语言都有 JSON 的解析和生成库。</li></ul><p>缺点：</p><ul><li>序列化后的数据量相对较大，因为 JSON 使用文本格式存储数据，需要额外的字符表示键、值和数据结构。</li><li>不能很好地处理复杂的数据结构和循环引用，可能导致性能下降或者序列化失败。</li></ul><p>2）Hessian：<a href="https://hessian.caucho.com/">https://hessian.caucho.com/</a></p><p>优点：</p><ul><li>二进制序列化，序列化后的数据量较小，网络传输效率高。</li><li>支持跨语言，适用于分布式系统中的服务调用。</li></ul><p>缺点：</p><ul><li>性能较 JSON 略低，因为需要将对象转换为二进制格式。</li><li>对象必须实现 Serializable 接口，限制了可序列化的对象范围。</li></ul><p>3）Kryo：<a href="https://github.com/EsotericSoftware/kryo">https://github.com/EsotericSoftware/kryo</a></p><p>优点：</p><ul><li>高性能，序列化和反序列化速度快。</li><li>支持循环引用和自定义序列化器，适用于复杂的对象结构。</li><li>无需实现 Serializable 接口，可以序列化任意对象。</li></ul><p>缺点：</p><ul><li>不跨语言，只适用于 Java。</li><li>对象的序列化格式不够友好，不易读懂和调试。</li></ul><p>4）Protobuf：</p><p>优点：</p><ul><li>高效的二进制序列化，序列化后的数据量极小。</li><li>跨语言支持，并且提供了多种语言的实现库。</li><li>支持版本化和向前 &#x2F; 向后兼容性。</li></ul><p>缺点：</p><ul><li>配置相对复杂，需要先定义数据结构的消息格式。</li><li>对象的序列化格式不易读懂，不便于调试。</li></ul><p>这几种序列化方式中最熟悉的莫过于 JSON 了，下面会实现 JSON、Kryo 和 Hessian 这三种序列化器。</p><h3 id="2、动态使用序列化器"><a href="#2、动态使用序列化器" class="headerlink" title="2、动态使用序列化器"></a>2、动态使用序列化器</h3><p>之前我们是在代码中硬编码了序列化器，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Serializer</span> <span class="variable">serializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdkSerializer</span>();</span><br></pre></td></tr></table></figure><p>如果开发者想要替换为别的序列化器，就必须修改所有的上述代码，太麻烦了！</p><p>理想情况下，应该可以通过配置文件来指定使用的序列化器。在使用序列化器时，根据配置来获取不同的序列化器实例即可。</p><p>参考 Dubbo 替换序列化协议的方式：<a href="https://cn.dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/serialization/hessian/">https://cn.dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/serialization/hessian/</a></p><p>这个操作并不难，我们只需要定义一个 <code>序列化器名称 =&gt; 序列化器实现类对象</code> 的 Map，然后根据名称从 Map 中获取对象即可。</p><h3 id="3、自定义序列化器"><a href="#3、自定义序列化器" class="headerlink" title="3、自定义序列化器"></a>3、自定义序列化器</h3><p>如果开发者不想使用我们框架内置的序列化器，想要自己定义一个新的序列化器实现，但不能修改我们写好的框架代码，应该怎么办呢？</p><p>思路很简单：只要我们的 RPC 框架能够读取到用户自定义的类路径，然后加载这个类，作为 Serializer 序列化器接口的实现即可。</p><p>但是如何实现这个操作呢？</p><p>这就需要我们学习一个新的概念，也是 Java 中的重要特性 —— SPI 机制。</p><h4 id="什么是-SPI？"><a href="#什么是-SPI？" class="headerlink" title="什么是 SPI？"></a>什么是 SPI？</h4><p>SPI（Service Provider Interface）服务提供接口是 Java 的机制，主要用于实现模块化开发和插件化扩展。</p><p>SPI 机制允许服务提供者通过特定的配置文件将自己的实现注册到系统中，然后系统通过反射机制动态加载这些实现，而不需要修改原始框架的代码，从而实现了系统的解耦、提高了可扩展性。</p><p>一个典型的 SPI 应用场景是 JDBC（Java 数据库连接库），不同的数据库驱动程序开发者可以使用 JDBC 库，然后定制自己的数据库驱动程序。</p><p>此外，我们使用的主流 Java 开发框架中，几乎都使用到了 SPI 机制，比如 Servlet 容器、日志框架、ORM 框架、Spring 框架。<strong>所以这是 Java 开发者必须掌握的一个重要特性！</strong></p><h4 id="如何实现-SPI？"><a href="#如何实现-SPI？" class="headerlink" title="如何实现 SPI？"></a>如何实现 SPI？</h4><p>分为系统实现和自定义实现。</p><h5 id="系统实现"><a href="#系统实现" class="headerlink" title="系统实现"></a>系统实现</h5><p>其实 Java 内已经提供了 SPI 机制相关的 API 接口，可以直接使用，这种方式最简单。</p><p>1）首先在 <code>resources</code> 资源目录下创建 <code>META-INF/services</code> 目录，并且创建一个名称为要实现的接口的空文件。</p><p>2）在文件中填写自己定制的接口实现类的 <strong>完整类路径</strong>。</p><p>3）直接使用系统内置的 ServiceLoader 动态加载指定接口的实现类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定序列化器</span></span><br><span class="line"><span class="type">Serializer</span> <span class="variable">serializer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">ServiceLoader&lt;Serializer&gt; serviceLoader = ServiceLoader.load(Serializer.class);</span><br><span class="line"><span class="keyword">for</span> (Serializer service : serviceLoader) &#123;</span><br><span class="line">    serializer = service;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码能够获取到所有文件中编写的实现类对象，选择一个使用即可。</p><h5 id="自定义-SPI-实现"><a href="#自定义-SPI-实现" class="headerlink" title="自定义 SPI 实现"></a>自定义 SPI 实现</h5><p>系统实现 SPI 虽然简单，但是如果我们想定制多个不同的接口实现类，就没办法在框架中指定使用哪一个了，也就无法实现我们 “通过配置快速指定序列化器” 的需求。</p><p>所以我们需要自己定义 SPI 机制的实现，只要能够根据配置加载到类即可。</p><p>比如读取如下配置文件，能够得到一个 <code>序列化器名称 =&gt; 序列化器实现类对象</code> 的映射，之后就可以根据用户配置的序列化器名称动态加载指定实现类对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdk=com.yupi.yurpc.serializer.JdkSerializer</span><br><span class="line">hessian=com.yupi.yurpc.serializer.HessianSerializer</span><br><span class="line">json=com.yupi.yurpc.serializer.JsonSerializer</span><br><span class="line">kryo=com.yupi.yurpc.serializer.KryoSerializer</span><br></pre></td></tr></table></figure><h2 id="三、开发实现"><a href="#三、开发实现" class="headerlink" title="三、开发实现"></a>三、开发实现</h2><h3 id="1、多种序列化器实现"><a href="#1、多种序列化器实现" class="headerlink" title="1、多种序列化器实现"></a>1、多种序列化器实现</h3><p>我们要分别实现 JSON、Kryo 和 Hessian 这三种主流的序列化器。</p><p>1）首先给项目的 pom.xml 中引入依赖：</p><p>2）然后在序列化器包 <code>serializer</code> 中分别实现这三种序列化器。</p><h4 id="JSON-序列化器"><a href="#JSON-序列化器" class="headerlink" title="JSON 序列化器"></a>JSON 序列化器</h4><p>JSON 序列化器的实现相对复杂，要考虑一些对象转换的兼容性问题，比如 Object 数组在序列化后会丢失类型。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Json 序列化器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href=&quot;https://github.com/liyupi&quot;&gt;程序员鱼皮&lt;/a&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@learn</span> &lt;a href=&quot;https://codefather.cn&quot;&gt;编程宝典&lt;/a&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@from</span> &lt;a href=&quot;https://yupi.icu&quot;&gt;编程导航知识星球&lt;/a&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JsonSerializer</span> <span class="keyword">implements</span> <span class="title class_">Serializer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ObjectMapper</span> <span class="variable">OBJECT_MAPPER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="type">byte</span>[] serialize(T obj) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">return</span> OBJECT_MAPPER.writeValueAsBytes(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(<span class="type">byte</span>[] bytes, Class&lt;T&gt; classType)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">obj</span> <span class="operator">=</span> OBJECT_MAPPER.readValue(bytes, classType);</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> RpcRequest) &#123;</span><br><span class="line">            <span class="keyword">return</span> handleRequest((RpcRequest) obj, classType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> RpcResponse) &#123;</span><br><span class="line">            <span class="keyword">return</span> handleResponse((RpcResponse) obj, classType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 由于 Object 的原始对象会被擦除，导致反序列化时会被作为 LinkedHashMap 无法转换成原始对象，因此这里做了特殊处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rpcRequest rpc 请求</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type       类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> T&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException IO异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; T <span class="title function_">handleRequest</span><span class="params">(RpcRequest rpcRequest, Class&lt;T&gt; type)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        Class&lt;?&gt;[] parameterTypes = rpcRequest.getParameterTypes();</span><br><span class="line">        Object[] args = rpcRequest.getArgs();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环处理每个参数的类型</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; parameterTypes.length; i++) &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = parameterTypes[i];</span><br><span class="line">            <span class="comment">// 如果类型不同，则重新处理一下类型</span></span><br><span class="line">            <span class="keyword">if</span> (!clazz.isAssignableFrom(args[i].getClass())) &#123;</span><br><span class="line">                <span class="type">byte</span>[] argBytes = OBJECT_MAPPER.writeValueAsBytes(args[i]);</span><br><span class="line">                args[i] = OBJECT_MAPPER.readValue(argBytes, clazz);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> type.cast(rpcRequest);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 由于 Object 的原始对象会被擦除，导致反序列化时会被作为 LinkedHashMap 无法转换成原始对象，因此这里做了特殊处理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rpcResponse rpc 响应</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type        类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> T&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException IO异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; T <span class="title function_">handleResponse</span><span class="params">(RpcResponse rpcResponse, Class&lt;T&gt; type)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 处理响应数据</span></span><br><span class="line">        <span class="type">byte</span>[] dataBytes = OBJECT_MAPPER.writeValueAsBytes(rpcResponse.getData());</span><br><span class="line">        rpcResponse.setData(OBJECT_MAPPER.readValue(dataBytes, rpcResponse.getDataType()));</span><br><span class="line">        <span class="keyword">return</span> type.cast(rpcResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Kryo-序列化器"><a href="#Kryo-序列化器" class="headerlink" title="Kryo 序列化器"></a>Kryo 序列化器</h4><p>Kryo 本身是线程不安全的，所以需要使用 ThreadLocal 保证每个线程有一个单独的 Kryo 对象实例。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Kryo 序列化器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href=&quot;https://github.com/liyupi&quot;&gt;程序员鱼皮&lt;/a&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@learn</span> &lt;a href=&quot;https://codefather.cn&quot;&gt;编程宝典&lt;/a&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@from</span> &lt;a href=&quot;https://yupi.icu&quot;&gt;编程导航知识星球&lt;/a&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KryoSerializer</span> <span class="keyword">implements</span> <span class="title class_">Serializer</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * kryo 线程不安全，使用 ThreadLocal 保证每个线程只有一个 Kryo</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Kryo&gt; KRYO_THREAD_LOCAL = ThreadLocal.withInitial(() -&gt; &#123;</span><br><span class="line">        <span class="type">Kryo</span> <span class="variable">kryo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Kryo</span>();</span><br><span class="line">        <span class="comment">// 设置动态动态序列化和反序列化类，不提前注册所有类（可能有安全问题）</span></span><br><span class="line">        kryo.setRegistrationRequired(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> kryo;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="type">byte</span>[] serialize(T obj) &#123;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">Output</span> <span class="variable">output</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Output</span>(byteArrayOutputStream);</span><br><span class="line">        KRYO_THREAD_LOCAL.get().writeObject(output, obj);</span><br><span class="line">        output.close();</span><br><span class="line">        <span class="keyword">return</span> byteArrayOutputStream.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(<span class="type">byte</span>[] bytes, Class&lt;T&gt; classType)</span> &#123;</span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes);</span><br><span class="line">        <span class="type">Input</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Input</span>(byteArrayInputStream);</span><br><span class="line">        <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> KRYO_THREAD_LOCAL.get().readObject(input, classType);</span><br><span class="line">        input.close();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Hessian-序列化器"><a href="#Hessian-序列化器" class="headerlink" title="Hessian 序列化器"></a>Hessian 序列化器</h4><p>实现比较简单，完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Hessian 序列化器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href=&quot;https://github.com/liyupi&quot;&gt;程序员鱼皮&lt;/a&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@learn</span> &lt;a href=&quot;https://codefather.cn&quot;&gt;编程宝典&lt;/a&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@from</span> &lt;a href=&quot;https://yupi.icu&quot;&gt;编程导航知识星球&lt;/a&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HessianSerializer</span> <span class="keyword">implements</span> <span class="title class_">Serializer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="type">byte</span>[] serialize(T object) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">HessianOutput</span> <span class="variable">ho</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HessianOutput</span>(bos);</span><br><span class="line">        ho.writeObject(object);</span><br><span class="line">        <span class="keyword">return</span> bos.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(<span class="type">byte</span>[] bytes, Class&lt;T&gt; tClass)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes);</span><br><span class="line">        <span class="type">HessianInput</span> <span class="variable">hi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HessianInput</span>(bis);</span><br><span class="line">        <span class="keyword">return</span> (T) hi.readObject(tClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、动态使用序列化器-1"><a href="#2、动态使用序列化器-1" class="headerlink" title="2、动态使用序列化器"></a>2、动态使用序列化器</h3><p>1）首先定义序列化器名称的常量，使用接口实现。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 序列化器键名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SerializerKeys</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">JDK</span> <span class="operator">=</span> <span class="string">&quot;jdk&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">JSON</span> <span class="operator">=</span> <span class="string">&quot;json&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">KRYO</span> <span class="operator">=</span> <span class="string">&quot;kryo&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">HESSIAN</span> <span class="operator">=</span> <span class="string">&quot;hessian&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）定义序列化器工厂。</p><p>序列化器对象是可以复用的，没必要每次执行序列化操作前都创建一个新的对象。所以我们可以使用设计模式中的 <strong>工厂模式 + 单例模式</strong> 来简化创建和获取序列化器对象的操作。</p><p>序列化器工厂代码如下，使用 Map 来维护序列化器实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 序列化器工厂（用于获取序列化器对象）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerializerFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列化映射（用于实现单例）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Serializer&gt; KEY_SERIALIZER_MAP = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Serializer&gt;() &#123;&#123;</span><br><span class="line">        put(SerializerKeys.JDK, <span class="keyword">new</span> <span class="title class_">JdkSerializer</span>());</span><br><span class="line">        put(SerializerKeys.JSON, <span class="keyword">new</span> <span class="title class_">JsonSerializer</span>());</span><br><span class="line">        put(SerializerKeys.KRYO, <span class="keyword">new</span> <span class="title class_">KryoSerializer</span>());</span><br><span class="line">        put(SerializerKeys.HESSIAN, <span class="keyword">new</span> <span class="title class_">HessianSerializer</span>());</span><br><span class="line">    &#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认序列化器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Serializer</span> <span class="variable">DEFAULT_SERIALIZER</span> <span class="operator">=</span> KEY_SERIALIZER_MAP.get(<span class="string">&quot;jdk&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取实例</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Serializer <span class="title function_">getInstance</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> KEY_SERIALIZER_MAP.getOrDefault(key, DEFAULT_SERIALIZER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）在全局配置类 RpcConfig 中补充序列化器的配置，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcConfig</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列化器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">serializer</span> <span class="operator">=</span> SerializerKeys.JDK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4）动态获取序列化器。</p><p>需要将之前代码中所有用到序列化器的位置更改为 “使用工厂 + 读取配置” 来获取实现类。</p><p>更改代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定序列化器</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">Serializer</span> <span class="variable">serializer</span> <span class="operator">=</span> SerializerFactory.getInstance(RpcApplication.getRpcConfig().getSerializer());</span><br></pre></td></tr></table></figure><h3 id="3、自定义序列化器-1"><a href="#3、自定义序列化器-1" class="headerlink" title="3、自定义序列化器"></a>3、自定义序列化器</h3><p>我们使用自定义的 SPI 机制实现，支持用户自定义序列化器并指定键名。</p><p>1）指定 SPI 配置目录。</p><p>系统内置的 SPI 机制会加载 <code>resources</code> 资源目录下的 <code>META-INF/services</code> 目录，那我们自定义的序列化器可以如法炮制，改为读取 <code>META-INF/rpc</code> 目录。</p><p>我们还可以将 SPI 配置再分为系统内置 SPI 和用户自定义 SPI，即目录如下：</p><ul><li>用户自定义 SPI：META-INF&#x2F;rpc&#x2F;custom。用户可以在该目录下新建配置，加载自定义的实现类。</li><li>系统内置 SPI：META-INF&#x2F;rpc&#x2F;system。RPC 框架自带的实现类，比如我们之前开发好的 <code>JdkSerializer</code>。</li></ul><p>这样一来，所有接口的实现类都可以通过 SPI 动态加载，不用在代码中硬编码 Map 来维护实现类了。</p><p>让我们编写一个系统扩展配置文件，内容为我们之前写好的序列化器。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdk=com.yupi.yurpc.serializer.JdkSerializer</span><br><span class="line">hessian=com.yupi.yurpc.serializer.HessianSerializer</span><br><span class="line">json=com.yupi.yurpc.serializer.JsonSerializer</span><br><span class="line">kryo=com.yupi.yurpc.serializer.KryoSerializer</span><br></pre></td></tr></table></figure><p>2）编写 SpiLoader 加载器。</p><p>相当于一个工具类，提供了读取配置并加载实现类的方法。</p><p>关键实现如下：</p><ol><li>用 Map 来存储已加载的配置信息 <code>键名 =&gt; 实现类</code>。</li><li>扫描指定路径，读取每个配置文件，获取到 <code>键名 =&gt; 实现类</code> 信息并存储在 Map 中。</li><li>定义获取实例方法，根据用户传入的接口和键名，从 Map 中找到对应的实现类，然后通过反射获取到实现类对象。可以维护一个对象实例缓存，创建过一次的对象从缓存中读取即可。</li></ol><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SPI 加载器（支持键值对映射）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpiLoader</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存储已加载的类：接口名 =&gt;（key =&gt; 实现类）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Map&lt;String, Class&lt;?&gt;&gt;&gt; loaderMap = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对象实例缓存（避免重复 new），类路径 =&gt; 对象实例，单例模式</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Object&gt; instanceCache = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 系统 SPI 目录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">RPC_SYSTEM_SPI_DIR</span> <span class="operator">=</span> <span class="string">&quot;META-INF/rpc/system/&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用户自定义 SPI 目录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">RPC_CUSTOM_SPI_DIR</span> <span class="operator">=</span> <span class="string">&quot;META-INF/rpc/custom/&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 扫描路径</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] SCAN_DIRS = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;RPC_SYSTEM_SPI_DIR, RPC_CUSTOM_SPI_DIR&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态加载的类列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Class&lt;?&gt;&gt; LOAD_CLASS_LIST = Arrays.asList(Serializer.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载所有类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">loadAll</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;加载所有 SPI&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; aClass : LOAD_CLASS_LIST) &#123;</span><br><span class="line">            load(aClass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取某个接口的实例</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tClass</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getInstance</span><span class="params">(Class&lt;?&gt; tClass, String key)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">tClassName</span> <span class="operator">=</span> tClass.getName();</span><br><span class="line">        Map&lt;String, Class&lt;?&gt;&gt; keyClassMap = loaderMap.get(tClassName);</span><br><span class="line">        <span class="keyword">if</span> (keyClassMap == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(String.format(<span class="string">&quot;SpiLoader 未加载 %s 类型&quot;</span>, tClassName));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!keyClassMap.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(String.format(<span class="string">&quot;SpiLoader 的 %s 不存在 key=%s 的类型&quot;</span>, tClassName, key));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取到要加载的实现类型</span></span><br><span class="line">        Class&lt;?&gt; implClass = keyClassMap.get(key);</span><br><span class="line">        <span class="comment">// 从实例缓存中加载指定类型的实例</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">implClassName</span> <span class="operator">=</span> implClass.getName();</span><br><span class="line">        <span class="keyword">if</span> (!instanceCache.containsKey(implClassName)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                instanceCache.put(implClassName, implClass.newInstance());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">errorMsg</span> <span class="operator">=</span> String.format(<span class="string">&quot;%s 类实例化失败&quot;</span>, implClassName);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(errorMsg, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (T) instanceCache.get(implClassName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载某个类型</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loadClass</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, Class&lt;?&gt;&gt; load(Class&lt;?&gt; loadClass) &#123;</span><br><span class="line">        log.info(<span class="string">&quot;加载类型为 &#123;&#125; 的 SPI&quot;</span>, loadClass.getName());</span><br><span class="line">        <span class="comment">// 扫描路径，用户自定义的 SPI 优先级高于系统 SPI</span></span><br><span class="line">        Map&lt;String, Class&lt;?&gt;&gt; keyClassMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String scanDir : SCAN_DIRS) &#123;</span><br><span class="line">            List&lt;URL&gt; resources = ResourceUtil.getResources(scanDir + loadClass.getName());</span><br><span class="line">            <span class="comment">// 读取每个资源文件</span></span><br><span class="line">            <span class="keyword">for</span> (URL resource : resources) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">InputStreamReader</span> <span class="variable">inputStreamReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(resource.openStream());</span><br><span class="line">                    <span class="type">BufferedReader</span> <span class="variable">bufferedReader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(inputStreamReader);</span><br><span class="line">                    String line;</span><br><span class="line">                    <span class="keyword">while</span> ((line = bufferedReader.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">                        String[] strArray = line.split(<span class="string">&quot;=&quot;</span>);</span><br><span class="line">                        <span class="keyword">if</span> (strArray.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                            <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> strArray[<span class="number">0</span>];</span><br><span class="line">                            <span class="type">String</span> <span class="variable">className</span> <span class="operator">=</span> strArray[<span class="number">1</span>];</span><br><span class="line">                            keyClassMap.put(key, Class.forName(className));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    log.error(<span class="string">&quot;spi resource load error&quot;</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        loaderMap.put(loadClass.getName(), keyClassMap);</span><br><span class="line">        <span class="keyword">return</span> keyClassMap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，虽然提供了 loadAll 方法，扫描所有路径下的文件进行加载，但其实没必要使用。更推荐使用 load 方法，按需加载指定的类。</p><p>注意，上述代码中获取配置文件是使用了 <code>ResourceUtil.getResources</code>，而不是通过文件路径获取。因为如果框架作为依赖被引入，是无法得到正确文件路径的。</p><p>3）重构序列化器工厂。</p><p>之前，我们是通过在工厂中硬编码 HashMap 来存储序列化器和实现类的，有了 SPI 后，就可以改为从 SPI 加载指定的序列化器对象。</p><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 序列化器工厂（用于获取序列化器对象）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerializerFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        SpiLoader.load(Serializer.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认序列化器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Serializer</span> <span class="variable">DEFAULT_SERIALIZER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdkSerializer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取实例</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Serializer <span class="title function_">getInstance</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> SpiLoader.getInstance(Serializer.class, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用静态代码块，在工厂首次加载时，就会调用 SpiLoader 的 load 方法加载序列化器接口的所有实现类，之后就可以通过调用 getInstance 方法获取指定的实现类对象了。</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RPC框架开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPC开发3_接口Mock</title>
      <link href="/2025/01/11/RPC%E5%BC%80%E5%8F%913_%E6%8E%A5%E5%8F%A3Mock/"/>
      <url>/2025/01/11/RPC%E5%BC%80%E5%8F%913_%E6%8E%A5%E5%8F%A3Mock/</url>
      
        <content type="html"><![CDATA[<h2 id="一、需求分析"><a href="#一、需求分析" class="headerlink" title="一、需求分析"></a>一、需求分析</h2><h3 id="什么是-Mock？"><a href="#什么是-Mock？" class="headerlink" title="什么是 Mock？"></a>什么是 Mock？</h3><p>RPC 框架的核心功能是调用其他远程服务。但是在实际开发和测试过程中，有时可能无法直接访问真实的远程服务，或者访问真实的远程服务可能会产生不可控的影响，例如网络延迟、服务不稳定等。在这种情况下，就需要使用 mock 服务来模拟远程服务的行为，以便进行接口的测试、开发和调试。</p><p>mock 是指模拟对象，通常用于测试代码中，特别是在单元测试中，便于我们跑通业务流程。</p><p>举个例子，用户服务要调用订单服务，伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        doSomething();</span><br><span class="line">        orderService.order();</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果订单服务还没上线，那么这个流程就跑不通，只能先把调用订单服务的代码注释掉。</p><p>但如果给 orderService 设置一个模拟对象，调用它的 order 方法时，随便返回一个值，就能继续执行后续代码，这就是 mock 的作用。</p><h3 id="为什么要支持-Mock？"><a href="#为什么要支持-Mock？" class="headerlink" title="为什么要支持 Mock？"></a>为什么要支持 Mock？</h3><p>虽然 mock 服务并不是 RPC 框架的核心能力，<strong>但是它的开发成本并不高</strong>。而且给 RPC 框架支持 mock 后，开发者就可以轻松调用服务接口、跑通业务流程，不必依赖真实的远程服务，提高使用体验，何乐而不为呢？</p><p>我们希望能够用最简单的方式 —— 比如一个配置，就让开发者使用 mock 服务。</p><h2 id="二、设计方案"><a href="#二、设计方案" class="headerlink" title="二、设计方案"></a>二、设计方案</h2><p>前面也提到了，mock 的本质就是为要调用的服务创建模拟对象。</p><p>如何创建模拟对象呢？</p><p>之前提到了一种动态创建对象的方法 —— 动态代理。之前是通过动态代理创建远程调用对象。同理，我们可以通过动态代理创建一个 <strong>调用方法时返回固定值</strong> 的对象。</p><h2 id="三、开发实现"><a href="#三、开发实现" class="headerlink" title="三、开发实现"></a>三、开发实现</h2><p>1）我们可以支持开发者通过修改配置文件的方式开启 mock，那么首先给全局配置类 <code>RpcConfig</code> 新增 mock 字段，默认值为 false。</p><p>修改的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcConfig</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟调用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">mock</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）在 Proxy 包下新增 <code>MockServiceProxy</code> 类，用于生成 mock 代理服务。</p><p>在这个类中，需要提供一个根据服务接口类型返回固定值的方法。</p><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Mock 服务代理（JDK 动态代理）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MockServiceProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用代理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 根据方法的返回值类型，生成特定的默认值对象</span></span><br><span class="line">        Class&lt;?&gt; methodReturnType = method.getReturnType();</span><br><span class="line">        log.info(<span class="string">&quot;mock invoke &#123;&#125;&quot;</span>, method.getName());</span><br><span class="line">        <span class="keyword">return</span> getDefaultObject(methodReturnType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成指定类型的默认值对象（可自行完善默认值逻辑）</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object <span class="title function_">getDefaultObject</span><span class="params">(Class&lt;?&gt; type)</span> &#123;</span><br><span class="line">        <span class="comment">// 基本类型</span></span><br><span class="line">        <span class="keyword">if</span> (type.isPrimitive()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (type == <span class="type">boolean</span>.class) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">short</span>.class) &#123;</span><br><span class="line">                <span class="keyword">return</span> (<span class="type">short</span>) <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">int</span>.class) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="type">long</span>.class) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0L</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对象类型</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，通过 <code>getDefaultObject</code> 方法，根据代理接口的 class 返回不同的默认值，比如针对 boolean 类型返回 false、对象类型返回 null 等。</p><p>3）给 <code>ServiceProxyFactory</code> 服务代理工厂新增获取 mock 代理对象的方法 <code>getMockProxy</code>。可以通过读取已定义的全局配置 <code>mock</code> 来区分创建哪种代理对象。</p><p>修改 ServiceProxyFactory，完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务代理工厂（用于创建代理对象）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> &lt;a href=&quot;https://github.com/liyupi&quot;&gt;程序员鱼皮&lt;/a&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@learn</span> &lt;a href=&quot;https://codefather.cn&quot;&gt;编程宝典&lt;/a&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@from</span> &lt;a href=&quot;https://yupi.icu&quot;&gt;编程导航知识星球&lt;/a&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceProxyFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据服务类获取代理对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceClass</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getProxy</span><span class="params">(Class&lt;T&gt; serviceClass)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (RpcApplication.getRpcConfig().isMock()) &#123;</span><br><span class="line">            <span class="keyword">return</span> getMockProxy(serviceClass);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(</span><br><span class="line">                serviceClass.getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;serviceClass&#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ServiceProxy</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据服务类获取 Mock 代理对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceClass</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getMockProxy</span><span class="params">(Class&lt;T&gt; serviceClass)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(</span><br><span class="line">                serviceClass.getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;serviceClass&#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">MockServiceProxy</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RPC框架开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPC开发2_全局配置加载</title>
      <link href="/2025/01/10/RPC%E5%BC%80%E5%8F%912_%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD/"/>
      <url>/2025/01/10/RPC%E5%BC%80%E5%8F%912_%E5%85%A8%E5%B1%80%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="一、需求分析"><a href="#一、需求分析" class="headerlink" title="一、需求分析"></a>一、需求分析</h2><p>在 RPC 框架运行的过程中，会涉及到很多的配置信息，比如注册中心的地址、序列化方式、网络服务器端口号等等。</p><p>之前的简易版 RPC 项目中，我们是在程序里硬编码了这些配置，不利于维护。</p><p>而且 RPC 框架是需要被其他项目作为服务提供者或者服务消费者引入的，我们应当允许引入框架的项目通过编写配置文件来 <strong>自定义配置</strong>。并且一般情况下，服务提供者和服务消费者需要编写相同的 RPC 配置。</p><p>因此，我们需要一套全局配置加载功能。能够让 RPC 框架轻松地从配置文件中读取配置，并且维护一个全局配置对象，便于框架快速获取到一致的配置。</p><h2 id="二、设计方案"><a href="#二、设计方案" class="headerlink" title="二、设计方案"></a>二、设计方案</h2><h3 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h3><p>首先我们梳理需要的配置项，刚开始就一切从简，只提供以下几个配置项即可：</p><ul><li>name 名称</li><li>version 版本号</li><li>serverHost 服务器主机名</li><li>serverPort 服务器端口号</li></ul><p>后续随着框架功能的扩展，我们会不断地新增配置项，还可以适当地对配置项进行分组。</p><p>比如以下是一些常见的 RPC 框架配置项，仅做了解：</p><ol><li>注册中心地址：服务提供者和服务消费者都需要指定注册中心的地址，以便进行服务的注册和发现。</li><li>服务接口：服务提供者需要指定提供的服务接口，而服务消费者需要指定要调用的服务接口。</li><li>序列化方式：服务提供者和服务消费者都需要指定序列化方式，以便在网络中传输数据时进行序列化和反序列化。</li><li>网络通信协议：服务提供者和服务消费者都需要选择合适的网络通信协议，比如 TCP、HTTP 等。</li><li>超时设置：服务提供者和服务消费者都需要设置超时时间，以便在调用服务时进行超时处理。</li><li>负载均衡策略：服务消费者需要指定负载均衡策略，以决定调用哪个服务提供者实例。</li><li>服务端线程模型：服务提供者需要指定服务端线程模型，以决定如何处理客户端请求。</li></ol><p>作为参考可以了解 Dubbo RPC 框架的配置项，包括应用配置、注册中心配置、服务配置等。</p><p>参考 Dubbo：<a href="https://cn.dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/config/api/">https://cn.dubbo.apache.org/zh-cn/overview/mannual/java-sdk/reference-manual/config/api/</a></p><h3 id="读取配置文件"><a href="#读取配置文件" class="headerlink" title="读取配置文件"></a>读取配置文件</h3><p>如何读取配置文件呢？可以使用 Java 的 Properties 类自行编写，但更推荐使用一些第三方工具库，比如 Hutool 的 Setting 模块，可以直接读取指定名称的配置文件中的部分配置信息，并且转换成 Java 对象，非常方便。</p><p>参考官方文档：<a href="https://doc.hutool.cn/pages/Props/%E3%80%82">https://doc.hutool.cn/pages/Props/。</a></p><p>一般情况下，我们读取的配置文件名称为 <code>application.properties</code>，还可以通过指定文件名称后缀的方式来区分多环境，比如 <code>application-prod.properties</code> 表示生产环境、 <code>application-test.properties</code> 表示测试环境。</p><h2 id="三、开发实现"><a href="#三、开发实现" class="headerlink" title="三、开发实现"></a>三、开发实现</h2><h3 id="1、项目初始化"><a href="#1、项目初始化" class="headerlink" title="1、项目初始化"></a>1、项目初始化</h3><h3 id="2、配置加载"><a href="#2、配置加载" class="headerlink" title="2、配置加载"></a>2、配置加载</h3><p>1）在 config 包下新建配置类 <code>RpcConfig</code>，用于保存配置信息。</p><p>可以给属性指定一些默认值，完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RPC 框架配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;yu-rpc&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 版本号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">version</span> <span class="operator">=</span> <span class="string">&quot;1.0&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务器主机名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">serverHost</span> <span class="operator">=</span> <span class="string">&quot;localhost&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务器端口号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Integer</span> <span class="variable">serverPort</span> <span class="operator">=</span> <span class="number">8080</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）在 utils 包下新建工具类 <code>ConfigUtils</code>，作用是读取配置文件并返回配置对象，可以简化调用。</p><p>工具类应当尽量通用，和业务不强绑定，提高使用的灵活性。比如支持外层传入要读取的配置内容前缀、支持传入环境等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载配置对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tClass</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prefix</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">loadConfig</span><span class="params">(Class&lt;T&gt; tClass, String prefix)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> loadConfig(tClass, prefix, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载配置对象，支持区分环境</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tClass</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prefix</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> environment</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">loadConfig</span><span class="params">(Class&lt;T&gt; tClass, String prefix, String environment)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">configFileBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;application&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (StrUtil.isNotBlank(environment)) &#123;</span><br><span class="line">            configFileBuilder.append(<span class="string">&quot;-&quot;</span>).append(environment);</span><br><span class="line">        &#125;</span><br><span class="line">        configFileBuilder.append(<span class="string">&quot;.properties&quot;</span>);</span><br><span class="line">        <span class="type">Props</span> <span class="variable">props</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Props</span>(configFileBuilder.toString());</span><br><span class="line">        <span class="keyword">return</span> props.toBean(tClass, prefix);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后，调用 <code>ConfigUtils</code> 的静态方法就能读取配置了。</p><p>3）在 constant 包中新建 <code>RpcConstant</code> 接口，用于存储 RPC 框架相关的常量。</p><p>比如默认配置文件的加载前缀为 <code>rpc</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yupi.yurpc.constant;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RPC 相关常量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RpcConstant</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 默认配置文件加载前缀</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">DEFAULT_CONFIG_PREFIX</span> <span class="operator">=</span> <span class="string">&quot;rpc&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以读取到类似下面的配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rpc.name=yurpc</span><br><span class="line">rpc.version=<span class="number">2.0</span></span><br><span class="line">rpc.serverPort=<span class="number">8081</span></span><br></pre></td></tr></table></figure><h3 id="3、维护全局配置对象"><a href="#3、维护全局配置对象" class="headerlink" title="3、维护全局配置对象"></a>3、维护全局配置对象</h3><p>RPC 框架中需要维护一个全局的配置对象。在引入 RPC 框架的项目启动时，从配置文件中读取配置并创建对象实例，之后就可以集中地从这个对象中获取配置信息，而不用每次加载配置时再重新读取配置、并创建新的对象，减少了性能开销。</p><p>使用设计模式中的 <strong>单例模式</strong>，就能够很轻松地实现这个需求了。</p><p>一般情况下，我们会使用 holder 来维护全局配置对象实例。在我们的项目中，可以换一个更优雅的命名，使用 <code>RpcApplication</code> 类作为 RPC 项目的启动入口、并且维护项目全局用到的变量。</p><p>完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RPC 框架应用</span></span><br><span class="line"><span class="comment"> * 相当于 holder，存放了项目全局用到的变量。双检锁单例模式实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> RpcConfig rpcConfig;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 框架初始化，支持传入自定义配置</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> newRpcConfig</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(RpcConfig newRpcConfig)</span> &#123;</span><br><span class="line">        rpcConfig = newRpcConfig;</span><br><span class="line">        log.info(<span class="string">&quot;rpc init, config = &#123;&#125;&quot;</span>, newRpcConfig.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        RpcConfig newRpcConfig;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            newRpcConfig = ConfigUtils.loadConfig(RpcConfig.class, RpcConstant.DEFAULT_CONFIG_PREFIX);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// 配置加载失败，使用默认值</span></span><br><span class="line">            newRpcConfig = <span class="keyword">new</span> <span class="title class_">RpcConfig</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        init(newRpcConfig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取配置</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> RpcConfig <span class="title function_">getRpcConfig</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (rpcConfig == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (RpcApplication.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rpcConfig == <span class="literal">null</span>) &#123;</span><br><span class="line">                    init();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rpcConfig;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码其实就是 <code>双检锁单例模式</code> 的经典实现，支持在获取配置时才调用 init 方法实现懒加载。</p><p>为了便于扩展，还支持自己传入配置对象；如果不传入，则默认调用前面写好的 ConfigUtils 来加载配置。</p><p>以后 RPC 框架内只需要写一行代码，就能正确加载到配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RpcConfig</span> <span class="variable">rpc</span> <span class="operator">=</span> RpcApplication.getRpcConfig();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RPC框架开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RPC开发1_简易框架</title>
      <link href="/2025/01/08/RPC%E5%BC%80%E5%8F%911_%E7%AE%80%E6%98%93%E6%A1%86%E6%9E%B6/"/>
      <url>/2025/01/08/RPC%E5%BC%80%E5%8F%911_%E7%AE%80%E6%98%93%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>为了加深对RPC框架的理解，我跟着鱼皮进行了一次完整的RPC框架的开发，写博客主要用来记录技术要点，开发过程适当省略。</p></blockquote><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><h3 id="什么是-RPC？"><a href="#什么是-RPC？" class="headerlink" title="什么是 RPC？"></a>什么是 RPC？</h3><p>RPC（Remote Procedure Call）即远程过程调用，是一种计算机通信协议，它允许程序在不同的计算机之间进行通信和交互，就像本地调用一样。</p><p>简单理解，以前只能跑腿到线下店购买食物，耗时耗力。但现在有了手机、网络、外卖平台，只需要在家动动手指，就能点外卖让骑手把食物配送到家，而不需要关注网络是怎么传输的、外卖平台是怎么操作的、骑手小哥是怎么配送的，只负责享受食物就行了。</p><h3 id="为什么需要-RPC？"><a href="#为什么需要-RPC？" class="headerlink" title="为什么需要 RPC？"></a>为什么需要 RPC？</h3><p>回到 RPC 的概念，RPC 允许一个程序（称为服务消费者）像调用自己程序的方法一样，调用另一个程序（称为服务提供者）的接口，而不需要了解数据的传输处理过程、底层网络通信的细节等。这些都会由 RPC 框架帮你完成，使得开发者可以轻松调用远程服务，快速开发分布式系统。</p><p>举个例子，现在有个项目 A 提供了点餐服务，项目 B 需要调用点餐服务完成下单。</p><p>点餐服务和接口的示例伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="comment">// 点餐，返回 orderId</span></span><br><span class="line">    <span class="type">long</span> <span class="title function_">order</span><span class="params">(参数<span class="number">1</span>, 参数<span class="number">2</span>, 参数<span class="number">3</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有 RPC 框架，项目 B 怎么调用项目 A 的服务呢？</p><p>首先，由于项目 A 和项目 B 都是独立的系统，不能像 SDK 一样作为依赖包引入。那么就需要项目 A 提供 web 服务，并且编写一个点餐接口暴露服务，比如访问 <code>http://meituan.top</code> 就能调用点餐服务；然后项目 B 作为服务消费者，需要自己构造请求，并通过 HttpClient 请求上述地址。如果项目 B 需要调用更多第三方服务，每个服务和方法的调用都编写一个 HTTP 请求，那么会非常麻烦！</p><p>示例伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">url = <span class="string">&quot;http://meituan.top&quot;</span></span><br><span class="line">req = <span class="keyword">new</span> <span class="title class_">Req</span>(参数<span class="number">1</span>, 参数<span class="number">2</span>, 参数<span class="number">3</span>)</span><br><span class="line">res = httpClient.post(url).body(req).execute()</span><br><span class="line">orderId = res.data.orderId</span><br></pre></td></tr></table></figure><p>而有了 RPC 框架，项目 B 可以通过一行代码完成调用！</p><p>示例伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">orderId = orderService.order(参数<span class="number">1</span>, 参数<span class="number">2</span>, 参数<span class="number">3</span>)</span><br></pre></td></tr></table></figure><h2 id="二、RPC-框架实现思路"><a href="#二、RPC-框架实现思路" class="headerlink" title="二、RPC 框架实现思路"></a>二、RPC 框架实现思路</h2><h3 id="基本设计"><a href="#基本设计" class="headerlink" title="基本设计"></a>基本设计</h3><p>RPC 框架为什么能帮我们简化调用？如何实现一个 RPC 框架呢？</p><p>首先如下图，有服务消费者和服务提供者两个角色：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/03/10/67cece8162786.jpeg"></p><p>消费者想要调用提供者，就需要提供者启动一个 <code>web 服务</code>，然后通过 <code>请求客户端</code>发送 HTTP 或者其他协议的请求来调用。</p><p>比如请求 <code>yupi.icu/order</code> 地址后，提供者会调用 orderService 的 order 方法：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/03/10/67cecec208cfb.jpeg"></p><p>但如果提供者提供了多个服务和方法，每个接口和方法都要单独写一个接口？消费者要针对每个接口写一段 HTTP 调用的逻辑么？</p><p>其实可以提供一个统一的服务调用接口，通过 <code>请求处理器</code> 根据客户端的请求参数来进行不同的处理、调用不同的服务和方法。</p><p>可以在服务提供者程序维护一个 <code>本地服务注册器</code>，记录服务和对应实现类的映射。</p><p>举个例子，消费者要调用 orderService 服务的 order 方法，可以发送请求，参数为 <code>service=orderService,method=order</code>，然后请求处理器会根据 service 从服务注册器中找到对应的服务实现类，并且通过 Java 的反射机制调用 method 指定的方法。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/03/10/67ced0169f020.jpeg"></p><p>需要注意的是，由于 Java 对象无法直接在网络中传输，所以要对传输的参数进行 <code>序列化</code> 和 <code>反序列化</code>。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/03/10/67cecf58c279f.jpeg"></p><p>为了简化消费者发请求的代码，实现类似本地调用的体验。可以基于代理模式，为消费者要调用的接口生成一个代理对象，由代理对象完成请求和响应的过程。</p><p>所谓代理，就是有人帮你做一些事情，不用自己操心。</p><p>至此，一个最简易的 RPC 框架架构图诞生了：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/03/10/67ced0bc7941c.jpeg"></p><p>上图中的虚线框部分，就是 RPC 框架需要提供的模块和能力。</p><h3 id="扩展设计"><a href="#扩展设计" class="headerlink" title="扩展设计"></a>扩展设计</h3><p>虽然上述设计已经跑通了基本调用流程，但离一个完备的 RPC 框架还有很大的差距，让我们带着问题来进一步完善下架构设计。</p><h4 id="1、服务注册发现"><a href="#1、服务注册发现" class="headerlink" title="1、服务注册发现"></a>1、服务注册发现</h4><p>问题 1：消费者如何知道提供者的调用地址呢？</p><p>类比生活场景，我们点外卖时，外卖小哥如何知道我们的地址和店铺的地址？肯定是买家和卖家分别填写地址，由平台来保存的。<br>因此，我们需要一个 <code>注册中心</code>，来保存服务提供者的地址。消费者要调用服务时，只需从注册中心获取对应服务的提供者地址即可。</p><p>架构图如下：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/03/10/67ced0ffaeca3.jpeg"></p><p>一般用现成的第三方注册中心，比如 Redis、Zookeeper 即可。</p><h4 id="2、负载均衡"><a href="#2、负载均衡" class="headerlink" title="2、负载均衡"></a>2、负载均衡</h4><p>问题 2：如果有多个服务提供者，消费者应该调用哪个服务提供者呢？</p><p>我们可以给服务调用方增加负载均衡能力，通过指定不同的算法来决定调用哪一个服务提供者，比如轮询、随机、根据性能动态调用等。</p><p>架构图如下：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/03/10/67ced11a10367.jpeg"></p><h4 id="3、容错机制"><a href="#3、容错机制" class="headerlink" title="3、容错机制"></a>3、容错机制</h4><p>问题 3：如果服务调用失败，应该如何处理呢？</p><p>为了保证分布式系统的高可用，我们通常会给服务的调用增加一定的容错机制，比如失败重试、降级调用其他接口等等。</p><p>架构图如下：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2025/03/10/67ced13dca5ca.jpeg"></p><h4 id="4、其他"><a href="#4、其他" class="headerlink" title="4、其他"></a>4、其他</h4><p>除了上面几个经典设计外，如果想要做一个优秀的 RPC 框架，还要考虑很多问题。</p><p>比如：</p><ul><li>服务提供者下线了怎么办？需要一个失效节点剔除机制。</li><li>服务消费者每次都从注册中心拉取信息，性能会不会很差？可以使用缓存来优化性能。</li><li>如何优化 RPC 框架的传输通讯性能？比如选择合适的网络框架、自定义协议头、节约传输体积等。</li><li>如何让整个框架更利于扩展？比如使用 Java 的 SPI 机制、配置化等等。</li></ul><p>我们可以通过做一个 RPC 项目学习到网络、序列化、代理、服务注册发现、负载均衡、容错、可扩展设计等知识，相信完成项目后会收获满满。</p><h2 id="三、开发简易版-RPC-框架"><a href="#三、开发简易版-RPC-框架" class="headerlink" title="三、开发简易版 RPC 框架"></a>三、开发简易版 RPC 框架</h2><p>下面从 0 开始，先完成一个简易版的 RPC 框架，后面再持续扩展优化。</p><h3 id="项目准备"><a href="#项目准备" class="headerlink" title="项目准备"></a>项目准备</h3><h4 id="1、项目初始化"><a href="#1、项目初始化" class="headerlink" title="1、项目初始化"></a>1、项目初始化</h4><p>分别介绍几个模块：</p><ul><li>example-common：示例代码的公共依赖，包括接口、Model 等</li><li>example-consumer：示例服务消费者代码</li><li>example-provider：示例服务提供者代码</li><li>yu-rpc-easy：简易版 RPC 框架</li></ul><h4 id="2、公共模块"><a href="#2、公共模块" class="headerlink" title="2、公共模块"></a>2、公共模块</h4><p>公共模块需要同时被消费者和服务提供者引入，主要是编写和服务相关的接口和数据模型。</p><p>1）编写用户实体类 User：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，对象需要实现序列化接口，为后续网络传输序列化提供支持。</p><p>2）编写用户服务接口 UserService，提供一个获取用户的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户服务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取用户</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    User <span class="title function_">getUser</span><span class="params">(User user)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、服务提供者"><a href="#3、服务提供者" class="headerlink" title="3、服务提供者"></a>3、服务提供者</h4><p>服务提供者是真正实现了接口的模块。</p><p>1）编写服务实现类，实现公共模块中定义的用户服务接口。</p><p>功能是打印用户的名称，并且返回参数中的用户对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户服务实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用户名：&quot;</span> + user.getName());</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）编写服务提供者启动类，之后会在该类的 main 方法中编写提供服务的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简易服务提供者示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EasyProviderExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 提供服务</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、服务消费者"><a href="#4、服务消费者" class="headerlink" title="4、服务消费者"></a>4、服务消费者</h4><p>服务消费者是需要调用服务的模块。</p><p>1）创建服务消费者启动类 EasyConsumerExample，编写调用接口的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简易服务消费者示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EasyConsumerExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// todo 需要获取 UserService 的实现类对象</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;yupi&quot;</span>);</span><br><span class="line">        <span class="comment">// 调用</span></span><br><span class="line">        <span class="type">User</span> <span class="variable">newUser</span> <span class="operator">=</span> userService.getUser(user);</span><br><span class="line">        <span class="keyword">if</span> (newUser != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(newUser.getName());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;user == null&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，现在是无法获取到 userService 实例的，所以预留为 null。我们之后的目标是，能够通过 RPC 框架，快速得到一个支持远程调用服务提供者的代理对象，像调用本地方法一样调用 UserService 的方法。</p><h3 id="web-服务器"><a href="#web-服务器" class="headerlink" title="web 服务器"></a>web 服务器</h3><p>接下来，我们要先让服务提供者提供 <strong>可远程访问</strong> 的服务。那么，就需要一个 web 服务器，能够接受处理请求、并返回响应。</p><p>web 服务器的选择有很多，比如 Spring Boot 内嵌的 Tomcat、NIO 框架 Netty 和 Vert.x 等等。</p><p>此处使用高性能的 NIO 框架 Vert.x 来作为 RPC 框架的 web 服务器。</p><p>Vert.x 官方文档：<a href="https://vertx.io/">https://vertx.io/</a></p><p>1）编写一个 web 服务器的接口 HttpServer，定义统一的启动服务器方法，便于后续的扩展，比如实现多种不同的 web 服务器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HTTP 服务器接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">HttpServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动服务器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> port</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doStart</span><span class="params">(<span class="type">int</span> port)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）编写基于 Vert.x 实现的 web 服务器 VertxHttpServer，能够监听指定端口并处理请求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VertxHttpServer</span> <span class="keyword">implements</span> <span class="title class_">HttpServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doStart</span><span class="params">(<span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 Vert.x 实例</span></span><br><span class="line">        <span class="type">Vertx</span> <span class="variable">vertx</span> <span class="operator">=</span> Vertx.vertx();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 HTTP 服务器</span></span><br><span class="line">        io.vertx.core.http.<span class="type">HttpServer</span> <span class="variable">server</span> <span class="operator">=</span> vertx.createHttpServer();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 监听端口并处理请求</span></span><br><span class="line">        server.requestHandler(request -&gt; &#123;</span><br><span class="line">            <span class="comment">// 处理 HTTP 请求</span></span><br><span class="line">            System.out.println(<span class="string">&quot;Received request: &quot;</span> + request.method() + <span class="string">&quot; &quot;</span> + request.uri());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送 HTTP 响应</span></span><br><span class="line">            request.response()</span><br><span class="line">                    .putHeader(<span class="string">&quot;content-type&quot;</span>, <span class="string">&quot;text/plain&quot;</span>)</span><br><span class="line">                    .end(<span class="string">&quot;Hello from Vert.x HTTP server!&quot;</span>);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动 HTTP 服务器并监听指定端口</span></span><br><span class="line">        server.listen(port, result -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (result.succeeded()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Server is now listening on port &quot;</span> + port);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;Failed to start server: &quot;</span> + result.cause());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）验证 web 服务器能否启动成功并接受请求。</p><p>修改示例服务提供者模块的 <code>EasyProviderExample</code> 类，编写启动 web 服务的代码，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简易服务提供者示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EasyProviderExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 启动 web 服务</span></span><br><span class="line">        <span class="type">HttpServer</span> <span class="variable">httpServer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VertxHttpServer</span>();</span><br><span class="line">        httpServer.doStart(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过浏览器访问 <code>localhost:8080</code>，查看能否正常访问并看到输出的文字。</p><h3 id="本地服务注册器"><a href="#本地服务注册器" class="headerlink" title="本地服务注册器"></a>本地服务注册器</h3><p>我们现在做的简易 RPC 框架主要是跑通流程，所以暂时先不用第三方注册中心，直接把服务注册到服务提供者本地即可。</p><p>使用线程安全的 ConcurrentHashMap 存储服务注册信息，key 为服务名称、value 为服务的实现类。之后就可以根据要调用的服务名称获取到对应的实现类，然后通过反射进行方法调用了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本地注册中心</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalRegistry</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册信息存储</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Class&lt;?&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册服务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> implClass</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(String serviceName, Class&lt;?&gt; implClass)</span> &#123;</span><br><span class="line">        map.put(serviceName, implClass);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取服务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; get(String serviceName) &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(serviceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除服务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceName</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">(String serviceName)</span> &#123;</span><br><span class="line">        map.remove(serviceName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，本地服务注册器和注册中心的作用是有区别的。注册中心的作用侧重于管理注册的服务、提供服务信息给消费者；而本地服务注册器的作用是根据服务名获取到对应的实现类，是完成调用必不可少的模块。</p><p>服务提供者启动时，需要注册服务到注册器中，修改 <code>EasyProviderExample</code> 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简易服务提供者示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EasyProviderExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 注册服务</span></span><br><span class="line">        LocalRegistry.register(UserService.class.getName(), UserServiceImpl.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动 web 服务</span></span><br><span class="line">        <span class="type">HttpServer</span> <span class="variable">httpServer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VertxHttpServer</span>();</span><br><span class="line">        httpServer.doStart(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="序列化器"><a href="#序列化器" class="headerlink" title="序列化器"></a>序列化器</h3><p>服务在本地注册后，就可以根据请求信息取出实现类并调用方法了。</p><p>但是在编写处理请求的逻辑前，我们要先实现序列化器模块。因为无论是请求或响应，都会涉及参数的传输。而 Java 对象是存活在 JVM 虚拟机中的，如果想在其他位置存储并访问、或者在网络中进行传输，就需要进行序列化和反序列化。</p><p>什么是序列化和反序列化呢？</p><ul><li>序列化：将 Java 对象转为可传输的字节数组。</li><li>反序列化：将字节数组转换为 Java 对象。</li></ul><p>有很多种不同的序列化方式，比如 Java 原生序列化、JSON、Hessian、Kryo、protobuf 等。</p><p>为了实现方便，此处选择 Java 原生的序列化器。</p><p>1）在 RPC 模块中编写序列化接口 Serializer，提供序列化和反序列化两个方法，便于后续扩展更多的序列化器。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 序列化器接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Serializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; <span class="type">byte</span>[] serialize(T object) <span class="keyword">throws</span> IOException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反序列化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(<span class="type">byte</span>[] bytes, Class&lt;T&gt; type)</span> <span class="keyword">throws</span> IOException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）基于 Java 自带的序列化器实现 JdkSerializer，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yupi.yurpc.serializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * JDK 序列化器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdkSerializer</span> <span class="keyword">implements</span> <span class="title class_">Serializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> object</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="type">byte</span>[] serialize(T object) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">objectOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(outputStream);</span><br><span class="line">        objectOutputStream.writeObject(object);</span><br><span class="line">        objectOutputStream.close();</span><br><span class="line">        <span class="keyword">return</span> outputStream.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 反序列化</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(<span class="type">byte</span>[] bytes, Class&lt;T&gt; type)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ByteArrayInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">objectInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(inputStream);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) objectInputStream.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            objectInputStream.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="提供者处理调用-请求处理器"><a href="#提供者处理调用-请求处理器" class="headerlink" title="提供者处理调用 - 请求处理器"></a>提供者处理调用 - 请求处理器</h3><p>请求处理器是 RPC 框架的实现关键，它的作用是：处理接收到的请求，并根据请求参数找到对应的服务和方法，通过反射实现调用，最后封装返回结果并响应请求。</p><p>1）在 RPC 模块中编写请求和响应封装类。</p><p>请求类 RpcRequest 的作用是封装调用所需的信息，比如服务名称、方法名称、调用参数的类型列表、参数列表。这些都是 Java 反射机制所需的参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RPC 请求</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcRequest</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 服务名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String serviceName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数类型列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] parameterTypes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参数列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object[] args;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>响应类 RpcResponse 的作用是封装调用方法得到的返回值、以及调用的信息（比如异常情况）等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RPC 响应</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcResponse</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应数据类型（预留）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; dataType;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Exception exception;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）编写请求处理器 HttpServerHandler。</p><p>业务流程如下：</p><ol><li>反序列化请求为对象，并从请求对象中获取参数。</li><li>根据服务名称从本地注册器中获取到对应的服务实现类。</li><li>通过反射机制调用方法，得到返回结果。</li><li>对返回结果进行封装和序列化，并写入到响应中。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * HTTP 请求处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HttpServerHandler</span> <span class="keyword">implements</span> <span class="title class_">Handler</span>&lt;HttpServerRequest&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handle</span><span class="params">(HttpServerRequest request)</span> &#123;</span><br><span class="line">        <span class="comment">// 指定序列化器</span></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Serializer</span> <span class="variable">serializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdkSerializer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录日志</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Received request: &quot;</span> + request.method() + <span class="string">&quot; &quot;</span> + request.uri());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 异步处理 HTTP 请求</span></span><br><span class="line">        request.bodyHandler(body -&gt; &#123;</span><br><span class="line">            <span class="type">byte</span>[] bytes = body.getBytes();</span><br><span class="line">            <span class="type">RpcRequest</span> <span class="variable">rpcRequest</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                rpcRequest = serializer.deserialize(bytes, RpcRequest.class);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 构造响应结果对象</span></span><br><span class="line">            <span class="type">RpcResponse</span> <span class="variable">rpcResponse</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RpcResponse</span>();</span><br><span class="line">            <span class="comment">// 如果请求为 null，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (rpcRequest == <span class="literal">null</span>) &#123;</span><br><span class="line">                rpcResponse.setMessage(<span class="string">&quot;rpcRequest is null&quot;</span>);</span><br><span class="line">                doResponse(request, rpcResponse, serializer);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获取要调用的服务实现类，通过反射调用</span></span><br><span class="line">                Class&lt;?&gt; implClass = LocalRegistry.get(rpcRequest.getServiceName());</span><br><span class="line">                <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> implClass.getMethod(rpcRequest.getMethodName(), rpcRequest.getParameterTypes());</span><br><span class="line">                <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> method.invoke(implClass.newInstance(), rpcRequest.getArgs());</span><br><span class="line">                <span class="comment">// 封装返回结果</span></span><br><span class="line">                rpcResponse.setData(result);</span><br><span class="line">                rpcResponse.setDataType(method.getReturnType());</span><br><span class="line">                rpcResponse.setMessage(<span class="string">&quot;ok&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">                rpcResponse.setMessage(e.getMessage());</span><br><span class="line">                rpcResponse.setException(e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 响应</span></span><br><span class="line">            doResponse(request, rpcResponse, serializer);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 响应</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rpcResponse</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serializer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">doResponse</span><span class="params">(HttpServerRequest request, RpcResponse rpcResponse, Serializer serializer)</span> &#123;</span><br><span class="line">        <span class="type">HttpServerResponse</span> <span class="variable">httpServerResponse</span> <span class="operator">=</span> request.response()</span><br><span class="line">                .putHeader(<span class="string">&quot;content-type&quot;</span>, <span class="string">&quot;application/json&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 序列化</span></span><br><span class="line">            <span class="type">byte</span>[] serialized = serializer.serialize(rpcResponse);</span><br><span class="line">            httpServerResponse.end(Buffer.buffer(serialized));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            httpServerResponse.end(Buffer.buffer());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意，不同的 web 服务器对应的请求处理器实现方式也不同，比如 Vert.x 中是通过实现 <code>Handler&lt;HttpServerRequest&gt;</code> 接口来自定义请求处理器的。并且可以通过 <code>request.bodyHandler</code> 异步处理请求。</p><p>3）给 HttpServer 绑定请求处理器。</p><p>修改 VertxHttpServer 的代码，通过 <code>server.requestHandler</code> 绑定请求处理器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Vertx HTTP 服务器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VertxHttpServer</span> <span class="keyword">implements</span> <span class="title class_">HttpServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动服务器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> port</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doStart</span><span class="params">(<span class="type">int</span> port)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建 Vert.x 实例</span></span><br><span class="line">        <span class="type">Vertx</span> <span class="variable">vertx</span> <span class="operator">=</span> Vertx.vertx();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建 HTTP 服务器</span></span><br><span class="line">        io.vertx.core.http.<span class="type">HttpServer</span> <span class="variable">server</span> <span class="operator">=</span> vertx.createHttpServer();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 监听端口并处理请求</span></span><br><span class="line">        server.requestHandler(<span class="keyword">new</span> <span class="title class_">HttpServerHandler</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动 HTTP 服务器并监听指定端口</span></span><br><span class="line">        server.listen(port, result -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (result.succeeded()) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Server is now listening on port &quot;</span> + port);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;Failed to start server: &quot;</span> + result.cause());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，引入了 RPC 框架的服务提供者模块，已经能够接受请求并完成服务调用了。</p><h3 id="消费方发起调用-代理"><a href="#消费方发起调用-代理" class="headerlink" title="消费方发起调用 - 代理"></a>消费方发起调用 - 代理</h3><p>在项目准备阶段，我们已经预留了一段调用服务的代码，只要能够获取到 UserService 对象（实现类），就能跑通整个流程。</p><p>但 UserService 的实现类从哪来呢？</p><p>总不能把服务提供者的 UserServiceImpl 复制粘贴到消费者模块吧？要能那样做还需要 RPC 框架干什么？分布式系统中，我们调用其他项目或团队提供的接口时，一般只关注请求参数和响应结果，而不关注具体实现。</p><p>在之前的架构中讲过，我们可以通过生成代理对象来简化消费方的调用。</p><p>代理的实现方式大致分为 2 类：静态代理和动态代理，下面依次实现。</p><h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>静态代理是指为每一个特定类型的接口或对象，编写一个代理类。</p><p>比如在 <code>example-consumer</code> 模块中，创建一个静态代理 UserServiceProxy，实现 UserService 接口和 getUser 方法。</p><p>只不过实现 getUser 方法时，不是复制粘贴服务提供者 UserServiceImpl 中的代码，而是要构造 HTTP 请求去调用服务提供者。</p><p>需要注意发送请求前要将参数序列化，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态代理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="comment">// 指定序列化器</span></span><br><span class="line">        <span class="type">Serializer</span> <span class="variable">serializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdkSerializer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发请求</span></span><br><span class="line">        <span class="type">RpcRequest</span> <span class="variable">rpcRequest</span> <span class="operator">=</span> RpcRequest.builder()</span><br><span class="line">                .serviceName(UserService.class.getName())</span><br><span class="line">                .methodName(<span class="string">&quot;getUser&quot;</span>)</span><br><span class="line">                .parameterTypes(<span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;User.class&#125;)</span><br><span class="line">                .args(<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;user&#125;)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">byte</span>[] bodyBytes = serializer.serialize(rpcRequest);</span><br><span class="line">            <span class="type">byte</span>[] result;</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">HttpResponse</span> <span class="variable">httpResponse</span> <span class="operator">=</span> HttpRequest.post(<span class="string">&quot;http://localhost:8080&quot;</span>)</span><br><span class="line">                    .body(bodyBytes)</span><br><span class="line">                    .execute()) &#123;</span><br><span class="line">                result = httpResponse.bodyBytes();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">RpcResponse</span> <span class="variable">rpcResponse</span> <span class="operator">=</span> serializer.deserialize(result, RpcResponse.class);</span><br><span class="line">            <span class="keyword">return</span> (User) rpcResponse.getData();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后修改 EasyConsumerExample，new 一个代理对象并赋值给 userService，就能完成调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简易服务消费者示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EasyConsumerExample</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 静态代理</span></span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserServiceProxy</span>();</span><br><span class="line">        </span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态代理虽然很好理解（就是写个实现类），但缺点也很明显，我们如果要给每个服务接口都写一个实现类，是非常麻烦的，这种代理方式的灵活性很差！</p><p>所以 RPC 框架中，我们会使用动态代理。</p><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>动态代理的作用是，根据要生成的对象的类型，自动生成一个代理对象。</p><p>常用的动态代理实现方式有 JDK 动态代理和基于字节码生成的动态代理（比如 CGLIB）。前者简单易用、无需引入额外的库，但缺点是只能对接口进行代理；后者更灵活、可以对任何类进行代理，但性能略低于 JDK 动态代理。</p><p>此处我们使用 JDK 动态代理。</p><p>1）在 RPC 模块中编写动态代理类 ServiceProxy，需要实现 InvocationHandler 接口的 invoke 方法。</p><p>代码如下（几乎就是把静态代理的代码搬运过来）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务代理（JDK 动态代理）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceProxy</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用代理</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        <span class="comment">// 指定序列化器</span></span><br><span class="line">        <span class="type">Serializer</span> <span class="variable">serializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdkSerializer</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造请求</span></span><br><span class="line">        <span class="type">RpcRequest</span> <span class="variable">rpcRequest</span> <span class="operator">=</span> RpcRequest.builder()</span><br><span class="line">                .serviceName(method.getDeclaringClass().getName())</span><br><span class="line">                .methodName(method.getName())</span><br><span class="line">                .parameterTypes(method.getParameterTypes())</span><br><span class="line">                .args(args)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 序列化</span></span><br><span class="line">            <span class="type">byte</span>[] bodyBytes = serializer.serialize(rpcRequest);</span><br><span class="line">            <span class="comment">// 发送请求</span></span><br><span class="line">            <span class="comment">// todo 注意，这里地址被硬编码了（需要使用注册中心和服务发现机制解决）</span></span><br><span class="line">            <span class="keyword">try</span> (<span class="type">HttpResponse</span> <span class="variable">httpResponse</span> <span class="operator">=</span> HttpRequest.post(<span class="string">&quot;http://localhost:8080&quot;</span>)</span><br><span class="line">                    .body(bodyBytes)</span><br><span class="line">                    .execute()) &#123;</span><br><span class="line">                <span class="type">byte</span>[] result = httpResponse.bodyBytes();</span><br><span class="line">                <span class="comment">// 反序列化</span></span><br><span class="line">                <span class="type">RpcResponse</span> <span class="variable">rpcResponse</span> <span class="operator">=</span> serializer.deserialize(result, RpcResponse.class);</span><br><span class="line">                <span class="keyword">return</span> rpcResponse.getData();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解释下上述代码，当用户调用某个接口的方法时，会改为调用 invoke 方法。在 invoke 方法中，我们可以获取到要调用的方法信息、传入的参数列表等，这不就是我们服务提供者需要的参数么？用这些参数来构造请求对象就可以完成调用了。</p><p>需要注意的是，上述代码中，请求的服务提供者地址被硬编码了，需要使用注册中心和服务发现机制来解决。</p><p>2）创建动态代理工厂 ServiceProxyFactory，作用是根据指定类创建动态代理对象。</p><p>这里是使用了 <strong>工厂设计模式</strong>，来简化对象的创建过程，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务代理工厂（用于创建代理对象）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceProxyFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据服务类获取代理对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceClass</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getProxy</span><span class="params">(Class&lt;T&gt; serviceClass)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(</span><br><span class="line">                serviceClass.getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;serviceClass&#125;,</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ServiceProxy</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，主要是通过 <code>Proxy.newProxyInstance</code> 方法为指定类型创建代理对象。</p><p>3）最后，在 EasyConsumerExample 中，就可以通过调用工厂来为 UserService 获取动态代理对象了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态代理</span></span><br><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> ServiceProxyFactory.getProxy(UserService.class);</span><br></pre></td></tr></table></figure><p>至此，简易版的 RPC 框架已经开发完成。</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RPC框架开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络攻防期末复习</title>
      <link href="/2024/12/24/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
      <url>/2024/12/24/%E7%BD%91%E7%BB%9C%E6%94%BB%E9%98%B2%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="“攻击”-5步走"><a href="#“攻击”-5步走" class="headerlink" title="“攻击” 5步走"></a>“攻击” 5步走</h3><p>​1.社会工程，获取特定目标（比如已知qq号码）或非特定目标（机会主义者要控制一批机器当僵尸机）<br>​2.扫描，获取目标漏洞信息<br>​3.入侵<br>​4.拖库或潜伏监控<br>​5.消除痕迹</p><h3 id="“防范”"><a href="#“防范”" class="headerlink" title="“防范”"></a>“防范”</h3><p>​1.不要泄露社工信息<br>​2.打补丁堵漏洞<br>​3.观察网络流量，识别正常、异常、攻击，以及拖库等行为(snort,mydlp)<br>​4.对流量载荷中可能的泄露进行检查（ntop一般不关心载荷，用squid+sslbump+icap）<br>​5.日常性的工作，比如勤于观察日志、关心技术论坛和安全新闻等</p><h3 id="“网络”系统"><a href="#“网络”系统" class="headerlink" title="“网络”系统"></a>“网络”系统</h3><p>​1.访问控制，除了os、app登录等，还有iptables、selinux等<br>​2.传输加密，https，vpn，ssh<br>​3.掩盖IP来源，各种proxy和跳转，典型就是vps、tor、i2p<br>​4.对流量进行其他混淆，比如使用ping载荷、dns载荷等<br>​5.其他，比如利用Botnet、APT、供应链攻击等</p><h3 id="网络攻击的深层技术（脱离脚本小子的低级趣味）"><a href="#网络攻击的深层技术（脱离脚本小子的低级趣味）" class="headerlink" title="网络攻击的深层技术（脱离脚本小子的低级趣味）"></a>网络攻击的深层技术（脱离脚本小子的低级趣味）</h3><p>​1.内存安全，以缓冲区溢出为代表，各种exploit和shellcode基本都是这一类<br>​2.二进制分析和逆向，各种平台windows&#x2F;linux&#x2F;Android&#x2F;macos&#x2F;ios上，可以发现内存安全等等各方面的问题<br>​3.外挂技术，一般也是基于二进制分析的成果进行<br>​4.网络攻击一般不去破译密文，因为密码算法没有容易破解的，但是cmap5.com确实很好用。</p><h3 id="安全管理和法规"><a href="#安全管理和法规" class="headerlink" title="安全管理和法规"></a>安全管理和法规</h3><p>​    1.安全管理：“bs7799” vs. 国内网络安全技术标准 vs. 企业安全管理制度<br>​    2.国内法规：<del>网络安全法、</del>数据安全法、~个人信息保护法</p><h3 id="工具-集-众多，典型举例"><a href="#工具-集-众多，典型举例" class="headerlink" title="工具(集)众多，典型举例"></a>工具(集)众多，典型举例</h3><p>​1.泄露案和社工库<br>​2.安全扫描器以及一些ctf常用工具<br>​3.metaspolit<br>​4.vulhub<br>​5.ntopng<br>​    6.snort<br>​7.squid-icap-clamav<br>​8.mydlp</p><h3 id="学习线索串联"><a href="#学习线索串联" class="headerlink" title="学习线索串联"></a>学习线索串联</h3><p>1.了解目标，通过社会工程，比如至少whois一下，利用“社工库”也是重要的手段之一。所以社工库是违法的，不过建设和部署一个用于内部自用教育培训和演示的社工库系统希望***。</p><p>2.对目标主机或网络进行安全扫描，注意别暴漏自己，有个叫董大风(化名)的仅扫描了某政府网站一下，就被判了几个月，用的还是境外的VPS，实在不行，“撒旦”了解一下。反过来，防范工作在扫描阶段就开始了，用防火墙、snort等易于发现扫描行为，应及时预警(向上级汇报)，如果是政府网站就可以请律师了。只报警是不行的，要打补丁要改配置要买防火墙，一定要买。</p><p>3.有了目标的漏洞信息，可以用通用工具比如Metasploit等尝试获得控制权。如果漏洞太新，比如安全论坛看到的0day，流行工具还没有收录，只能论坛里找别的黑客写好的工具比如MSxx-yyy.exe这种，或自己写利用漏洞入侵的程序(共享给别人利用是违法的)。</p><p>4.有了控制权，先偷文件，再长期驻留监控用户活动，也可以当攻击跳板或代理，也可以利用其CPU、存储、带宽等资源做些能获得利益的事情。不要做损人不利己的事情。从防范角度，装终端安全软件如360或Symantec，配置windows安全域(活动目录)，装mydlp等，是能阻止或发现不正常的进程、文件、网络等活动的。</p><p>5.全身而退 vs. 追踪痕迹。攻击的敏感步骤，应尽量通过vps、tor、i2p等难于追踪的间接通信形式，要把系统中各种活动日志等及时清空或破坏，选择温和低调的策略以利于长期隐藏等。</p><p>6.攻、防双方都应了解和熟悉相关的法律，要阅读“中华人民共和国网络安全法”“中华人民共和国数据安全法”“中华人民共和国个人信息保护法”。不仅是黑客，还有网管也要了解哪些途径自己可能进去。本市某儿童照相馆买、卖公民个人信息，用于电话营销，被公安部列入年度十大典型案件。<a href="https://www.mps.gov.cn/n2254098/n4904352/c9148603/content.html">https://www.mps.gov.cn/n2254098/n4904352/c9148603/content.html</a></p><h3 id="其他知识点"><a href="#其他知识点" class="headerlink" title="其他知识点"></a>其他知识点</h3><ul><li>内存安全之BOF</li><li>传输加密技术，VPN、SSH、https以及“中间人攻击”(sslbump+icap了解下)</li><li>逆向分析技术路线、工具和方法</li><li>代理和端口映射技术和工具，比如http-proxy、socks、socat、ssh-L&#x2F;-R&#x2F;-D、ssr等</li></ul><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><h5 id="ssh"><a href="#ssh" class="headerlink" title="~&#x2F;.ssh&#x2F;*"></a>~&#x2F;.ssh&#x2F;*</h5><ol><li>含义解释<ul><li><code>~/.ssh/</code>是一个在类 Unix 系统（如 Linux、macOS）中的目录路径。<code>~</code>代表用户的主目录（home directory），不同的用户有不同的主目录，例如在 Linux 系统中，用户<code>user1</code>的主目录可能是<code>/home/user1</code>，那么<code>~/.ssh/</code>对于<code>user1</code>来说就是<code>/home/user1/.ssh/</code>。</li><li><code>.ssh</code>是一个隐藏目录（在 Unix&#x2F;Linux 系统中，文件名以 “.” 开头的文件或目录是隐藏的，默认情况下使用<code>ls</code>命令不会显示它们，需要使用<code>ls -a</code>命令才能看到），这个目录主要用于存放和 SSH（Secure Shell）相关的文件。</li><li><code>~/.ssh/*</code>中的<code>*</code>是一个通配符，表示<code>~/.ssh/</code>目录下的所有文件和子目录。</li></ul></li><li>文件内容说明<ul><li>私钥文件（例如<code>id_rsa</code>）和公钥文件（例如<code>id_rsa.pub</code>）<ul><li>SSH 使用非对称加密算法，其中私钥用于解密数据和进行数字签名，是保密的，不能泄露。公钥用于加密数据和验证签名，可以公开。例如，当你想通过 SSH 登录到远程服务器时，你可以将本地的公钥发送到远程服务器，远程服务器使用这个公钥来加密挑战信息，然后你的本地客户端使用私钥来解密这个挑战信息，从而完成身份验证。</li></ul></li><li>已知主机文件（<code>known_hosts</code>）<ul><li>这个文件记录了已经访问过的 SSH 服务器的主机密钥等信息。当你第一次连接到一个 SSH 服务器时，客户端会收到服务器发送的主机密钥，并将其存储在<code>known_hosts</code>文件中。以后每次连接时，客户端会检查服务器发送的主机密钥是否与<code>known_hosts</code>文件中记录的一致，这有助于防止中间人攻击。如果主机密钥发生变化，客户端会发出警告，提醒用户可能存在安全风险。</li></ul></li><li>配置文件（<code>config</code>）<ul><li>可以通过这个文件来配置 SSH 客户端的各种参数，比如设置不同的连接选项（如指定端口号、用户身份等），用于连接多个不同的 SSH 服务器。</li></ul></li></ul></li></ol><h5 id="74-75破解方法"><a href="#74-75破解方法" class="headerlink" title="74&#x2F;75破解方法"></a>74&#x2F;75破解方法</h5><p>在软件破解中，74 对应机器码 je，即等于则跳转，75 对应 jne，即不等于则跳转。许多软件使用 je 来对注册码进行判断，如果将 je 修改为 jne，就可能达到破解软件的目的</p><h5 id="ALSR"><a href="#ALSR" class="headerlink" title="ALSR"></a>ALSR</h5><p>地址空间布局随机化（Address Space Layout Randomization）：是一种计算机安全技术，通过将熵引入进程内存地址空间，使进程的系统调用区域、栈内存空间等在加载时随机分配虚拟地址空间，增加攻击者预测目标地址的难度，有效阻止 Ret2libs 和 ROP 等利用技术，防御缓冲区溢出攻击等内存漏洞利用方式</p><h5 id="botnet"><a href="#botnet" class="headerlink" title="botnet"></a>botnet</h5><p>Botnet 是 “机器人网络”（英文为 “robot network”）的缩写，也被称为僵尸网络。它是指通过互联网通信信道，将大量被恶意软件感染的计算机（称为 “僵尸主机” 或 “肉鸡”）连接起来形成的网络。这些受感染的计算机可以被一个或多个控制者（称为 “botmaster”）远程控制，执行各种恶意任务。</p><h5 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h5><p>chmod 是 “change mode” 的缩写，是一个用于改变文件或目录访问权限的命令，在 Unix 和类 Unix 系统（如 Linux、macOS 等）中广泛使用。文件和目录的权限决定了谁（所有者、所属组用户或其他用户）可以对其进行读取（r）、写入（w）和执行（x）操作。</p><h5 id="cmd5-com"><a href="#cmd5-com" class="headerlink" title="cmd5.com"></a>cmd5.com</h5><p><a href="https://cmd5.com/">cmd5.com</a>是一个创建于 2006 年的 MD5 在线解密破解网站，提供 MD5、SHA1、MySQL、SHA256 等多种类型的加密解密服务，其数据库庞大，拥有超过 90T 的数据记录，部分服务免费，少量收费.</p><p>该网站的特点和优势明显， 其界面设计简洁，操作方便，即使是初次使用的用户也能快速上手，能够为技术人员等在数据恢复、安全测试等方面提供便利。同时，该网站也注重用户数据的安全性，采取了多种措施保障数据安全.</p><h5 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h5><p>Cookie 是在 Web 浏览器和 Web 服务器之间传递的一小段文本信息。当用户访问一个网站时，服务器可以通过 HTTP 响应头将 Cookie 发送给浏览器，浏览器会将 Cookie 存储在本地。之后，浏览器在每次向该网站发送请求时，会把相应的 Cookie 信息通过 HTTP 请求头再发送回服务器。</p><h5 id="CreateRemoteThread"><a href="#CreateRemoteThread" class="headerlink" title="CreateRemoteThread()"></a>CreateRemoteThread()</h5><p>CreateRemoteThread()是 Windows API 中的一个函数，它允许一个进程在另一个进程的地址空间中创建一个新的线程。该函数在 Windows 操作系统的多线程编程和进程间通信中起着关键的作用。</p><h5 id="CTF"><a href="#CTF" class="headerlink" title="CTF"></a>CTF</h5><p>CTF（Capture The Flag）一般译作夺旗赛，是一种网络安全竞赛形式。其目标是通过解决各种信息安全相关的挑战来获取 “旗帜”（Flag），这些旗帜通常是一个特定格式的字符串，代表着参赛者成功完成某个挑战的凭证。</p><h5 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h5><p>curl是一个命令行工具，用于在各种网络协议下传输数据。它支持多种协议，如 HTTP、HTTPS、FTP、FTPS、SCP、SFTP、TFTP、LDAP、DAP、FILE 等。<code>curl</code>的名字是 “Client for URLs” 的缩写，它可以从指定的 URL 获取数据，也可以将数据发送到指定的 URL。</p><h5 id="DDOS"><a href="#DDOS" class="headerlink" title="DDOS"></a>DDOS</h5><p>DDoS（Distributed Denial of Service），即分布式拒绝服务攻击。它是一种恶意的网络攻击手段，攻击者通过控制大量（通常是数千台甚至更多）的计算机（这些计算机被称为 “僵尸主机” 或 “肉鸡”）组成僵尸网络（Botnet），同时向目标服务器或网络资源发送海量的请求，使得目标服务器或网络资源被请求洪流淹没，无法正常处理合法用户的请求，从而导致服务中断或性能严重下降。</p><h5 id="DEP"><a href="#DEP" class="headerlink" title="DEP"></a>DEP</h5><p>数据执行保护（Data Execution Prevention，DEP）是一种计算机安全技术，主要用于防止恶意代码在计算机内存中的数据区域执行。它通过硬件和软件相结合的方式，将内存划分为可执行区域和不可执行区域，当处理器执行到标记为不可执行的内存区域中的代码时，会引发异常并阻止代码的执行。</p><h5 id="dex2jar"><a href="#dex2jar" class="headerlink" title="dex2jar"></a>dex2jar</h5><p>dex2jar 是一个将 Android 的.dex（Dalvik Executable）文件转换为 Java 的.jar（Java Archive）文件的工具。在 Android 开发和安全分析领域有广泛的应用。</p><h5 id="DLL-Inject"><a href="#DLL-Inject" class="headerlink" title="DLL Inject"></a>DLL Inject</h5><p>DLL 注入（DLL Inject）是一种在 Windows 操作系统环境下的技术，用于将一个动态链接库（DLL）加载到目标进程的地址空间中。这使得注入的 DLL 能够在目标进程的上下文中执行代码，从而可以实现对目标进程的修改、监控或扩展等操作。</p><h5 id="DllMain"><a href="#DllMain" class="headerlink" title="DllMain()"></a>DllMain()</h5><p><code>DllMain()</code>是动态链接库（DLL）的入口点函数。当一个 DLL 被加载到进程的地址空间或者从进程的地址空间卸载，又或者是进程中发生了线程相关的事件时，操作系统会调用这个函数。</p><p>它主要用于执行一些与 DLL 初始化和清理相关的任务。例如，初始化 DLL 中使用的全局变量、分配资源（如内存、文件句柄等），以及在 DLL 卸载时释放这些资源。</p><h5 id="DLP"><a href="#DLP" class="headerlink" title="DLP"></a>DLP</h5><p>数据丢失防护是一种网络安全技术，旨在防止企业敏感数据或机密信息在未经授权的情况下被传输、存储或使用。它通过识别、监控和保护数据在各种端点（如笔记本电脑、移动设备）、网络和存储系统中的流动，帮助企业满足合规性要求并降低数据泄露的风险。</p><h5 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h5><p>docker 是一个开源的容器化平台，它允许开发者将应用程序及其依赖项打包成一个可移植的容器。容器是一种轻量级、独立运行的软件单元，包含了运行应用程序所需的一切，如代码、运行时环境、系统工具、系统库等。就好像是一个独立的小盒子，里面装着应用程序和它运行所需的所有东西，这个小盒子可以在任何支持 Docker 的环境中运行。</p><h5 id="DRM"><a href="#DRM" class="headerlink" title="DRM"></a>DRM</h5><p>DRM 是数字版权管理（Digital Rights Management）的简称。它是一系列访问控制技术，用于保护数字内容（如软件、音乐、电影、电子书等）的版权。通过 DRM 技术，内容提供商可以对数字内容的使用进行限制和管理，确保只有经过授权的用户才能以合法的方式访问和使用这些内容。</p><h5 id="GDPR"><a href="#GDPR" class="headerlink" title="GDPR"></a>GDPR</h5><p>GDPR 是《通用数据保护条例》（General Data Protection Regulation）的英文缩写，它是欧盟（EU）制定的一项全面的数据保护法规。该条例于 2018 年 5 月 25 日在欧盟成员国正式生效，旨在加强对欧盟公民个人数据的保护，并规范企业和组织对个人数据的处理活动。</p><h5 id="git"><a href="#git" class="headerlink" title="git"></a>git</h5><p>Git 是一个分布式版本控制系统（DVCS - Distributed Version Control System）。它主要用于跟踪文件的变化，协助开发团队协作开发软件项目或管理各种文档等内容。版本控制系统可以记录文件的每一次修改，方便用户查看历史版本、比较差异，并且能够在需要的时候恢复到之前的某个版本。</p><h5 id="heartbeat"><a href="#heartbeat" class="headerlink" title="heartbeat"></a>heartbeat</h5><p>Heartbeat 通常是指心跳机制，是计算机系统和网络领域中用于检测系统或设备是否正常运行、网络连接是否通畅以及应用程序之间是否保持通信的一种机制。它通过周期性地发送和接收信号（就像心跳一样）来实现这种检测功能。</p><h5 id="heartbleed"><a href="#heartbleed" class="headerlink" title="heartbleed"></a>heartbleed</h5><p>Heartbleed 是一个严重的安全漏洞，它主要影响了 OpenSSL 软件库。OpenSSL 是一个广泛用于实现安全套接层（SSL）和传输层安全（TLS）协议的开源密码库，这些协议在互联网通信中用于加密数据传输，如网页浏览、电子邮件、即时通讯等众多应用场景中的安全连接。Heartbleed 漏洞允许攻击者从服务器内存中读取敏感信息，包括但不限于加密密钥、用户名和密码、信用卡号码等，从而对用户的隐私和网络安全构成巨大威胁。</p><h5 id="honeypot"><a href="#honeypot" class="headerlink" title="honeypot"></a>honeypot</h5><p>蜜罐（Honeypot）是一种网络安全防御技术中的诱饵系统。它是一个被设计成看似包含有价值信息（如敏感数据、系统漏洞等）的计算机系统、网络服务或者网络资源，其目的是吸引攻击者，从而收集攻击者的信息，如攻击方式、工具、动机等，同时也可以将攻击者的注意力从真正的关键系统和信息上转移开。</p><h5 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h5><p>HTTPS（Hypertext Transfer Protocol Secure）是超文本传输安全协议，它是一种在计算机网络上进行安全通信的协议。是在 HTTP（超文本传输协议）的基础上加入 SSL&#x2F;TLS（安全套接层 &#x2F; 传输层安全）加密协议，用于保障数据传输的安全性和完整性，确保用户在浏览网页、进行网上交易等网络活动时，信息不会被窃取或篡改。</p><h5 id="ICAP"><a href="#ICAP" class="headerlink" title="ICAP"></a>ICAP</h5><p>ICAP（Internet Content Adaptation Protocol）即互联网内容适配协议。它是一种用于在互联网内容服务器和内容适配设备之间进行通信的协议，主要目的是对互联网内容（如网页、文件等）进行过滤、修改、转换等操作，以满足不同的需求，如内容安全检查、内容优化、访问控制等。</p><h5 id="IDApro"><a href="#IDApro" class="headerlink" title="IDApro"></a>IDApro</h5><p>IDA Pro（Interactive Disassembler Professional）是一款功能强大的交互式反汇编工具，主要用于软件逆向工程和恶意软件分析。它能够将二进制文件（如可执行文件、动态链接库、固件等）转换为汇编语言代码或更高级的编程语言表示形式，帮助安全研究人员、软件开发者和黑客理解程序的内部结构和工作原理。</p><h5 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h5><p>iptables 是一个用户空间的应用层工具，用于在 Linux 操作系统内核中配置防火墙规则。它通过操作内核中的 Netfilter 数据包过滤框架，来决定哪些网络数据包可以进入、离开或者在主机内部转发，从而实现网络访问控制、安全防护等功能。</p><h5 id="Kerberos"><a href="#Kerberos" class="headerlink" title="Kerberos"></a>Kerberos</h5><p>Kerberos 是一种网络认证协议，它的设计目的是在不安全的网络环境中，通过使用密钥加密技术，为客户端和服务器之间提供安全的身份验证服务。这个协议以希腊神话中看守地狱大门的三头犬刻耳柏洛斯（Kerberos）命名，寓意着它像这只神兽一样守护着网络的安全大门。</p><h5 id="Metasploit"><a href="#Metasploit" class="headerlink" title="Metasploit"></a>Metasploit</h5><p>Metasploit 是一款开源的、非常强大的渗透测试框架。它为安全专业人员和渗透测试人员提供了一个集成的平台，用于发现、利用和验证计算机系统和网络中的安全漏洞。其目的是帮助用户评估目标系统的安全性，而不是用于恶意攻击。</p><h5 id="mydlp"><a href="#mydlp" class="headerlink" title="mydlp"></a>mydlp</h5><p>MyDLP 是一款数据丢失防护（Data Loss Prevention，DLP）解决方案，最初作为免费和开源软件发布。</p><h5 id="NAS"><a href="#NAS" class="headerlink" title="NAS"></a>NAS</h5><p>NAS 是一种专门用于存储数据的设备，它独立于计算机本身，通过网络连接到多个用户设备，如计算机、智能手机、平板电脑等。从架构上看，它像是一个带有网络接口的存储服务器，把存储功能从计算机主机中分离出来，使得数据存储更加集中、高效并且易于管理。</p><h5 id="nmap"><a href="#nmap" class="headerlink" title="nmap"></a>nmap</h5><p>Nmap（Network Mapper）是一款开源的网络扫描和安全审计工具。它主要用于发现网络中的主机和服务，确定这些主机上开放的端口、运行的服务及其版本，还可以用于评估网络的安全性，检测网络中的潜在安全漏洞。Nmap 被广泛应用于网络管理、渗透测试、安全评估等领域。</p><h5 id="ntop-ntopng"><a href="#ntop-ntopng" class="headerlink" title="ntop&#x2F;ntopng"></a>ntop&#x2F;ntopng</h5><p>ntop 是一款用于网络流量监控和分析的工具，ntopng 是它的下一代版本。它们提供了可视化的方式来查看网络流量的详细信息，帮助网络管理员深入了解网络使用情况、发现异常流量和优化网络性能。</p><h5 id="O-LLVM"><a href="#O-LLVM" class="headerlink" title="O-LLVM"></a>O-LLVM</h5><p>O - LLVM（Obfuscator - LLVM）是基于 LLVM（Low Level Virtual Machine）编译器基础设施开发的一个代码混淆工具。它的主要目的是通过对程序代码进行转换和变形，增加逆向工程的难度，保护软件知识产权，防止代码被轻易理解、分析和篡改。</p><h5 id="ollydbg"><a href="#ollydbg" class="headerlink" title="ollydbg"></a>ollydbg</h5><p>OllyDbg 是一款强大的、用户界面友好的 32 位 Windows 平台下的动态调试工具。主要用于软件逆向工程、恶意软件分析以及调试应用程序，帮助开发人员和安全研究人员理解程序的内部工作机制、查找程序漏洞和分析恶意软件的行为。</p><h5 id="PAP"><a href="#PAP" class="headerlink" title="PAP"></a>PAP</h5><p>密码验证协议（Password Authentication Protocol）的缩写，是一种身份验证协议，用于在网络连接中验证用户身份。用户输入密码后，其名称和密码以明文形式通过线路发送到服务器，并与服务器上的用户帐户名和密码数据库进行比较。由于密码以明文传输，容易受到窃听攻击，安全性较低，通常只有在客户端不支持其他身份认证协议时才会使用。</p><h5 id="Phishing"><a href="#Phishing" class="headerlink" title="Phishing"></a>Phishing</h5><p>Phishing（网络钓鱼）是一种网络欺诈手段。攻击者通过伪装成可信赖的实体（如知名银行、电子商务平台、社交媒体网站等），通常利用电子邮件、短信、即时通讯软件等通信渠道，诱使受害者提供敏感信息（如用户名、密码、信用卡号码、社会安全号码等）或执行某些有害操作（如点击恶意链接、下载恶意软件）。</p><h5 id="PKCS-11"><a href="#PKCS-11" class="headerlink" title="PKCS#11"></a>PKCS#11</h5><p>PKCS#11（Public - Key Cryptography Standards #11）即公钥密码学标准第 11 号，是一种由 RSA 实验室制定的标准应用编程接口（API），主要用于在各种密码设备（如智能卡、硬件安全模块 - HSM）中管理和使用加密密钥、执行加密和解密操作以及进行数字签名和验证等密码学功能。</p><h5 id="RADIUS"><a href="#RADIUS" class="headerlink" title="RADIUS"></a>RADIUS</h5><p>RADIUS（Remote Authentication Dial - In User Service）即远程认证拨号用户服务，是一种网络协议，主要用于对网络接入用户进行认证、授权和计费（AAA）。它提供了一种集中式的用户管理方式，使得网络服务提供商（NSP）和企业网络能够有效地控制用户对网络资源的访问。</p><h5 id="robots-txt"><a href="#robots-txt" class="headerlink" title="robots.txt"></a>robots.txt</h5><p>robots.txt 是一个纯文本文件，用于告知网络搜索引擎的爬虫（也称为机器人或蜘蛛）哪些部分的网站内容可以被抓取和索引，哪些部分应该被避开。它是一种网站与搜索引擎之间的沟通方式，通过定义规则来引导搜索引擎爬虫的访问行为，从而帮助网站管理者更好地控制网站内容在搜索引擎中的曝光度。</p><h5 id="rust"><a href="#rust" class="headerlink" title="rust"></a>rust</h5><p>Rust 是一种系统编程语言，由 Mozilla 主导开发，它专注于安全性、性能和并发性。其设计目标是在不牺牲性能的前提下，提供内存安全保证，同时支持高效的多线程编程，避免常见的编程错误，如空指针引用、缓冲区溢出和数据竞争。</p><h5 id="SGX"><a href="#SGX" class="headerlink" title="SGX"></a>SGX</h5><p>SGX（Software Guard Extensions）即英特尔软件防护扩展，是英特尔处理器的一组硬件扩展功能，用于增强软件的安全性。它提供了一个受保护的执行环境，称为飞地（Enclave），在这个环境中，即使操作系统或其他特权软件被攻破，敏感数据和代码仍然可以得到保护。</p><h5 id="shadowsocks"><a href="#shadowsocks" class="headerlink" title="shadowsocks"></a>shadowsocks</h5><p>Shadowsocks（影梭）是一种基于 Socks5 代理方式的网络代理软件。它最初是为了帮助用户突破网络限制访问外部网站而设计的，通过加密网络流量并转发请求，使得用户可以绕过一些网络封锁或者限制访问策略。</p><h5 id="Shellcode"><a href="#Shellcode" class="headerlink" title="Shellcode"></a>Shellcode</h5><p>Shellcode 是一段用于利用软件漏洞的机器语言代码。它的名字来源于其最初的用途，即通过触发漏洞来获取目标系统的一个命令行 Shell（如在 Unix&#x2F;Linux 系统中的 Bash Shell 或在 Windows 系统中的 CMD Shell），进而实现对目标系统的控制。不过，随着技术的发展，Shellcode 的用途已经不限于获取 Shell，还可以用于执行各种恶意操作，如窃取数据、植入后门等。</p><h5 id="socat"><a href="#socat" class="headerlink" title="socat"></a>socat</h5><p>Socat 是一个多功能的网络工具，它可以在两个双向字节流之间建立连接，并在它们之间传输数据。这两个字节流可以是来自文件、管道、设备、网络套接字（如 TCP 或 UDP 套接字）等各种数据源。它就像是一个数据管道的搭建者，能够灵活地将不同类型的数据通道连接起来，以满足各种网络数据传输和转换的需求。</p><h5 id="sql注入"><a href="#sql注入" class="headerlink" title="sql注入"></a>sql注入</h5><p>SQL 注入（SQL Injection）是一种常见的网络安全漏洞，攻击者通过在用户输入或其他数据源中插入恶意的 SQL 语句，利用目标应用程序对这些输入处理不当的情况，欺骗数据库执行非预期的 SQL 操作，从而获取敏感数据、篡改数据、执行系统命令或破坏数据库的完整性等。</p><h5 id="ssh-D"><a href="#ssh-D" class="headerlink" title="ssh -D"></a>ssh -D</h5><p><code>ssh -D</code>是 SSH（Secure Shell）命令的一个选项。SSH 是一种网络协议，用于在不安全的网络上安全地访问远程计算机系统。<code>-D</code>选项用于创建一个本地的 SOCKS 代理。通过这个代理，客户端可以将其网络流量转发到远程服务器，并且这个过程是加密的，能够增强隐私保护并绕过一些网络限制。</p><h5 id="ssh-L"><a href="#ssh-L" class="headerlink" title="ssh -L"></a>ssh -L</h5><p><code>ssh -L</code>是 SSH（Secure Shell）命令的一个选项，用于本地端口转发。它允许用户将本地机器（客户端）上的一个端口与远程服务器上的一个端口进行绑定，使得发送到本地指定端口的连接请求能够通过 SSH 加密通道转发到远程服务器的指定端口，就好像在本地和远程之间建立了一个安全的隧道，用于特定端口的通信。</p><h5 id="ssh-R"><a href="#ssh-R" class="headerlink" title="ssh -R"></a>ssh -R</h5><p><code>ssh -R</code>是 SSH（Secure Shell）协议中的一个命令选项，用于实现远程端口转发。与<code>ssh -L</code>（本地端口转发）相反，它是将远程服务器上的一个端口绑定到本地机器（客户端）的一个端口，使得对远程服务器指定端口的访问请求能够通过 SSH 加密通道转发到本地机器对应的端口，从而允许外部网络通过远程服务器访问本地服务，就好像在本地和远程之间搭建了一个反向的安全通道。</p><h5 id="SSO"><a href="#SSO" class="headerlink" title="SSO"></a>SSO</h5><p>SSO（Single Sign - On）单点登录是一种方便用户访问多个相关系统的身份验证方案。从用户角度看，它就像是一把 “万能钥匙”，只需用一组登录凭证（如用户名和密码），就能开启多个不同系统的 “大门”。从系统管理角度，它是一种集中化的身份管理策略，将多个分散的身份验证过程整合为一。</p><h5 id="SYN-flood"><a href="#SYN-flood" class="headerlink" title="SYN flood"></a>SYN flood</h5><p>SYN Flood（同步洪水攻击）是一种典型的分布式拒绝服务攻击（DDoS）方式。它利用了 TCP（传输控制协议）三次握手的过程来实现攻击目的。正常情况下，TCP 三次握手用于建立可靠的连接，但攻击者通过发送大量伪造的带有 SYN（同步）标志的 TCP 请求，使得目标服务器忙于处理这些半连接请求，从而消耗服务器资源，最终导致服务器无法正常处理合法用户的请求。</p><h5 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h5><p>tcpdump 是一款强大的、广泛用于网络分析的命令行工具，主要用于在网络接口上捕获和分析网络数据包。它可以捕获流经指定网络接口的各种协议（如 TCP、UDP、ICMP 等）的数据包，并将其内容以可读的形式显示出来，帮助网络工程师、系统管理员和安全分析师了解网络流量的细节，检测网络故障、安全漏洞或分析应用程序的网络行为。</p><h5 id="TOR"><a href="#TOR" class="headerlink" title="TOR"></a>TOR</h5><p>TOR（The Onion Router）是第二代洋葱路由网络，是一种匿名通信技术。它通过在全球范围内由志愿者运行的分布式服务器网络（称为中继节点）来转发用户的网络流量，以隐藏用户的真实 IP 地址和网络活动路径，从而保护用户的隐私和匿名性。</p><h5 id="VNC"><a href="#VNC" class="headerlink" title="VNC"></a>VNC</h5><p>VNC（Virtual Network Computing）即虚拟网络计算，是一种远程桌面共享系统。它允许用户通过网络连接远程访问和控制另一台计算机的桌面环境，就好像直接坐在那台计算机前操作一样。VNC 使用客户端 - 服务器架构，通过在远程计算机（服务器端）上运行 VNC 服务器软件，以及在本地计算机（客户端）上运行 VNC 客户端软件来实现远程桌面访问。</p><h5 id="vulhub"><a href="#vulhub" class="headerlink" title="vulhub"></a>vulhub</h5><p>Vulhub 是一个面向安全研究人员和爱好者的开源漏洞环境集合。它提供了一系列预先构建好的、包含各种已知安全漏洞的容器化环境，这些环境基于 Docker 和 Docker - Compose 技术。其目的是方便安全从业者在一个可控的、便捷的场景下学习、研究和测试安全漏洞，帮助他们更好地理解漏洞的原理、利用方式和防御措施。</p><h5 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h5><p>wget 是一个在命令行环境下用于从网络上下载文件的自由软件。它是一个非交互式的工具，支持通过 HTTP、HTTPS、FTP 等多种常见的网络协议来获取文件，并且功能强大、使用灵活，被广泛应用于 Linux、Unix 以及其他类 Unix 系统中，也有适用于 Windows 的版本。</p><h5 id="whois"><a href="#whois" class="headerlink" title="whois"></a>whois</h5><p>Whois 是一种用于查询互联网域名注册信息和 IP 地址相关信息的协议和工具。它可以帮助用户获取域名的所有者、注册商、注册日期、过期日期、域名服务器等详细信息，也可以用于查询 IP 地址的分配机构等内容。这对于网络管理、安全研究、知识产权保护等领域都非常有用。</p><h5 id="Windows更新服务"><a href="#Windows更新服务" class="headerlink" title="Windows更新服务"></a>Windows更新服务</h5><p>Windows 更新服务是微软为 Windows 操作系统提供的一种机制，用于向用户的计算机系统推送系统更新、安全补丁、驱动程序更新以及软件功能改进等内容。它能够确保 Windows 系统保持最新状态，提高系统的安全性、稳定性和性能，并且可以为用户提供新的功能体验。</p><h5 id="Wireshark"><a href="#Wireshark" class="headerlink" title="Wireshark"></a>Wireshark</h5><p>Wireshark 是一款广泛使用的开源网络数据包分析工具。它能够捕获网络接口上的数据包，并对这些数据包进行详细的分析，以帮助网络管理员、安全专家、开发人员等理解网络协议、排查网络故障、分析网络安全事件以及进行网络性能优化等诸多工作。</p><h5 id="x64dbg"><a href="#x64dbg" class="headerlink" title="x64dbg"></a>x64dbg</h5><p>x64dbg 是一款开源的 Windows 平台下的调试工具，主要用于调试 64 位和 32 位的可执行文件，包括应用程序（.exe）、动态链接库（.dll）等。它为逆向工程师、安全研究人员和软件开发人员提供了强大的调试功能，帮助他们分析软件的内部工作机制、查找软件漏洞、修复程序错误等。</p><h5 id="XKMS"><a href="#XKMS" class="headerlink" title="XKMS"></a>XKMS</h5><p>XKMS（XML Key Management Specification）即 XML 密钥管理规范。它是一种基于 XML（可扩展标记语言）的标准，用于在分布式环境中进行密钥管理，旨在简化公钥基础设施（PKI）的部署和管理，使应用程序更容易使用和处理数字证书和密钥相关的操作。</p><h5 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h5><p>XSS（Cross - Site Scripting）即跨站脚本攻击，是一种常见的网络安全漏洞。它是指攻击者通过在目标网站中注入恶意脚本（通常是 JavaScript，但也可能是其他脚本语言，如 VBScript），当用户访问被注入了恶意脚本的页面时，浏览器会执行这些脚本，从而导致用户信息泄露、账户被盗用或其他恶意行为。</p>]]></content>
      
      
      <categories>
          
          <category> 大学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目实训个人周报合集</title>
      <link href="/2024/06/24/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%AE%AD%E4%B8%AA%E4%BA%BA%E5%91%A8%E6%8A%A5%E5%90%88%E9%9B%86/"/>
      <url>/2024/06/24/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%AE%AD%E4%B8%AA%E4%BA%BA%E5%91%A8%E6%8A%A5%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h3 id="4-14"><a href="#4-14" class="headerlink" title="4.14"></a>4.14</h3><p>我们组的项目是基于大模型的知识问答教育系统，我在前期的任务是数据采集和处理清洗，以便于构建数据集训练大模型。</p><p>基于调查研究，我对于数据收集的关键点做出了以下归纳。</p><ul><li><p><strong>准确性</strong>：确保数据来源可靠，内容准确无误。错误的信息会导致模型输出错误答案，影响用户体验和教育效果。</p></li><li><p><strong>更新性</strong>：确保数据是最新的，特别是对于动态变化的领域，如科技、法律等。</p></li><li><p><strong>教育层次</strong>：覆盖从基础教育到高等教育的内容，适应不同学习阶段的用户需求。</p></li><li><p><strong>结构化数据</strong>：优先选择结构化数据（如数据库、表格），便于处理和分析。</p></li><li><p><strong>隐私保护</strong>：确保用户数据的匿名化处理，避免泄露个人信息。</p></li><li><p><strong>合规性</strong>：遵守数据保护法律法规，如GDPR等，确保数据收集和使用过程中的合法合规性。</p></li></ul><p>在开始的时候，我准备从百度百科、csdn等知识网站上收集数据，但是我发现这些网站上的数据质量良莠不齐，有的甚至有常识性错误，难以在爬取的时候进行分辨；并且这些数据的格式不一致，在后期处理的时候会造成麻烦，于是放弃。</p><p>然后我找到了Hugging Face 的 Datasets 库，这个库提供了大量预构建的数据集，涵盖了广泛的任务和领域，包括文本分类、情感分析、机器翻译、问答、对话系统等。这些数据集经过整理和优化，便于用户直接使用。这个库还可以通过简单的 API 调用轻松下载和加载数据集，无需手动下载和处理数据文件，比较方便。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/29/6657005b61ff9.png" alt="Hugging Face 的 Datasets 库.png"></p><p>于是我决定在这里进行数据的收集。因为我们的项目是问答系统，所以我筛选了可能用得到的QA数据集。以下是我认为能用到的数据集，供给大模型训练。</p><p>医疗：<a href="https://huggingface.co/datasets/lavita/medical-qa-datasets?row=15">https://huggingface.co/datasets/lavita/medical-qa-datasets?row=15</a></p><p>​<a href="https://huggingface.co/datasets/blinoff/medical_qa_ru_data?row=7">https://huggingface.co/datasets/blinoff/medical_qa_ru_data?row=7</a></p><p>​<a href="https://huggingface.co/datasets/medalpaca/medical_meadow_medqa">https://huggingface.co/datasets/medalpaca/medical_meadow_medqa</a></p><p>中医：<a href="https://huggingface.co/datasets/FreedomIntelligence/huatuo_knowledge_graph_qa">https://huggingface.co/datasets/FreedomIntelligence/huatuo_knowledge_graph_qa</a></p><p>​<a href="https://huggingface.co/datasets/FreedomIntelligence/huatuo_encyclopedia_qa/viewer/default/train?p=3624&row=362400">https://huggingface.co/datasets/FreedomIntelligence/huatuo_encyclopedia_qa/viewer/default/train?p=3624&amp;row=362400</a></p><p>中文综合：<a href="https://huggingface.co/datasets/m-a-p/COIG-CQIA">https://huggingface.co/datasets/m-a-p/COIG-CQIA</a></p><p>博客节目：<a href="https://huggingface.co/datasets/wavpub/JinJinLeDao_QA_Dataset">https://huggingface.co/datasets/wavpub/JinJinLeDao_QA_Dataset</a></p><p>哲学：<a href="https://huggingface.co/datasets/sayhan/strix-philosophy-qa/viewer/default/train?p=1337&row=133777">https://huggingface.co/datasets/sayhan/strix-philosophy-qa/viewer/default/train?p=1337&amp;row=133777</a></p><p>心理健康：<a href="https://huggingface.co/datasets/Amod/mental_health_counseling_conversations?row=7">https://huggingface.co/datasets/Amod/mental_health_counseling_conversations?row=7</a></p><p>小学数学：<a href="https://huggingface.co/datasets/microsoft/orca-math-word-problems-200k">https://huggingface.co/datasets/microsoft/orca-math-word-problems-200k</a></p><p><strong>计算机相关</strong></p><p>数学：<a href="https://huggingface.co/datasets/math-ai/StackMathQA">https://huggingface.co/datasets/math-ai/StackMathQA</a></p><p>python编程：<a href="https://huggingface.co/datasets/lucasmccabe-lmi/codex_math_qa_alpaca_style/viewer/default/train?p=280&row=28004">https://huggingface.co/datasets/lucasmccabe-lmi/codex_math_qa_alpaca_style/viewer/default/train?p=280&amp;row=28004</a></p><p>​<a href="https://huggingface.co/datasets/flytech/python-codes-25k">https://huggingface.co/datasets/flytech/python-codes-25k</a></p><p>sql编程：<a href="https://huggingface.co/datasets/b-mc2/sql-create-context">https://huggingface.co/datasets/b-mc2/sql-create-context</a></p><p>代码指令：<a href="https://huggingface.co/datasets/m-a-p/CodeFeedback-Filtered-Instruction?row=38">https://huggingface.co/datasets/m-a-p/CodeFeedback-Filtered-Instruction?row=38</a></p><p>​   <a href="https://huggingface.co/datasets/m-a-p/Code-Feedback/viewer/default/train?p=663&row=66310">https://huggingface.co/datasets/m-a-p/Code-Feedback/viewer/default/train?p=663&amp;row=66310</a></p><p>论文NLP：<a href="https://huggingface.co/datasets/allenai/qasper?row=0">https://huggingface.co/datasets/allenai/qasper?row=0</a></p><p>stackExchange：<a href="https://huggingface.co/datasets/lvwerra/stack-exchange-paired?row=16">https://huggingface.co/datasets/lvwerra/stack-exchange-paired?row=16</a></p><p>综合包括computer science：<a href="https://huggingface.co/datasets/MMMU/MMMU/viewer/Computer_Science/test?row=2">https://huggingface.co/datasets/MMMU/MMMU/viewer/Computer_Science/test?row=2</a></p><p>​   <a href="https://huggingface.co/datasets/cais/mmlu/viewer/college_computer_science?row=29">https://huggingface.co/datasets/cais/mmlu/viewer/college_computer_science?row=29</a></p><p>​   <a href="https://huggingface.co/datasets/ikala/tmmluplus/viewer/computer_science/test">https://huggingface.co/datasets/ikala/tmmluplus/viewer/computer_science/test</a></p><p>然后我在kaggle网站上找到了一个与我们项目适配程度较大的数据集，是关于计算机理论知识的问答集：</p><p><a href="https://www.kaggle.com/datasets/mujtabamatin/computer-science-theory-qa-dataset">https://www.kaggle.com/datasets/mujtabamatin/computer-science-theory-qa-dataset</a></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/29/66570410f2522.png" alt="kaggle数据集.png"></p><p>结合做大模型相关工作的同学的反馈，我选取了上述中的几个数据集，整理成了csv文件，以便于后续的数据清洗等工作。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/29/665704bf105aa.png" alt="csv文件.png"></p><h3 id="4-23"><a href="#4-23" class="headerlink" title="4.23"></a>4.23</h3><p>在大模型训练中，数据分析是确保模型性能和训练效率的关键步骤。通过对训练数据进行全面的分析，可以发现潜在的问题和优化空间，提高模型的整体效果。以下是数据分析过程中需要重点关注的方面及其要点：</p><ol><li><strong>数据质量</strong></li></ol><ul><li><strong>准确性</strong>：检查数据是否有错误、错别字或不正确的标签。错误的数据会误导模型学习，降低其准确性。</li><li><strong>完整性</strong>：确保数据集的完整性，避免缺失值或不完整的样本。缺失数据可能导致训练偏差。</li></ul><ol start="2"><li><strong>数据分布</strong></li></ol><ul><li><strong>类别分布</strong>：分析分类任务中的类别分布，确保数据集中的类别分布均衡。如果类别不均衡，模型可能会偏向多数类别。</li><li><strong>特征分布</strong>：对于回归或其他任务，检查特征的分布情况，确保没有异常值或过度偏斜的分布。</li></ul><ol start="3"><li><strong>数据多样性</strong></li></ol><ul><li><strong>文本多样性</strong>：在NLP任务中，检查文本的多样性，包括词汇、句法结构和主题。多样性高的数据集有助于提高模型的泛化能力。</li><li><strong>样本多样性</strong>：确保数据集中包含足够多样的样本，以覆盖不同的场景和情况。</li></ul><ol start="4"><li><strong>文本长度</strong></li></ol><ul><li><strong>长度分布</strong>：分析文本长度的分布情况，确定合适的最大长度和最小长度。这有助于设定模型输入的最大序列长度，优化资源使用。</li><li><strong>截断和填充</strong>：研究需要截断和填充的样本比例，确保截断和填充策略不会显著影响数据质量。</li></ul><ol start="5"><li><strong>数据预处理</strong></li></ol><ul><li><strong>清洗和标准化</strong>：对数据进行必要的清洗和标准化处理，如去除噪声、统一格式和处理特殊字符。</li><li><strong>去重</strong>：检查并去除重复的样本，避免模型在重复数据上过度拟合。</li></ul><p>观察发现，QA数据集中有空格、“答：”、乱码等不需要的字样，于是进行处理。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/29/665707514d0e2.png" alt="Snipaste_2024-05-29_18-46-10.png"></p><p>通过上述模版代码，去除了数据集中”答：”的字样，然后如法炮制，将空格和乱码都进行了去除和清洗。清理完后的部分数据如下图。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/29/665707eaa2fa9.png" alt="Snipaste_2024-05-29_18-48-34.png"></p><p>可以观察到，数据的结构比较清晰，q列是问题，a列是答案，并且数据中的空格、乱码等已经被去除。</p><p>下面我进行了数据分析,主要是分析了文本长度。<strong>文本长度</strong>在大模型训练中很重要，主要有以下几点。</p><ul><li><p><strong>丰富的上下文</strong>：较长的文本通常包含更多的信息和上下文，有助于模型理解复杂的语义关系和捕捉长距离依赖。</p></li><li><p><strong>过长文本的挑战</strong>：处理过长的文本可能导致模型过拟合或者捕捉到过多无关信息，反而可能降低模型性能。需要找到一个平衡点，既包含足够的信息，又不过多冗余。</p></li><li><p><strong>最大长度设定</strong>：在训练过程中，通常会设定一个最大文本长度，超过该长度的文本会被截断。这种策略需要权衡信息完整性和计算资源。</p></li><li><p><strong>任务特定需求</strong>：不同任务对文本长度的需求不同。例如，句子分类任务可能不需要很长的文本，而文档摘要生成则需要处理更长的文本。</p></li><li><p><strong>微调阶段</strong>：在微调阶段，根据具体任务调整文本长度，可以优化模型性能和资源利用效率。</p></li></ul><p>分析文本长度的代码如下。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/29/665708b2dfe85.png" alt="Snipaste_2024-05-29_18-52-10.png"></p><h3 id="5-06"><a href="#5-06" class="headerlink" title="5.06"></a>5.06</h3><p>在大模型训练中，数据集划分、数据增强和数据可视化是至关重要的步骤，确保模型训练的有效性、可靠性和可解释性。下面是对这三个方面的具体实现方法的详细说明。</p><p> <strong>数据集划分：合理划分训练、验证和测试集</strong></p><ol><li><p>比例划分：</p><p>常用的划分比例是70%用于训练，15%用于验证，15%用于测试。具体比例可以根据数据集的规模和任务的需求进行调整。</p></li><li><p>随机划分：</p><p>使用随机数生成器确保数据集划分的随机性，避免样本顺序导致的偏差。</p></li><li><p>分层抽样：</p><p>在分类任务中，确保各类样本在训练、验证和测试集中的比例一致，可以使用分层抽样。</p></li><li><p>时间序列数据划分：</p><p>在时间序列数据中，按照时间顺序划分数据，确保训练集早于验证集，验证集早于测试集。</p></li></ol><p>这里我使用随机划分，使用<code>sklearn.model_selection.train_test_split</code>函数实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">train_data, test_data = train_test_split(data, test_size=<span class="number">0.3</span>, random_state=<span class="number">42</span>)</span><br><span class="line">train_data, val_data = train_test_split(train_data, test_size=<span class="number">0.2</span>, random_state=<span class="number">42</span>)</span><br></pre></td></tr></table></figure><p><strong>数据增强：同义词替换、回译、随机删除</strong></p><p>1.同义词替换</p><p>随机选择句子中的词，替换为其同义词。</p><p>这里我使用NLTK实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> nltk.corpus <span class="keyword">import</span> wordnet</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">synonym_replacement</span>(<span class="params">text</span>):</span><br><span class="line">    words = text.split()</span><br><span class="line">    new_words = words.copy()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(words)):</span><br><span class="line">        synonyms = wordnet.synsets(words[i])</span><br><span class="line">        <span class="keyword">if</span> synonyms:</span><br><span class="line">            new_words[i] = synonyms[<span class="number">0</span>].lemmas()[<span class="number">0</span>].name()</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join(new_words)</span><br></pre></td></tr></table></figure><p>2.回译：</p><p>将文本翻译成另一种语言，再翻译回来，以生成新的文本。</p><p>我这里使用谷歌的翻译API（Google Translate API）实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> googletrans <span class="keyword">import</span> Translator</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">back_translation</span>(<span class="params">text, src=<span class="string">&#x27;en&#x27;</span>, dest=<span class="string">&#x27;de&#x27;</span></span>):</span><br><span class="line">    translator = Translator()</span><br><span class="line">    translated = translator.translate(text, src=src, dest=dest).text</span><br><span class="line">    back_translated = translator.translate(translated, src=dest, dest=src).text</span><br><span class="line">    <span class="keyword">return</span> back_translated</span><br></pre></td></tr></table></figure><p>3.随机删除：</p><p>随机删除句子中的一些词，生成新的变体。</p><p>实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">random_deletion</span>(<span class="params">text, p=<span class="number">0.1</span></span>):</span><br><span class="line">    words = text.split()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(words) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> text</span><br><span class="line">    new_words = [word <span class="keyword">for</span> word <span class="keyword">in</span> words <span class="keyword">if</span> random.uniform(<span class="number">0</span>, <span class="number">1</span>) &gt; p]</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join(new_words)</span><br></pre></td></tr></table></figure><p><strong>数据可视化：文本数据可视化</strong></p><p>词频统计：使用词云（Word Cloud）展示高频词。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> wordcloud <span class="keyword">import</span> WordCloud</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_wordcloud</span>(<span class="params">text</span>):</span><br><span class="line">    wordcloud = WordCloud(width=<span class="number">800</span>, height=<span class="number">400</span>).generate(text)</span><br><span class="line">    plt.figure(figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line">    plt.imshow(wordcloud, interpolation=<span class="string">&#x27;bilinear&#x27;</span>)</span><br><span class="line">    plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><h3 id="5-19"><a href="#5-19" class="headerlink" title="5.19"></a>5.19</h3><p>数据采集后的文本并不全是中文的，这很正常。我下一步对这部分文本数据进行了翻译，实现方法是通过DeepL这个工具api用python代码实现。不过要订阅申请DeepL的api密钥。</p><p>翻译数据结构知识数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> deepl</span><br><span class="line"></span><br><span class="line"><span class="comment"># DeepL API认证密钥</span></span><br><span class="line">auth_key = <span class="string">&quot;&quot;</span></span><br><span class="line">translator = deepl.Translator(auth_key)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取XLSX文件</span></span><br><span class="line">data = pd.read_csv(<span class="string">&#x27;ds.xlsx&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个标志位，用于指示是否停止翻译</span></span><br><span class="line">stop_translation = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 翻译文本的函数，从英文翻译成中文</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">translate_to_chinese</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="keyword">global</span> stop_translation</span><br><span class="line">    <span class="keyword">if</span> stop_translation:</span><br><span class="line">        <span class="keyword">return</span> text  <span class="comment"># 如果已经出现异常，直接返回原文</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        translation = translator.translate_text(text, target_lang=<span class="string">&quot;ZH&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> translation.text</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;翻译文本时出错: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        stop_translation = <span class="literal">True</span>  <span class="comment"># 发生异常，设置标志位，停止后续翻译</span></span><br><span class="line">        <span class="keyword">return</span> text</span><br><span class="line"></span><br><span class="line"><span class="comment"># 翻译 &#x27;question&#x27; 列</span></span><br><span class="line">data[<span class="string">&#x27;question&#x27;</span>] = data[<span class="string">&#x27;question&#x27;</span>].apply(translate_to_chinese)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 翻译 &#x27;answer&#x27; 列</span></span><br><span class="line">data[<span class="string">&#x27;answer&#x27;</span>] = data[<span class="string">&#x27;answer&#x27;</span>].apply(translate_to_chinese)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示翻译后的数据的前几行</span></span><br><span class="line"><span class="built_in">print</span>(data.head())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将翻译后的数据保存到一个CSV文件</span></span><br><span class="line">data.to_csv(<span class="string">&#x27;translated_ds.csv&#x27;</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>下面给出代码解释：</p><ol><li>导入库<ul><li><code>import pandas as pd</code>：导入Pandas库，常用于数据处理和分析。</li><li><code>import deepl</code>：导入DeepL库，用于实现文本的机器翻译。</li></ul></li><li>设置DeepL API密钥<ul><li><code>auth_key = &quot;DeepL API密钥&quot;</code>：这里需要替换为DeepL API密钥，用于身份认证和访问翻译服务。</li></ul></li><li>创建DeepL翻译器实例<ul><li><code>translator = deepl.Translator(auth_key)</code>：使用提供的API密钥创建一个DeepL翻译器实例。</li></ul></li><li>加载数据<ul><li><code>data = pd.read_csv(&#39;train.parquet&#39;)</code>：使用Pandas的read_csv函数加载csv格式的文件。</li></ul></li><li>定义翻译函数<ul><li><code>translate_to_chinese(text)</code>：这是一个函数，输入参数是文本（英文），输出是翻译后的文本（中文）。</li><li><code>global stop_translation</code>：使用<code>global</code>关键字声明<code>stop_translation</code>，这允许函数内部修改全局变量。</li><li><code>if stop_translation</code>：如果<code>stop_translation</code>为真（表示已经发生翻译错误），则函数直接返回原文本，不进行翻译。</li><li><code>try-except</code>块：尝试使用DeepL翻译器翻译文本，如果发生异常（如网络问题、API限制等），则捕获异常，打印错误信息，并设置<code>stop_translation</code>为真，之后的所有翻译调用将直接返回原文。</li></ul></li><li>应用翻译函数到数据列<ul><li><code>data[&#39;question&#39;] = data[&#39;question&#39;].apply(translate_to_chinese)</code>：将<code>translate_to_chinese</code>函数应用于数据框<code>data</code>中名为<code>question</code>的列。这将逐行将英文指令翻译成中文。</li></ul></li><li>显示翻译后的数据<ul><li><code>print(data.head())</code>：打印翻译后的数据框的前几行，用于检查翻译结果。</li></ul></li><li>保存翻译后的数据<ul><li><code>data.to_csv(&#39;translated_train.csv&#39;, index=False)</code>：将翻译后的数据保存到一个名为<code>translated_train.csv</code>的CSV文件，<code>index=False</code>参数表示不保存行索引。</li></ul></li></ol><p>翻译java知识数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> deepl</span><br><span class="line"></span><br><span class="line"><span class="comment"># DeepL API认证密钥</span></span><br><span class="line">auth_key = <span class="string">&quot;cAjDPhRVq1V2y80O&quot;</span></span><br><span class="line">translator = deepl.Translator(auth_key)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取CSV文件</span></span><br><span class="line">data = pd.read_csv(<span class="string">&#x27;java.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个标志位，用于指示是否停止翻译</span></span><br><span class="line">stop_translation = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 翻译文本的函数，从英文翻译成中文</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">translate_to_chinese</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="keyword">global</span> stop_translation</span><br><span class="line">    <span class="keyword">if</span> stop_translation:</span><br><span class="line">        <span class="keyword">return</span> text  <span class="comment"># 如果已经出现异常，直接返回原文</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        translation = translator.translate_text(text, target_lang=<span class="string">&quot;ZH&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> translation.text</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;翻译文本时出错: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        stop_translation = <span class="literal">True</span>  <span class="comment"># 发生异常，设置标志位，停止后续翻译</span></span><br><span class="line">        <span class="keyword">return</span> text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 翻译 &#x27;question&#x27; 列</span></span><br><span class="line">data[<span class="string">&#x27;question&#x27;</span>] = data[<span class="string">&#x27;question&#x27;</span>].apply(translate_to_chinese)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 翻译 &#x27;answer&#x27; 列</span></span><br><span class="line">data[<span class="string">&#x27;answer&#x27;</span>] = data[<span class="string">&#x27;answer&#x27;</span>].apply(translate_to_chinese)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示翻译后的数据的前几行</span></span><br><span class="line"><span class="comment"># print(data.head())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将翻译后的数据保存到一个CSV文件</span></span><br><span class="line">data.to_csv(<span class="string">&#x27;translated_java.csv&#x27;</span>, index=<span class="literal">False</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>翻译操作系统知识数据：（这里源文件是parquet类型）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> deepl</span><br><span class="line"></span><br><span class="line">auth_key = <span class="string">&quot;cAjDPhRVq1V2y80O&quot;</span></span><br><span class="line">translator = deepl.Translator(auth_key)</span><br><span class="line"></span><br><span class="line">data = pd.read_parquet(<span class="string">&#x27;os.parquet&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个标志位，用于指示是否停止翻译</span></span><br><span class="line">stop_translation = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 翻译文本的函数，从英文翻译成中文</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">translate_to_chinese</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="keyword">global</span> stop_translation</span><br><span class="line">    <span class="keyword">if</span> stop_translation:</span><br><span class="line">        <span class="keyword">return</span> text  <span class="comment"># 如果已经出现异常，直接返回原文</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        translation = translator.translate_text(text, target_lang=<span class="string">&quot;ZH&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> translation.text</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;翻译文本时出错: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        stop_translation = <span class="literal">True</span>  <span class="comment"># 发生异常，设置标志位，停止后续翻译</span></span><br><span class="line">        <span class="keyword">return</span> text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 翻译 &#x27;question&#x27; 列</span></span><br><span class="line">data[<span class="string">&#x27;question&#x27;</span>] = data[<span class="string">&#x27;question&#x27;</span>].apply(translate_to_chinese)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 翻译 &#x27;answer&#x27; 列</span></span><br><span class="line">data[<span class="string">&#x27;answer&#x27;</span>] = data[<span class="string">&#x27;answer&#x27;</span>].apply(translate_to_chinese)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示翻译后的数据的前几行</span></span><br><span class="line"><span class="comment"># print(data.head())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将翻译后的数据保存到一个CSV文件</span></span><br><span class="line">data.to_csv(<span class="string">&#x27;translated_os.csv&#x27;</span>, index=<span class="literal">False</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>翻译计网知识数据：(这里源文件是俄语版，方法略有改动)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> deepl</span><br><span class="line"></span><br><span class="line"><span class="comment"># DeepL API认证密钥</span></span><br><span class="line">auth_key = <span class="string">&quot;cAjDPhRVq1V2y80O&quot;</span></span><br><span class="line">translator = deepl.Translator(auth_key)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取CSV文件</span></span><br><span class="line">data = pd.read_csv(<span class="string">&#x27;os.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个标志位，用于指示是否停止翻译</span></span><br><span class="line">stop_translation = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 翻译文本的函数，从俄语翻译成中文</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">translate_to_chinese</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="keyword">global</span> stop_translation</span><br><span class="line">    <span class="keyword">if</span> stop_translation:</span><br><span class="line">        <span class="keyword">return</span> text  <span class="comment"># 如果已经出现异常，直接返回原文</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        translation = translator.translate_text(text, source_lang=<span class="string">&quot;RU&quot;</span>, target_lang=<span class="string">&quot;ZH&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> translation.text</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;翻译文本时出错: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        stop_translation = <span class="literal">True</span>  <span class="comment"># 发生异常，设置标志位，停止后续翻译</span></span><br><span class="line">        <span class="keyword">return</span> text</span><br><span class="line"></span><br><span class="line"><span class="comment"># 翻译 &#x27;question&#x27; 列</span></span><br><span class="line">data[<span class="string">&#x27;question&#x27;</span>] = data[<span class="string">&#x27;question&#x27;</span>].apply(translate_to_chinese)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 翻译 &#x27;answer&#x27; 列</span></span><br><span class="line">data[<span class="string">&#x27;answer&#x27;</span>] = data[<span class="string">&#x27;answer&#x27;</span>].apply(translate_to_chinese)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示翻译后的数据的前几行</span></span><br><span class="line"><span class="built_in">print</span>(data.head())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将翻译后的数据保存到一个CSV文件</span></span><br><span class="line">data.to_csv(<span class="string">&#x27;translated_os.csv&#x27;</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><h3 id="5-26"><a href="#5-26" class="headerlink" title="5.26"></a>5.26</h3><p><strong>去除过短或者过长训练数据</strong></p><p>在机器学习中，去除过短或过长的训练数据通常是为了提高模型的性能和稳定性。以下是具体的原因：</p><ol><li>质量控制</li></ol><p>过短的文本：</p><ul><li>可能包含太少的信息，无法提供足够的上下文。</li><li>可能是噪音或无用的内容，如单个字符或单词。</li></ul><p>过长的文本：</p><ul><li>可能包含冗余信息或噪音。</li><li>处理起来资源消耗较大，增加计算开销。</li></ul><ol start="2"><li>计算效率</li></ol><p>过长的文本：</p><ul><li>需要更多的计算资源和时间。</li><li>可能导致内存不足或训练时间过长。</li></ul><ol start="3"><li>模型训练稳定性</li></ol><p>过短的文本：</p><ul><li>可能导致模型过拟合，无法泛化到更长或更复杂的句子。</li><li>模型可能学不到有用的特征。</li></ul><p>过长的文本：</p><ul><li>可能导致模型在训练时遇到梯度消失或爆炸的问题。</li><li>增加模型的复杂性，可能需要更复杂的架构来处理。</li></ul><ol start="4"><li>数据均衡性</li></ol><p>去除过短或过长的文本有助于确保训练数据的长度分布更加均衡，避免模型对特定长度的文本过度拟合。</p><ol start="5"><li>一致性和可解释性</li></ol><p>保持数据长度在一个合理的范围内，可以提高模型预测结果的一致性和可解释性。</p><p>下面是我去除过短或者过长训练数据的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取CSV文件</span></span><br><span class="line">data = pd.read_csv(<span class="string">&#x27;data.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 过滤数据，保留满足条件的行</span></span><br><span class="line">filtered_data = data[(data[<span class="string">&#x27;question&#x27;</span>].<span class="built_in">str</span>.<span class="built_in">len</span>() &gt;= <span class="number">5</span>) &amp; (data[<span class="string">&#x27;question&#x27;</span>].<span class="built_in">str</span>.<span class="built_in">len</span>() &lt;= <span class="number">50</span>) &amp;</span><br><span class="line">                     (data[<span class="string">&#x27;answer&#x27;</span>].<span class="built_in">str</span>.<span class="built_in">len</span>() &gt;= <span class="number">50</span>) &amp; (data[<span class="string">&#x27;answer&#x27;</span>].<span class="built_in">str</span>.<span class="built_in">len</span>() &lt;= <span class="number">512</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存过滤后的数据到新的CSV文件</span></span><br><span class="line">filtered_data.to_csv(<span class="string">&#x27;filtered_data.csv&#x27;</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><ol><li>读取CSV文件：使用<code>pd.read_csv()</code>函数读取名为<code>data.csv</code>的文件</li><li>过滤数据<ul><li>使用Pandas的字符串方法<code>.str.len()</code>来计算每一行中<code>question</code>和<code>answer</code>列的长度。</li><li>使用布尔索引过滤出满足所有条件的行：<ul><li>问题列的长度至少为5个字符且不超过50个字符。</li><li>答案列的长度至少为50个字符且不超过512个字符。</li></ul></li></ul></li><li>保存过滤后的数据：使用<code>to_csv()</code>方法将过滤后的数据保存到一个名为<code>filtered_data.csv</code>的新文件中。设置<code>index=False</code>参数来避免写入行索引到文件。</li></ol><p><strong>删除相似的问题或者相似的答案</strong></p><p>在大模型训练中，删除相似的问题或相似的答案有以下几个主要原因：</p><ol><li>减少数据冗余</li></ol><p>相似的问题和答案:</p><ul><li>会导致数据集中存在大量重复信息。</li><li>增加数据量但不提供新的有价值的信息。</li></ul><p>通过删除相似的样本，可以减少数据冗余，使模型更专注于学习多样化和有代表性的信息。</p><ol start="2"><li>提高训练效率</li></ol><p>减少冗余数据:</p><ul><li>可以显著减少训练时间和计算资源的消耗。</li><li>使模型训练更高效，因为训练时不需要反复处理相似的信息。</li></ul><ol start="3"><li>防止过拟合</li></ol><p>相似的问题和答案:</p><ul><li>可能导致模型对某些特定模式过拟合。</li><li>模型可能会记住这些重复的样本，而不是学会如何处理更多样化的数据。</li></ul><p>删除相似的样本有助于提高模型的泛化能力，使其在面对新数据时表现更好。</p><ol start="4"><li>增强模型的多样性学习</li></ol><p>多样化数据:</p><ul><li>使模型能够学习到更广泛的模式和特征。</li><li>提高模型在不同情境下的表现能力。</li></ul><p>删除相似的样本可以确保模型接触到更多样化的训练数据，从而提高模型的鲁棒性和应对不同情况的能力。</p><ol start="5"><li>改善数据集质量</li></ol><p>清理数据集:</p><ul><li>可以去除那些重复或者几乎相同的问答对，提升数据集的整体质量。</li><li>有助于确保数据集中的每个样本都提供有价值的训练信息。</li></ul><p>高质量的数据集有助于模型更有效地学习和推理。</p><p>下面是我的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> difflib <span class="keyword">import</span> SequenceMatcher</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">similar</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> SequenceMatcher(<span class="literal">None</span>, a, b).ratio()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取CSV文件</span></span><br><span class="line">data = pd.read_csv(<span class="string">&#x27;data.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化要删除的索引列表</span></span><br><span class="line">indices_to_drop = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查问题列的相似度</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data) - <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, <span class="built_in">len</span>(data)):</span><br><span class="line">        <span class="comment"># 比较问题列</span></span><br><span class="line">        <span class="keyword">if</span> similar(data.loc[i, <span class="string">&#x27;question&#x27;</span>], data.loc[j, <span class="string">&#x27;question&#x27;</span>]) &gt; <span class="number">0.8</span>:</span><br><span class="line">            indices_to_drop.add(j)  <span class="comment"># 添加问题二的索引到删除列表</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 比较答案列</span></span><br><span class="line">        <span class="keyword">if</span> similar(data.loc[i, <span class="string">&#x27;answer&#x27;</span>], data.loc[j, <span class="string">&#x27;answer&#x27;</span>]) &gt; <span class="number">0.8</span>:</span><br><span class="line">            indices_to_drop.add(j)  <span class="comment"># 添加答案二的索引到删除列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除相似度高的行</span></span><br><span class="line">data = data.drop(indices_to_drop)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存过滤后的数据到新的CSV文件</span></span><br><span class="line">data.to_csv(<span class="string">&#x27;filtered_data.csv&#x27;</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><ol><li><p>相似度计算函数</p><ul><li>使用<code>SequenceMatcher</code>函数比较两个字符串的相似度。这个函数返回一个介于0和1之间的数值，表示两个字符串的相似度百分比。</li></ul></li><li><p>读取CSV文件</p><ul><li>使用<code>pd.read_csv()</code>读取CSV文件。</li></ul></li><li><p>初始化索引列表</p><ul><li>使用一个集合<code>indices_to_drop</code>来存储需要删除的行索引。使用集合可以避免重复添加同一索引。</li></ul></li><li><p>双重循环比较每行</p><ul><li>用双重循环遍历数据框，比较每一对问题和答案。</li></ul></li></ol><ul><li>如果发现问题或答案的相似度超过80%，将较后的行索引添加到<code>indices_to_drop</code>集合中。</li></ul><ol start="5"><li><p>删除指定行</p><ul><li>使用<code>DataFrame.drop</code>方法删除所有标记为删除的行。</li></ul></li><li><p>保存结果</p><ul><li>使用<code>to_csv()</code>方法将处理后的数据保存到新的CSV文件<code>filtered_data.csv</code>中，<code>index=False</code>参数确保不保存行索引。</li></ul></li></ol><p>这段代码将根据问题和答案的相似度过滤出唯一的行，是处理大量文本数据</p><h3 id="6-03"><a href="#6-03" class="headerlink" title="6.03"></a>6.03</h3><p>前面从广义数据的角度对数据集进行了处理，但是没有考虑到大模型的角度。在和负责大模型部分的同学沟通后，进一步对数据进行了处理，使其更贴合大规模预训练模型。通过一番查找对比，我在这里选择了llm_corpus_quality这个项目。</p><p>llm_corpus_quality集成了包含清洗、敏感词过滤、广告词过滤、语料质量自动评估等功能在内的多个数据处理工具与算法，为中文AI大模型提供安全可信的主流数据。项目采用java实现，完整项目见<a href="https://github.com/jiangnanboy/llm_corpus_quality">https://github.com/jiangnanboy/llm_corpus_quality</a></p><p>llm_corpus_quality支持以下特性：</p><ul><li>规则清洗</li><li>敏感词过滤</li><li>广告过滤</li><li>去重</li><li>质量评估</li></ul><p>处理流程如下</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/29/66570ac0de3ea.png" alt="821577-20240113201957948-1480717496.png"></p><p>大模型训练语料清洗流程，共包括4个阶段5个模块：</p><ol><li>语料清洗规则过滤：通常经过格式转换后的json文件仍存在很多问题，不能直接用于构建训练数据集。通常会以句子或篇章作为过滤单位，通过检测句子或篇章内是否含有大量的怪异符号、是否存在html网页标签等来判断文本是否为合格文本。</li><li>敏感词过滤器：利用自动机，过滤色情、赌博、部分低质量广告等内容的文本。</li><li>广告过滤：利用textcnn模型，过滤涉嫌广告内容。(见<a href="https://github.com/jiangnanboy/ad_detect_textcnn">https://github.com/jiangnanboy/ad_detect_textcnn</a>)</li><li>去重：利用simhash对相似文本片段进行去重。</li><li>质量评估：采用ngram语言模型评估的方法，对语料进行概率预估，文本质量越高的语句，困惑度ppl越低，设定一个ppl阈值，高于这个阈值为低质量语料，可过滤。</li></ol><p>下面是作者给出的示例代码，我稍加改动，对预处理的数据集进行了适配大模型的清洗，得到了最终数据集。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// <span class="built_in">hash</span> data of corpus to deduplication (read <span class="keyword">and</span> save)</span><br><span class="line">     var hashFile = PropertiesReader.get(<span class="string">&quot;dedeplication_hash_path&quot;</span>);</span><br><span class="line"></span><br><span class="line">     //<span class="number">1.</span>rule</span><br><span class="line">     var ruleQuality = new RuleQuality();</span><br><span class="line"></span><br><span class="line">     //<span class="number">2.</span>sensitivity <span class="keyword">and</span> advertising detection</span><br><span class="line">     var simpleSenDetectionProcessor = SimpleSenDetectionProcessor.newInstance();</span><br><span class="line">     var senDetection = simpleSenDetectionProcessor.getKWSeeker(<span class="string">&quot;sensitive_words_path&quot;</span>);</span><br><span class="line"></span><br><span class="line">     var ad_detect_model_path = PropertiesReader.get(<span class="string">&quot;ad_detect_model_path&quot;</span>);</span><br><span class="line">     var ad_dict_path = PropertiesReader.get(<span class="string">&quot;ad_dict_path&quot;</span>);</span><br><span class="line">     var stop_words_path = PropertiesReader.get(<span class="string">&quot;stop_words_path&quot;</span>);</span><br><span class="line">     var adDetection = new AdDetection(ad_detect_model_path, ad_dict_path, stop_words_path);</span><br><span class="line"></span><br><span class="line">     //<span class="number">3.</span>text deduplication</span><br><span class="line">     var deDuplication = new DeDuplication(<span class="number">4</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">     //<span class="number">4.</span>quality evaluation</span><br><span class="line">     var ngramModelPath = PropertiesReader.get(<span class="string">&quot;language_model_path&quot;</span>);</span><br><span class="line">     var qualityEvaluation = new QualityEvaluation(ngramModelPath);</span><br><span class="line"></span><br><span class="line">     // load <span class="built_in">hash</span></span><br><span class="line">     <span class="keyword">if</span>(Files.exists(Paths.get(hashFile))) &#123;</span><br><span class="line">         deDuplication.loadHash(hashFile);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     var corpusQuality = new CorpusQuality(ruleQuality, senDetection, adDetection, deDuplication, qualityEvaluation, <span class="number">100</span>);</span><br><span class="line">     var corpus = <span class="string">&quot;对未按土地、环保和投资管理等法律法规履行相关手续或手续不符合规定的违规项目，地方政府要按照要求进行全面清理。一，凡是未开工的违规项目，一律不得开工建设；二，凡是不符合产业政策、准入标准、环保要求的违规项目一律停建。&quot;</span>;</span><br><span class="line">     var result = corpusQuality.quality(corpus);</span><br><span class="line">     System.out.println(result);</span><br><span class="line"></span><br><span class="line">     // save <span class="built_in">hash</span></span><br><span class="line">     deDuplication.saveHash(hashFile);</span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/29/66570bac4e6a7.png" alt="Snipaste_2024-05-29_19-04-51.png"></p><p>不过在这里，我对清洗前后的数据进行观察，发现并没有明显变化，因为原本的数据集已经是在上传者处理过后上传至平台上的。</p><h3 id="6-11"><a href="#6-11" class="headerlink" title="6.11"></a>6.11</h3><p><strong>转换为Alpaca数据集和Json格式用于模型训练和微调</strong></p><p>之前得到了csv格式的数据集，而模型训练和微调需要用到json格式，于是进行转换。下面是代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取CSV文件</span></span><br><span class="line">data = pd.read_csv(<span class="string">&#x27;cleaned_translated_train.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换数据为JSON格式，每一行变成一个字典</span></span><br><span class="line">json_data = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;instruction&quot;</span>: row[<span class="string">&quot;question&quot;</span>],</span><br><span class="line">        <span class="string">&quot;input&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;output&quot;</span>: row[<span class="string">&quot;answer&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> index, row <span class="keyword">in</span> data.iterrows()</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将JSON数据保存到文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data_for_training.json&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> json_file:</span><br><span class="line">    json.dump(json_data, json_file, ensure_ascii=<span class="literal">False</span>, indent=<span class="number">4</span>)</span><br></pre></td></tr></table></figure><ol><li>读取CSV文件：使用Pandas读取<code>cleaned_translated_train.csv</code>文件。</li><li>构建JSON格式数据：对于数据框中的每一行，创建一个字典，其中<code>instruction</code>键对应问题列的内容，<code>input</code>键为空字符串，<code>output</code>键对应答案列的内容。</li><li>保存JSON数据：将构建的JSON数据列表保存到名为<code>data_for_training.json</code>的文件中，使用<code>json.dump</code>进行序列化，保持格式化输出以提高可读性。</li></ol><p><strong>多个处理好的Json文件进行拼接，用于最后的Lora微调和Rag向量化</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有JSON文件都存放在一个名为 &#x27;json_files&#x27; 的目录中</span></span><br><span class="line">directory_path = <span class="string">&#x27;json_files&#x27;</span></span><br><span class="line">all_data = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历目录中的每个文件</span></span><br><span class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> os.listdir(directory_path):</span><br><span class="line">    <span class="keyword">if</span> filename.endswith(<span class="string">&#x27;.json&#x27;</span>):</span><br><span class="line">        file_path = os.path.join(directory_path, filename)</span><br><span class="line">        <span class="comment"># 打开并读取JSON文件</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">            data = json.load(file)</span><br><span class="line">            all_data.append(data)  <span class="comment"># 将读取的数据添加到列表中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将合并后的数据保存到一个新的JSON文件中</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;combined_data.json&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> output_file:</span><br><span class="line">    json.dump(all_data, output_file, ensure_ascii=<span class="literal">False</span>, indent=<span class="number">4</span>)</span><br></pre></td></tr></table></figure><ol><li>导入所需的库：使用<code>json</code>进行数据的序列化和反序列化，使用<code>os</code>来处理文件和目录路径。</li><li>设置文件目录：所有的JSON文件都放在名为<code>json_files</code>的目录中。</li><li>读取JSON文件<ul><li>使用<code>os.listdir()</code>遍历指定目录中的所有文件。</li><li>检查文件扩展名是否为<code>.json</code>，确保只处理JSON文件。</li><li>对于每个JSON文件，打开并使用<code>json.load()</code>读取内容，然后将这些内容添加到<code>all_data</code>列表中。</li></ul></li><li>写入合并后的JSON数据<ul><li>所有文件的数据被存储在<code>all_data</code>列表中，该列表包含了从每个文件读取的数据。</li><li>使用<code>json.dump()</code>将这个列表写入一个名为<code>combined_data.json</code>的新文件中，设置<code>ensure_ascii=False</code>来支持非ASCII字符，<code>indent=4</code>提供了格式化的输出，使得JSON文件易于阅读。</li></ul></li></ol><h3 id="6-20"><a href="#6-20" class="headerlink" title="6.20"></a>6.20</h3><p>其他队友的大模型训练和前后端开发工作基本完成了，于是我进行了测试。</p><h4 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h4><p>功能测试的主要目的是验证网站的核心功能是否按预期工作，包括用户交互、数据输入、页面跳转和功能性操作。</p><p>测试过程中，主要集中在以下几个方面：</p><p>- 验证链接跳转是否正确</p><p>- 输入验证和表单提交</p><p>- 功能性测试，如搜索、提问、用户登录、密码找回等</p><p><strong>测试环境</strong></p><p>操作系统：Windows 10</p><p>浏览器：Microsoft Edge,火狐,Chrome</p><p>自动化测试工具：Selenium WebDriver, JUnit</p><p><strong>自动化测试</strong></p><p>对于某些复杂的用例，我用了自动化测试以便减轻人工工作量</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/24/6678553b4b70e.png"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/24/6678554e08a9d.png"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/24/667855af4340a.png"></p><p><strong>测试结果</strong></p><p>绝大多数功能点按照预期工作，但发现了包括链接跳转错误、输入验证不严格的问题。</p><p><strong>Bug 列表</strong></p><p>1.输入问题时如果小于一定长度时提交会没有反应，而不是给出报错</p><p>2.输入问题时如果超出一定长度时提交会没有反应，而不是给出报错</p><p>3.前端路由跳转有时会失效</p><p>在反应给开发同学之后，修改了这些bug</p><h4 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h4><p>虽然网站不进行上线同时供多人使用，但性能测试也是测试的重要一环。</p><ol><li><strong>评估系统能力</strong>：性能测试通过模拟实际使用情况，对系统进行压力测试，以评估系统在不同负载条件下的性能指标，如响应时间、吞吐量、并发用户数等。</li><li><strong>识别体系中的弱点</strong>：在受控的负载条件下，性能测试可以发现系统存在的性能瓶颈或弱点，为后续的修复和优化提供方向。</li><li><strong>系统调优</strong>：基于性能测试的结果，可以对系统进行调优，改进性能，确保系统在实际使用中能够高效、稳定地运行。</li><li><strong>验证稳定性和可靠性</strong>：通过长时间、高负载的性能测试，可以验证系统的稳定性和可靠性，确保系统在生产环境中能够持续、稳定地提供服务。</li></ol><p>这里我选择用Jmeter进行性能测试。</p><p>在JMeter中通过结果树监听器查看每个请求的执行结果，确认是否成功访问页面，并查看返回的HTML信息及其他相关数据。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/24/6678539d38a94.png"></p><p>通过监听器的聚合报告展示关键的性能指标，如平均响应时间，这是服务器响应请求所需的平均时间；最小和最大响应时间，用以观察响应时间的波动；吞吐量，即每秒处理的请求量，反映了服务器的处理能力；以及错误率，即请求失败的百分比。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/24/667853fde463f.png"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/24/667853fd9a384.png"></p><p>根据聚合报告的结果，在执行了1000次请求的测试中，服务器表现出良好的稳定性和效率，平均响应时间为183毫秒，但个别请求的响应时间仍有较大波动。整体来看，服务器性能稳定。</p>]]></content>
      
      
      <categories>
          
          <category> 大学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目实训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目实训个人周报8</title>
      <link href="/2024/06/20/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%AE%AD%E4%B8%AA%E4%BA%BA%E5%91%A8%E6%8A%A58/"/>
      <url>/2024/06/20/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%AE%AD%E4%B8%AA%E4%BA%BA%E5%91%A8%E6%8A%A58/</url>
      
        <content type="html"><![CDATA[<p>其他队友的大模型训练和前后端开发工作基本完成了，于是我进行了测试。</p><h3 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h3><p>功能测试的主要目的是验证网站的核心功能是否按预期工作，包括用户交互、数据输入、页面跳转和功能性操作。</p><p>测试过程中，主要集中在以下几个方面：</p><p>- 验证链接跳转是否正确</p><p>- 输入验证和表单提交</p><p>- 功能性测试，如搜索、提问、用户登录、密码找回等</p><p><strong>测试环境</strong></p><p>操作系统：Windows 10</p><p>浏览器：Microsoft Edge,火狐,Chrome</p><p>自动化测试工具：Selenium WebDriver, JUnit</p><p><strong>自动化测试</strong></p><p>对于某些复杂的用例，我用了自动化测试以便减轻人工工作量</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/24/6678553b4b70e.png"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/24/6678554e08a9d.png"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/24/667855af4340a.png"></p><p><strong>测试结果</strong></p><p>绝大多数功能点按照预期工作，但发现了包括链接跳转错误、输入验证不严格的问题。</p><p><strong>Bug 列表</strong></p><p>1.输入问题时如果小于一定长度时提交会没有反应，而不是给出报错</p><p>2.输入问题时如果超出一定长度时提交会没有反应，而不是给出报错</p><p>3.前端路由跳转有时会失效</p><p>在反应给开发同学之后，修改了这些bug</p><h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><p>虽然网站不进行上线同时供多人使用，但性能测试也是测试的重要一环。</p><ol><li><strong>评估系统能力</strong>：性能测试通过模拟实际使用情况，对系统进行压力测试，以评估系统在不同负载条件下的性能指标，如响应时间、吞吐量、并发用户数等。</li><li><strong>识别体系中的弱点</strong>：在受控的负载条件下，性能测试可以发现系统存在的性能瓶颈或弱点，为后续的修复和优化提供方向。</li><li><strong>系统调优</strong>：基于性能测试的结果，可以对系统进行调优，改进性能，确保系统在实际使用中能够高效、稳定地运行。</li><li><strong>验证稳定性和可靠性</strong>：通过长时间、高负载的性能测试，可以验证系统的稳定性和可靠性，确保系统在生产环境中能够持续、稳定地提供服务。</li></ol><p>这里我选择用Jmeter进行性能测试。</p><p>在JMeter中通过结果树监听器查看每个请求的执行结果，确认是否成功访问页面，并查看返回的HTML信息及其他相关数据。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/24/6678539d38a94.png"></p><p>通过监听器的聚合报告展示关键的性能指标，如平均响应时间，这是服务器响应请求所需的平均时间；最小和最大响应时间，用以观察响应时间的波动；吞吐量，即每秒处理的请求量，反映了服务器的处理能力；以及错误率，即请求失败的百分比。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/24/667853fde463f.png"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/24/667853fd9a384.png"></p><p>根据聚合报告的结果，在执行了1000次请求的测试中，服务器表现出良好的稳定性和效率，平均响应时间为183毫秒，但个别请求的响应时间仍有较大波动。整体来看，服务器性能稳定。</p>]]></content>
      
      
      <categories>
          
          <category> 大学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目实训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试复习</title>
      <link href="/2024/06/16/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
      <url>/2024/06/16/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a><strong>第一章</strong></h1><h2 id="1-软件测试学科的发展"><a href="#1-软件测试学科的发展" class="headerlink" title="1 软件测试学科的发展"></a><strong>1 软件测试学科的发展</strong></h2><p>1957～1978年，以功能验证为导向，测试是证明软件是正确的（正向思维）。<br>1978～1983年，以破坏性检测为导向，测试是为了找到软件中的错误（逆向思维）。<br>1983～1987年，以质量评估为导向，测试是提供产品的评估和质量度量。<br>1988年起，以缺陷预防为导向，测试是为了展示软件符合设计要求，发现缺陷、预防缺陷。</p><h2 id="2-正向测试与反向测试的定义，关系"><a href="#2-正向测试与反向测试的定义，关系" class="headerlink" title="2 正向测试与反向测试的定义，关系"></a>2 正向测试与反向测试的定义，关系</h2><p>Bill Hetzel博士（正向思维的代表）：</p><ul><li>软件测试就是为程序或系统能够按预期设想运行而建立信心的过程。</li><li>软件测试是一系列活动以评价一个程序或系统的特性或能力并确定是否达到预期的结果</li><li>测试是为了验证软件是否符合用户需求，即验证软件产品是否能正常工作</li></ul><p>Glenford J. Myers （反向思维的代表）：</p><ul><li>测试是为了证明程序有错，而不是证明程序无错误</li><li>一个好的测试用例是在于它能发现至今未发现的错误 </li><li>一个成功的测试是发现了至今未发现的错误的测试</li></ul><h2 id="3-从经济视角认知软件测试"><a href="#3-从经济视角认知软件测试" class="headerlink" title="3 从经济视角认知软件测试"></a>3 <strong>从经济视角认知软件测试</strong></h2><p>测试的经济观点就是以最小的代价获得最高的软件产品质量。经济观点也要求软件测试尽早开展工作，发现缺陷越早，返工的工作量就越小，所造成的损失就越小。测试的成本&lt; 缺陷造成的损失，测试才有意义。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666ebe3010ecb.png"></p><h2 id="4-SQA，与软件测试关系"><a href="#4-SQA，与软件测试关系" class="headerlink" title="4 SQA，与软件测试关系"></a><strong>4</strong> SQA，与软件测试关系</h2><p>联系</p><p>SQA指导、监督软件测试的计划和执行，督促测试工作的结果客观、准确和有效，并协助测试流程的改进。<br>软件测试是SQA重要手段之一，为SQA提供所需的数据，作为质量评价的客观依据。</p><p>区别</p><p>SQA是一项管理工作，侧重于对流程的评审和监控<br>测试是一项技术性的工作，侧重对产品进行评估和验证</p><h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><h2 id="1-缺陷定义，现象，判定准则"><a href="#1-缺陷定义，现象，判定准则" class="headerlink" title="1 缺陷定义，现象，判定准则"></a>1 缺陷定义，现象，判定准则</h2><p><strong>定义</strong></p><p>任何程序、系统中的问题，如与产品设计书的不一致性、不能满足用户的需求 </p><p><strong>现象</strong></p><p>功能、特性没有实现或部分实现</p><p>设计不合理，存在缺陷</p><p>实际结果和预期结果不一致</p><p>运行出错，包括运行中断、系统崩溃、界面混乱</p><p>数据结果不正确、精度不够</p><p>用户不能接受的其他问题，如存取时间过长、界面不美观 </p><p><strong>判定准则</strong></p><p>1)需求规格说明书和其它需求、设计规范文档</p><p>2)竞争对手的产品</p><p>3)启发式测试预言（Heuristic oracle）</p><p>4)统计测试预言（Statistical oracle）</p><p>5)一致性测试预言（Consistency oracle）</p><p>6)基于模型的测试预言（Model-based oracle）</p><p>7)人类预言（Human oracle）</p><h2 id="2-软件缺陷产生的原因有哪？"><a href="#2-软件缺陷产生的原因有哪？" class="headerlink" title="2 软件缺陷产生的原因有哪？"></a>2 软件缺陷产生的原因有哪？</h2><ol><li><p><strong>技术问题</strong></p><p>算法错误、计算和精度问题</p><p>接口参数传递不匹配</p></li><li><p><strong>团队工作</strong></p><p>沟通不充分，误解</p></li><li><p><strong>软件本身</strong></p><p>文档错误、用户使用场合(user scenario)，</p><p>时间上不协调、或不一致性所带来的问题</p><p>系统的自我恢复或数据的异地备份、灾难性恢复等问题</p></li></ol><h2 id="3-产品质量的内容，内部，外部，使用质量"><a href="#3-产品质量的内容，内部，外部，使用质量" class="headerlink" title="3 产品质量的内容，内部，外部，使用质量"></a>3 产品质量的内容，内部，外部，使用质量</h2><p>产品质量是人们实践产物的属性和行为，是可以认识，可以科学地描述的，并且可以通过一些方法和人类活动，来改进质量。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666ec038b15d1.png"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666ec03896148.png"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666ec07486d56.png"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666ec099883ee.png"></p><h2 id="4-如何理解软件规格说明书缺陷"><a href="#4-如何理解软件规格说明书缺陷" class="headerlink" title="4 如何理解软件规格说明书缺陷"></a>4 如何理解<strong>软件规格说明书缺陷</strong></h2><p>软件规格说明书（也称为需求规格说明书或功能需求说明书）是软件开发过程中的关键文档，它详细描述了软件的功能、性能、接口和其他属性。理解软件规格说明书中的缺陷对于确保软件质量至关重要。以下是如何理解软件规格说明书缺陷的几个方面：</p><ol><li>不完整性<ul><li>如果规格说明书没有涵盖所有必要的需求，或者遗漏了关键的用户故事、场景或业务流程，那么它就是不完整的。</li><li>缺陷可能表现为遗漏了某些功能、性能要求、安全要求或用户交互。</li></ul></li><li>模糊性或歧义性<ul><li>如果规格说明书的描述含糊不清或存在歧义，那么开发人员可能会对其产生不同的解释，导致不一致的实现。</li><li>缺陷可能表现为使用不明确的术语、缺少上下文或缺少必要的图表、模型或示例。</li></ul></li><li>不一致性<ul><li>如果规格说明书内部存在矛盾或与其他相关文档（如用户手册、设计文档等）不一致，那么它就是不一致的。</li><li>缺陷可能表现为功能描述之间的冲突、数据格式的不匹配或与其他系统接口的不兼容。</li></ul></li><li>不可验证性<ul><li>如果规格说明书中的需求无法通过测试或其他验证手段来确认是否满足，那么它就是不可验证的。</li><li>缺陷可能表现为缺乏明确的验收标准、测试用例或性能度量指标。</li></ul></li><li>非功能性需求缺陷<ul><li>规格说明书通常不仅包含功能性需求，还包含非功能性需求，如性能、安全性、易用性、可维护性等。</li><li>如果这些非功能性需求描述不足或遗漏，则可能导致软件在某些方面不满足用户期望或行业标准。</li></ul></li><li>忽略用户反馈或市场需求<ul><li>如果规格说明书没有充分考虑用户反馈或市场需求的变化，那么它可能无法反映用户的真实需求或市场的最新趋势。</li><li>缺陷可能表现为过时的功能、忽视用户痛点或无法满足新兴市场需求。</li></ul></li><li>技术可行性问题<ul><li>如果规格说明书中的需求在技术上无法实现或实现成本过高，那么它可能存在技术可行性问题。</li><li>缺陷可能表现为对技术栈的误解、不切实际的性能要求或过于复杂的业务流程。</li></ul></li></ol><h2 id="5-verification-validation"><a href="#5-verification-validation" class="headerlink" title="5 verification,validation"></a>5 verification,validation</h2><p>软件测试是由“验证（Verification）”和“有效性确认（Validation）”活动构成的整体</p><p>Verification： Are we building the product right？是否正确地构造了软件？即是否正确地做事，验证开发过程是否遵守已定义好的内容。验证产品满足规格设计说明书的一致性</p><p>Validation： Are we building the right product? 是否构造了正是用户所需要的软件？即是否正在做正确的事。验证产品所实现的功能是否满足用户的需求</p><h2 id="6-软件测试不同层次测试的对象和任务"><a href="#6-软件测试不同层次测试的对象和任务" class="headerlink" title="6 软件测试不同层次测试的对象和任务"></a>6 软件测试不同层次测试的对象和任务</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666ec14c05c82.png"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666ec14c092f5.png"></p><h2 id="7-静态测试的内容包括什么？开展相关活动时采用的形式有哪些？"><a href="#7-静态测试的内容包括什么？开展相关活动时采用的形式有哪些？" class="headerlink" title="7 静态测试的内容包括什么？开展相关活动时采用的形式有哪些？"></a>7 静态测试的内容包括什么？开展相关活动时采用的形式有哪些？</h2><p><strong>静态测试</strong>包括对软件产品的需求和设计文档、代码的评审（技术评审、文档评审等），以及对代码的静态分析等。</p><p>管理评审、流程评审不属于静态测试，而是属于质量保证（QA）；</p><p>评审的主要形式：互为评审 (Peer review)、走查 (walk-through)、会议评审 (Inspection)；</p><p>代码的静态分析主要采用工具进行，但人工的代码评审也不可或缺。</p><h2 id="8-测试工作的流程"><a href="#8-测试工作的流程" class="headerlink" title="8 测试工作的流程"></a>8 测试工作的流程</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666ec210c793f.png"></p><h2 id="9-软件测试的工作范畴"><a href="#9-软件测试的工作范畴" class="headerlink" title="9 软件测试的工作范畴"></a>9 软件测试的工作范畴</h2><p>测试需求分析、测试策略指定、测试计划、测试设计、测试执行、测试结果和过程评估</p><h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><h2 id="1-等价类"><a href="#1-等价类" class="headerlink" title="1 等价类"></a>1 等价类</h2><ul><li>等价类是某个输入域的子集，在该子集中每个输入数据的作用是等效的.</li><li>将输入数据分成若干个等价类，从每个等价类选取一个代表性的数据作为测试用例</li><li>等价类分为有效等价类（合理的数据）和无效等价类（异常的数据）</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666ec2ef67f6f.png"></p><h2 id="2-边界值法"><a href="#2-边界值法" class="headerlink" title="2 边界值法"></a>2 边界值法</h2><ul><li><p>很多错误发生在输入或输出范围的边界上，因此针对各种边界情况设置测试用例，可以更有效地发现缺陷。</p></li><li><p>设计方法：</p><p>确定边界情况（输入或输出等价类的边界）</p><p>选取正好等于、刚刚大于或小于边界值作为测试数据</p></li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666ec2ef5306f.png"></p><h2 id="3-决策表（判定表），因果图法"><a href="#3-决策表（判定表），因果图法" class="headerlink" title="3 决策表（判定表），因果图法"></a>3 决策表（判定表），因果图法</h2><ul><li>在实际应用中，许多输入是由多个因素构成，而不是单一因素，这时就需要多因素组合分析。</li><li>对于多因素，有时可以直接对<strong>输入条件（成立或不成立）</strong>进行组合设计，不需要进行因果分析，这时就采用判定表方法。</li><li>决策表由“<strong>条件和活动</strong>”两部分组成，<strong>即列出一个测试活动执行所需的条件组合</strong>，所有可能的条件（输入）组合定义了一系列的选择，而测试活动（<strong>结果输出</strong>）需要考虑每一个选择。</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666ec3655a0a2.png"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666ec3652caee.png"></p><ul><li><p>因果图针对<strong>更为复杂的</strong>“多种输入条件、产生多种结果”设计组合测试用例。</p></li><li><p><strong>设计方法：</strong></p><p>分析软件Spec描述的哪些是原因（输入条件）、哪些是结果（输出），给每个原因和结果赋予一个标示符。</p><p>找出原因与结果、原因与原因之间的对应关系，画出因果图</p><p>在因果图上标上哪些不可能发生的因果关系，表明约束或限制条件</p><p>根据因果图，创建（转化为）判定表，将复杂的逻辑关系转化为简单的组合矩阵</p><p>把判定表的每一列转化为测试用例。</p></li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666ec3f271b2d.png"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666ec3f26f84d.png"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666ec3f26f854.png"></p><h2 id="4-各种逻辑覆盖法"><a href="#4-各种逻辑覆盖法" class="headerlink" title="4 各种逻辑覆盖法"></a>4 各种逻辑覆盖法</h2><h3 id="1-语句覆盖"><a href="#1-语句覆盖" class="headerlink" title="1.语句覆盖"></a>1.语句覆盖</h3><p>设计若干测试用例，运行被测程序，使程序中的每个可执行语句至少被执行一次</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666ec4e5db046.png"></p><h3 id="2-判定覆盖"><a href="#2-判定覆盖" class="headerlink" title="2.判定覆盖"></a>2.判定覆盖</h3><p>判定覆盖：设计若干用例，运行被测程序，使得程序中每个判断的取真分支和取假分支至少经历一次，即判断真假值均曾被满足。一个判定代表着程序的一个分支，所以判定覆盖也被称为<strong>分支覆盖</strong>。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666ec4e5f0828.png"></p><h3 id="3-条件覆盖"><a href="#3-条件覆盖" class="headerlink" title="3.条件覆盖"></a>3.条件覆盖</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666ec4e5db046.png"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666ec4e5f19c0.png"></p><h3 id="4-判定-条件覆盖"><a href="#4-判定-条件覆盖" class="headerlink" title="4.判定&#x2F;条件覆盖"></a>4.判定&#x2F;条件覆盖</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666ec5ce44aa4.png"></p><h3 id="5-条件组合覆盖"><a href="#5-条件组合覆盖" class="headerlink" title="5.条件组合覆盖"></a>5.条件组合覆盖</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666ec5ce42ef3.png"></p><h3 id="6-MC-DC覆盖"><a href="#6-MC-DC覆盖" class="headerlink" title="6.MC&#x2F;DC覆盖"></a>6.MC&#x2F;DC覆盖</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666ec5ce45aed.png"></p><h2 id="5-路径覆盖法"><a href="#5-路径覆盖法" class="headerlink" title="5 路径覆盖法"></a>5 路径覆盖法</h2><ol><li>依据代码绘制流程图</li><li>确定流程图的<strong>圈复杂度</strong>（cyclomatic complexity ）</li><li>确定线性独立路径的基本集合( basis set )</li><li>设计测试用例覆盖每条基本路径</li></ol><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666ec5ce443d5.png"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666ec6a10282d.png"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666ec6a0e9b59.png"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666ec6a0ed9fa.png"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666ec6a0e9dc5.png"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666ec6a1008a4.png"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666ec6a105bee.png"></p><h2 id="6-功能图法，EFMS"><a href="#6-功能图法，EFMS" class="headerlink" title="6 功能图法，EFMS"></a>6 功能图法，EFMS</h2><ul><li><p>每个程序的功能通常由静态说明和动态说明组成</p><p>静态说明描述了输入条件和输出条件之间的对应关系</p><p>动态说明描述了输入数据的次序或者转移的次序</p></li><li><p>功能图法就是为了解决动态说明问题的一种测试用例的设计方法</p></li><li><p>功能图由状态迁移图（state transition diagram，STD）和逻辑功能模型（logic function model， LFM）构成</p></li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666ec7960dd2b.png"></p><p><strong>有限状态机</strong>（ Finite State Machine ，FSM）是对象行为建模的工具，以描述对象在其生命周期内所经历的状态序列，以及<strong>如何响应来自外界的各种事件</strong>。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666ec7f899b51.png"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666ec7f899b51.png"></p><h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1><h2 id="1-测试左移和右移，贯穿全生命周期的测试思想"><a href="#1-测试左移和右移，贯穿全生命周期的测试思想" class="headerlink" title="1 测试左移和右移，贯穿全生命周期的测试思想"></a>1 测试左移和右移，贯穿全生命周期的测试思想</h2><ul><li><strong>软件测试贯穿全生命周期</strong></li><li><strong>测试左移</strong>：不仅让开发人员做更多的测试，而且需要做需求评审、设计评审，以及第1章介绍的验收测试驱动开发（ATDD）；</li><li><strong>测试右移</strong>：是在线测试（Test in Production，TiP），包括在线性能监控与分析、A&#x2F;B测试和日志分析等，可以和现在流行的DevOp联系起来。</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666ec8da2ac6c.png"></p><h2 id="2-w模型"><a href="#2-w模型" class="headerlink" title="2 w模型"></a>2 w模型</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666ec8da362c0.png"></p><h2 id="3-TMAP定义，几个阶段，模型基石及关系"><a href="#3-TMAP定义，几个阶段，模型基石及关系" class="headerlink" title="3 TMAP定义，几个阶段，模型基石及关系"></a>3 TMAP定义，几个阶段，模型基石及关系</h2><p><strong>TMap</strong> (Test Management Approach，测试管理方法)是一种结构化的、基于风险策略的测试方法体系, 目的能更早地发现缺陷，以最小的成本、有效地、彻底地完成测试任务，以减少软件发布后的支持成本。</p><p><strong>TMap</strong>所定义的测试生命周期由<strong>计划和控制、准备、说明、执行和完成等</strong>阶段组成</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666ec8da3f366.png"></p><h2 id="4-SBTM基本要素，结果，原理"><a href="#4-SBTM基本要素，结果，原理" class="headerlink" title="4 SBTM基本要素，结果，原理"></a>4 SBTM基本要素，结果，原理</h2><p>要素：session、mission。charter</p><ul><li><strong>Session</strong>(会话)是一段不受打扰的测试时间（通常是90分钟），是测试管理的最小单元。</li><li>每个session关联一个特定的、目标明确的测试任务（<strong>mission</strong>）</li><li><strong>Charter</strong> (章程，即测试指导) <strong>：</strong>对每个session如何执行进行简要的描述，相当于每个session需要一个简要的计划（提纲）</li><li>一系列Session相互支持，有机地组合在一起，周密地测试了整个产品。</li></ul><p>结果：</p><ul><li><strong>A session sheet</strong> (测试报告) <strong>：</strong> 相当于测试报告，供第三方（如测试经理、ScrumMaster等）进行检查的材料。它最好能被工具扫描、解析和合成。</li><li><strong>Debriefing</strong>（听取口头报告）：口头汇报，更准确地说，是测试人和其lead&#x2F;Manager之间的对话。</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666ec9f4b764e.png"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666ec9f4e428c.png"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666ec9f4e0374.png"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666ec9f5172c0.png"></p><h2 id="5-测试几个学派的特点"><a href="#5-测试几个学派的特点" class="headerlink" title="5 测试几个学派的特点"></a>5 测试几个学派的特点</h2><p>①<strong>分析流派</strong>：认为测试是严格的和技术性的，在学术界有许多支持者</p><p>②<strong>标准流派</strong>：将测试视为衡量进度的一种方法，强调成本和可重复的标准</p><p>③<strong>质量流派</strong>：强调过程规范性，监督开发人员并充当质量的看门人</p><p>④<strong>上下文驱动流派</strong>：强调人的价值，寻找涉众关心的bug</p><p>⑤<strong>敏捷流派</strong>：强调自动化测试，使用测试来快速验证开发是完整的</p><h2 id="6-TMM，TPI，CTP-STEP定义，特点"><a href="#6-TMM，TPI，CTP-STEP定义，特点" class="headerlink" title="6 TMM，TPI，CTP, STEP定义，特点"></a>6 TMM，TPI，CTP, STEP定义，特点</h2><p><strong>TMM</strong><br>TMMi呈现的是一个过程改进的阶段型架构。它包括阶段或级别，组织可以通过它们使测试过程从临时的和未管理的状态进化为已管理、已定义、已测量和优化的状态。在TMMi中有5个级别，规定了成熟度级别和测试过程改进的路径。每个级别都有一组过程域，组织需要实施这些过程域来达到对应的成熟度级别。</p><ul><li><p>TMMi1级—初始</p></li><li><p>TMMi2级—已管理</p></li><li><p>TMMi3级—已定义</p></li><li><p>TMMi4级—已测量</p></li><li><p>TMMi5级—优化</p></li></ul><p>过程能力描述了遵循一个软件测试过程可能达到的预期结果的范围。TMM的建立，得益于以下3点：</p><ul><li>充分吸收CMM的精华</li><li>基于历史演化的测试过程</li><li>业界的最佳实践</li></ul><p><strong>TPI</strong><br>TPI是基于连续性表示法的测试过程改进的参考模型，是在软件控制、测试知识以及过往经验的基础上开发出来的。</p><p><strong>CTP</strong><br>关键测试过程（Critical Test Process，CTP）评估模型主要是一个内容参考模型，一个上下文相关的方法，并能对模型进行裁剪。</p><p>使用 CTP 的过程改进，始于对现有测试过程的评估， 通过评估以识别过程的强弱，并结合组织的需要提供改进的意见。</p><p><strong>STEP</strong><br>STEP（Systematic Test and Evaluation Process，系统化测试和评估过程）是一个内容参考模型，认定测试是一个生命周期活动，在明确需求后开始直到系统退役。</p><h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><h2 id="1-代码评审的形式及各自特点"><a href="#1-代码评审的形式及各自特点" class="headerlink" title="1 代码评审的形式及各自特点"></a>1 代码评审的形式及各自特点</h2><ol><li>即时代码评审（配对编程）<ul><li>特点：开发人员编写代码时，审阅者坐在旁边即时阅读并更正代码。也被称为配对编程。</li><li>优点：适用于高度复杂的程序，两个开发人员可以更快、更有效地解决问题。</li><li>缺点：所需的时间和人力成本较高，可能影响开发人员的平均行数。同时，即时更正可能会中断代码作者的工作流程，并影响开发人员的学习曲线。</li></ul></li><li>同步代码评审<ul><li>特点：编码器生成代码后，要求审阅者进行评审。评审员与编码员会合，一边讨论一边评审代码。</li><li>优点：实施较为方便，是非正式和自发的过程。</li><li>缺点：可能导致开发人员强制上下文切换，影响工作效率。此外，由于缺乏对任务目标的深入了解，遗漏错误和小故障的概率较高。</li></ul></li><li>基于会议的代码评审<ul><li>特点：程序员完成工作后召开会议，整个技术团队一起讨论并改进代码。</li><li>优点：有助于团队成员更清楚地了解流程，并在团队中传播知识。</li><li>缺点：不常用，因为考虑到时间、人力成本、效率等因素，不太可能持续执行。通常只在团队对代码评审过程缺乏经验时使用。</li></ul></li><li>基于工具的代码评审（异步代码检查）<ul><li>特点：程序员完成代码后，通过工具让其他人查看和评审代码。</li><li>优点：异步完成，评审者可以根据自己的时间安排进行评审，提高了评审的灵活性。</li><li>缺点：依赖工具进行评审，可能无法完全覆盖所有问题和场景。</li></ul></li><li>个人评审<ul><li>特点：由一名开发者独立完成代码评审。</li><li>优点：简单快捷，适合小型项目或代码片段的评审。</li><li>缺点：可能受限于评审者的知识水平和经验，容易遗漏问题。</li></ul></li><li>团队评审<ul><li>特点：由开发团队的成员共同完成代码评审。</li><li>优点：可以集思广益，从多个角度发现和解决问题。</li><li>缺点：需要协调团队成员的时间和精力，可能耗时较长。</li></ul></li><li>对等评审<ul><li>特点：由两个开发者相互评审彼此的代码。</li><li>优点：有助于开发人员之间的相互学习和提高。</li><li>缺点：可能受限于评审者的知识水平和经验，且可能存在主观偏见。</li></ul></li><li>审查委员会评审<ul><li>特点：由一个由开发者、测试人员和领导人组成的委员会进行评审。</li><li>优点：能够从多个角度全面评估代码质量，确保代码符合标准和规范。</li><li>缺点：组织起来较为复杂，需要协调多个部门和人员的时间和精力。</li></ul></li></ol><h2 id="2-单元测试定义，作用，目标"><a href="#2-单元测试定义，作用，目标" class="headerlink" title="2 单元测试定义，作用，目标"></a>2 单元测试定义，作用，目标</h2><p><strong>单元测试</strong>：单元测试是对软件基本组成单元（如函数、类的方法等）进行的测试</p><p>单元质量是系统质量的基石，单元测试可以比系统测试测得更彻底</p><p><strong>测试目标</strong></p><p>主要目标：检验各单元模块是否被正确地编码</p><p>需要验证以下内容：</p><p>信息能否正确地流入和流出单元。<br>在单元工作过程中，其内部数据能否保持其完整性，包括内部数据的形式、内容及相互关系不发生错误，也包括全局变量在单元中的处理和影响。<br>在为限制数据加工而设置的边界处，能否正确工作。<br>单元的运行能否做到满足特定的逻辑覆盖。<br>单元中发生了错误，其中的出错处理措施是否有效。</p><h2 id="3桩程序，驱动程序"><a href="#3桩程序，驱动程序" class="headerlink" title="3桩程序，驱动程序"></a>3桩程序，驱动程序</h2><p><strong>驱动程序</strong><br>用于模拟被测模块的上级模块，能够调用被测模块，驱动模块接受测试数据，调用被测模块并把相关数据传送给被测模块。</p><p><strong>桩程序</strong><br>用于模拟被测模块工作过程中所调用的下层模块，一般很少进行数据处理，一般只检测被测模块传输数据的正确性。</p><h2 id="4-集成测试的概念"><a href="#4-集成测试的概念" class="headerlink" title="4 集成测试的概念"></a>4 集成测试的概念</h2><p>集成测试是将软件集成起来，对模块之间的接口进行测试。集成测试又叫子系统测试、组装测试、部件测试等。</p><h2 id="5-单一系统的集成测试的集成模式及优缺点"><a href="#5-单一系统的集成测试的集成模式及优缺点" class="headerlink" title="5 单一系统的集成测试的集成模式及优缺点"></a>5 单一系统的集成测试的集成模式及优缺点</h2><ul><li>非渐增式测试模式：先分别测试每个模块，再把所有模块按设计要求放在一起结合成所要的程序，如大棒模式。</li><li>渐增式测试模式：把下一个要测试的模块同已经测试好的模块结合进来进行测试，测试完后再把下一个应该测试的模块结合起来测试。渐增式测试又可以根据每次添加模块的路线分为自顶向下测试、自底向上测试和混合测试等方式。<ul><li>自顶向下：从主控模块开始，沿着软件的控制层次向下移动，从而逐渐把各个模块结合起来。在集成过程中，可以使用深度优先的策略或宽度优先的策略。</li><li>自底向上：从“原子”模块（ 即在软件结构最底层的模块） 开始集成以进行测试。</li><li>混合策略：在具体测试中，可采用混合策略，即结合上述的两种方法逐步实施集成测试。</li></ul></li></ul><h2 id="6-微服务特点，测试目标？测试基本步骤？"><a href="#6-微服务特点，测试目标？测试基本步骤？" class="headerlink" title="6 微服务特点，测试目标？测试基本步骤？"></a>6 微服务特点，测试目标？测试基本步骤？</h2><p><strong>微服务特点</strong>：</p><p>微服务（或称微服务架构）是一种云原生架构方法，具有以下主要特点：</p><ol><li><strong>单一职责原则</strong>：每个服务应该负责单独的功能，这是SOLID原则之一。</li><li><strong>独立部署、升级、扩展和替换</strong>：每个服务都可以单独部署及重新部署而不影响整个系统，这使得服务很容易升级。</li><li><strong>支持异构&#x2F;多种语言</strong>：每个服务的实现细节都与其他服务无关，服务之间能够解耦，团队可以针对每个服务选择最合适的开发语言、工具和方法。</li><li><strong>轻量级</strong>：微服务通常有轻量级的分布式服务框架承载，采用了P2P通信，无中心节点，性能可以线性增长；第三方软件依赖减少，减少类冲突和冗余依赖，集成和升级更方便。</li></ol><p><strong>微服务测试目标</strong>：</p><p>微服务测试的主要目标是确保每个微服务都能按照预期工作，并且与其他服务能够无缝集成。测试目标包括：</p><ol><li><strong>功能验证</strong>：验证每个微服务是否实现了其预期的功能。</li><li><strong>性能验证</strong>：确保每个微服务在性能上满足要求，并且在高负载下能够稳定运行。</li><li><strong>可靠性验证</strong>：测试微服务的容错能力，确保在出现故障时能够保持系统的整体运行。</li><li><strong>安全性验证</strong>：验证微服务的安全性，包括数据保护、身份验证和授权等。</li></ol><p><strong>微服务测试基本步骤</strong>：</p><ol><li><strong>确定系统架构</strong>：了解微服务架构，明确每个微服务的职责、接口、依赖项和通信方式。</li><li><strong>编写测试用例</strong>：根据微服务的功能和性能要求，编写测试用例。测试用例应覆盖不同的测试级别，如单元测试、集成测试和端到端测试。</li><li><strong>模拟依赖项</strong>：在微服务中，各个服务之间可能存在依赖关系。在测试过程中，需要模拟这些依赖项并确保它们正确地处理请求和响应。</li><li><strong>进行自动化测试</strong>：使用自动化测试工具来执行测试用例，并监控测试结果。自动化测试可以节省时间并减少错误。</li><li><strong>监控和日志记录</strong>：在微服务环境中，监视服务的健康和日志记录非常重要。通过监控可以及时发现故障和性能问题，并通过日志记录进行故障排查。</li><li><strong>修复问题并重新测试</strong>：如果在测试过程中发现问题，需要修复问题并重新进行测试，以确保问题已经被解决。</li></ol><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666ee3477374e.png"></p><h2 id="7-集成测试的目标"><a href="#7-集成测试的目标" class="headerlink" title="7 集成测试的目标"></a>7 集成测试的目标</h2><p>集成测试，也叫组装测试或联合测试。在单元测试的基础上，将所有模块按照设计要求（如根据结构图）组装成为子系统或系统，进行集成测试。实践表明，一些模块虽然能够单独地工作，但并不能保证连接起来也能正常的工作。程序在某些局部反映不出来的问题，在全局上很可能暴露出来，影响功能的实现。</p><p>目标在于检验与软件设计相关的程序结构问题。如数据穿过接口时可能丢失；一个模块与另一个模块可能有由于疏忽的问题而造成有害影响； 把子功能组合起来可能不产生预期的主功能；个别看起来是可以接受的误差可能积累到不能接受的程度；全程数据结构可能有错误等。</p><h1 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h1><h2 id="1-功能测试的基本思路"><a href="#1-功能测试的基本思路" class="headerlink" title="1 功能测试的基本思路"></a>1 功能测试的基本思路</h2><p>功能测试：根据产品规格说明书，来检验被测试的系统是否满足各方面功能的使用要求</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666ee3a6d1f8e.png"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666ee3a72a15f.png"></p><h2 id="2-回归测试需要解决的问题。回归测试的策略和方法"><a href="#2-回归测试需要解决的问题。回归测试的策略和方法" class="headerlink" title="2 回归测试需要解决的问题。回归测试的策略和方法"></a>2 回归测试需要解决的问题。回归测试的策略和方法</h2><ul><li>一旦程序某些区域被修改了，就可能影响原来正常工作的区域，导致受影响的区域出现回归缺陷。</li><li><strong>回归缺陷</strong>：原来正常工作的功能，没有发生需求变化，而由于受其它改动影响而产生的问题。</li><li><strong>回归测试就是为了发现回归缺陷而进行的测试</strong>。如果没有回归测试，产品就带着回归缺陷被发布出去了，造成严重后果。</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666ee4058144f.png"></p><h1 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h1><h2 id="1-性能测试目标"><a href="#1-性能测试目标" class="headerlink" title="1 性能测试目标"></a>1 性能测试目标</h2><ul><li>获取系统性能某些指标数据</li><li>为了验证系统是否达到用户提出的性能指标</li><li>发现系统中存在的性能瓶颈，优化系统的性能</li></ul><h2 id="2-什么是性能测试？"><a href="#2-什么是性能测试？" class="headerlink" title="2 什么是性能测试？"></a>2 什么是性能测试？</h2><p><strong>性能测试</strong>（performance test）就是为了发现系统性能问题或获取系统性能相关指标而进行的测试。一般在<strong>真实环境</strong>、<strong>特定负载</strong>条件下，通过<strong>工具模拟</strong>实际软件系统的运行及其操作，同时监控性能各项指标，最后对测试结果进行分析以确定系统的性能状况。</p><h2 id="3-系统性能表现"><a href="#3-系统性能表现" class="headerlink" title="3 系统性能表现"></a>3 系统性能表现</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666ef60a1ff80.png"></p><h2 id="4-按照测试目的分，性能测试类型"><a href="#4-按照测试目的分，性能测试类型" class="headerlink" title="4 按照测试目的分，性能测试类型"></a>4 按照测试目的分，性能测试类型</h2><ul><li><strong>性能基准测试</strong>：在系统标准配置下获得有关的性能指标数据，作为将来性能改进的基线(Baseline)</li><li><strong>性能验证测试</strong>：验证系统是否达到事先已定义的系统性能指标、能否满足系统的性能需求</li><li><strong>性能规划测试</strong>：在多种特定的环境下，获得不同配置的系统性能指标，从而决定系统部署的软硬件配置选型</li><li><strong>容量测试</strong>可以看作性能的测试一种，因为系统的容量可以看作是系统性能指标之一</li><li><strong>压力测试</strong> (Stress test) ：模拟实际应用的软硬件环境及用户使用过程的高负载、异常负载、超长时间运行，从而加速系统崩溃，以检查程序对异常情况的抵抗能力，找出性能瓶颈、不稳定等问题。</li><li><strong>渗入测试</strong>（soak test），通过长时间运行，使问题逐渐渗透出来，从而发现内存泄漏、垃圾回收（GC）或系统的其他问题，以检验系统的健壮性</li><li><strong>峰谷测试</strong>（peak-rest test），采用高低突变加载方式进行，先加载到高水平的负载，然后急剧降低负载，稍微平息一段时间，再加载到高水平的负载，重复这样过程，容易发现问题的蛛丝马迹，最终找到问题的根源</li></ul><h2 id="5-性能测试的基本过程"><a href="#5-性能测试的基本过程" class="headerlink" title="5 性能测试的基本过程"></a>5 性能测试的基本过程</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666ef5e4a9107.png"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666ef5c153949.png"></p><h2 id="6-什么是安全性测试"><a href="#6-什么是安全性测试" class="headerlink" title="6 什么是安全性测试"></a>6 什么是安全性测试</h2><p>安全性测试是验证应用程序的安全级别和识别潜在安全性缺陷的过程。它的主要目的是查找软件程序设计中存在的安全隐患，并检查应用程序对非法侵入的防范能力。</p><h2 id="7-渗透测试实施策略"><a href="#7-渗透测试实施策略" class="headerlink" title="7 渗透测试实施策略"></a>7 渗透测试实施策略</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666ef7de5cb00.png"></p><ul><li><strong>全程监控</strong>：采用类似wireshark的嗅探软件进行全程抓包嗅探</li><li><strong>择要监控</strong>：对扫描过程不进行录制，仅仅在数据分析后，准备发起渗透前才开启软件进行嗅探</li><li><strong>主机监控</strong>：仅监控受测主机的存活状态</li><li><strong>指定攻击源</strong>：多方监控指定源（某主机）进程、网络连接、数据传输等</li><li><strong>对关键系统</strong>，可以采用对目标的副本进行渗透测试</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666ef7de734a3.png"></p><h2 id="8-软件安全性测试有哪两种？有什么关系和区别？"><a href="#8-软件安全性测试有哪两种？有什么关系和区别？" class="headerlink" title="8 软件安全性测试有哪两种？有什么关系和区别？"></a>8 软件安全性测试有哪两种？有什么关系和区别？</h2><ul><li><p><strong>安全功能测试</strong> (Security Functional Testing)：数据机密性、完整性、可用性、不可否认性、身份认证、授权、访问控制、审计跟踪、委托、隐私保护、安全管理等</p></li><li><p><strong>安全漏洞测试</strong> (Security Vulnerability Testing)：从攻击者的角度, 以发现软件的安全漏洞为目的。安全漏洞是指系统在设计、实现、操作、管理上存在的可被利用的缺陷或弱点</p></li></ul><p><strong>关系与区别</strong>：</p><ul><li>关系<ul><li>功能安全性测试和安全漏洞测试是软件安全性测试的两个重要方面，它们共同构成了软件安全测试的完整体系。</li><li>功能安全性测试关注软件功能的正确性，而安全漏洞测试关注软件系统的安全防护能力。二者相辅相成，共同提高软件的安全性。</li></ul></li><li>区别<ul><li><strong>测试目标</strong>：功能安全性测试主要关注软件功能的正确性，而安全漏洞测试主要关注软件系统的安全防护能力。</li><li><strong>测试方法</strong>：功能安全性测试通常采用黑盒测试方法，通过设计测试用例来验证软件的功能表现；而安全漏洞测试则可能采用白盒测试方法，通过深入分析软件系统的内部结构和代码来发现潜在的安全漏洞。</li><li><strong>测试结果</strong>：功能安全性测试的结果通常用于评估软件的功能质量和用户体验；而安全漏洞测试的结果则直接反映软件系统的安全防护能力和可能存在的安全风险。</li></ul></li></ul><h2 id="9-安全性测试的任务"><a href="#9-安全性测试的任务" class="headerlink" title="9 安全性测试的任务"></a>9 安全性测试的任务</h2><p>全面检验软件在<strong>需求</strong>规格说明中规定的防止危险状态措施的有效性和在每一个危险状态下的反应</p><p>对软件<strong>设计</strong>中用于提高安全性的结构、算法、容错、冗余、中断处理等方案，进行针对性测试</p><p>在<strong>异常</strong>条件下测试软件，以表明不会因可能的单个或多个输入错误而导致不安全状态</p><p>对安全性<strong>关键的软件单元、组件</strong>，单独进行加强的测试，以确认其满足安全性需求</p><h2 id="10-安全性测试方法按内外部分为哪两种？"><a href="#10-安全性测试方法按内外部分为哪两种？" class="headerlink" title="10 安全性测试方法按内外部分为哪两种？"></a>10 安全性测试方法按内外部分为哪两种？</h2><p><strong>基于威胁的方法</strong>：从软件<strong>外部</strong>考察其安全性，识别软件面临的安全威胁并测试其是否能够发生</p><p><strong>基于漏洞的方法</strong> ：从软件<strong>内部</strong>考虑其安全性，识别软件的安全漏洞，如借助特定的漏洞扫描工具 </p><h2 id="11-什么是XSS攻击和sql注入攻击，如何进行测试和防范"><a href="#11-什么是XSS攻击和sql注入攻击，如何进行测试和防范" class="headerlink" title="11 什么是XSS攻击和sql注入攻击，如何进行测试和防范"></a>11 什么是XSS攻击和sql注入攻击，如何进行测试和防范</h2><h3 id="XSS攻击"><a href="#XSS攻击" class="headerlink" title="XSS攻击"></a>XSS攻击</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>XSS攻击（跨站脚本攻击）通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java、VBScript、ActiveX、Flash或者甚至是普通的HTML。</p><h4 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h4><ol><li>反射型XSS<ul><li>找寻目标：找到应用程序中所有接受用户输入并在响应中反映这些输入的地方。</li><li>测试注入：尝试插入各种恶意脚本载荷，观察是否在响应中原样反映出来。</li><li>绕过过滤器：如果应用程序具有某种输入过滤或转义机制，尝试使用不同的编码、大小写或其他技巧来绕过它们。</li></ul></li><li>存储型XSS<ul><li>找寻目标：查找应用程序中的所有地方，可以提交数据并在其他地方再次显示这些数据。</li><li>测试注入：尝试插入恶意载荷，并希望这些载荷能够被存储并在后续的请求中再次呈现给用户。</li><li>检查后端：了解后端如何处理和存储数据可以帮助更好地定制攻击。</li></ul></li><li>DOM型XSS<ul><li>分析JavaScript：检查代码中如何处理用户输入，特别是与DOM操作相关的部分。</li></ul></li></ol><h4 id="防范措施"><a href="#防范措施" class="headerlink" title="防范措施"></a>防范措施</h4><ol><li><strong>输入验证</strong>：在服务器端对用户输入进行验证和过滤，检查输入是否符合预期的格式。</li><li><strong>输出转义</strong>：在将用户输入显示给用户之前，确保对其进行转义，以防止恶意脚本的注入。</li><li><strong>CSP（Content Security Policy）</strong>：使用CSP来限制JavaScript的来源，防止恶意脚本的注入。</li></ol><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666ef87abcd96.png"></p><h3 id="SQL注入攻击"><a href="#SQL注入攻击" class="headerlink" title="SQL注入攻击"></a>SQL注入攻击</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>SQL注入攻击是指后台数据库操作时，如果拼接外部参数到SQL语句中，就可能导致欺骗服务器执行恶意的SQL语句，造成数据泄露、删库、页面篡改等严重后果。</p><h4 id="测试方法-1"><a href="#测试方法-1" class="headerlink" title="测试方法"></a>测试方法</h4><ol><li><strong>基于错误消息的注入测试</strong>：尝试注入语法错误，观察返回的错误消息是否包含敏感信息或数据库结构。</li><li><strong>基于布尔注入的测试</strong>：注入布尔表达式，观察返回的结果是否符合预期。</li><li><strong>基于时间延迟的注入测试</strong>：注入延迟语句，观察查询的执行时间是否明显延长。</li><li><strong>基于报错注入的测试</strong>：注入报错语句，观察返回的错误消息是否包含敏感信息。</li></ol><h4 id="防范措施-1"><a href="#防范措施-1" class="headerlink" title="防范措施"></a>防范措施</h4><ol><li><strong>用户分级管理</strong>：严格控制用户的权限，对于普通用户，禁止给予数据库建立、删除、修改等相关权限。</li><li><strong>参数传值</strong>：禁止将变量直接写入到SQL语句，必须通过设置相应的参数来传递相关的变量。</li><li><strong>基础过滤与二次过滤</strong>：对用户输入进行检查，对于单引号、双引号、冒号等字符进行转换或者过滤。</li><li><strong>使用安全参数</strong>：在数据库设计时设置专门的SQL安全参数，尽量使用安全参数来杜绝注入式攻击。</li><li><strong>漏洞扫描</strong>：使用专业的扫描工具，及时发现系统存在的SQL攻击安全漏洞。</li></ol><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666ef87a7edac.png"></p><h2 id="12-web安全性测试可从哪些方法开展"><a href="#12-web安全性测试可从哪些方法开展" class="headerlink" title="12 web安全性测试可从哪些方法开展"></a>12 web安全性测试可从哪些方法开展</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666efae515eb6.png"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666efae516f11.png"></p><h2 id="13-什么是软件可靠性？可从哪几个指标度量？各自的定义"><a href="#13-什么是软件可靠性？可从哪几个指标度量？各自的定义" class="headerlink" title="13 什么是软件可靠性？可从哪几个指标度量？各自的定义"></a>13 什么是软件可靠性？可从哪几个指标度量？各自的定义</h2><p>可靠性：在规定的一段时间和条件下，软件能维持其性能水平的能力有关的一组属性，可用成熟性、容错性、易恢复性三个基本子特性来度量。</p><ul><li><p><strong>成熟性度量</strong>：通过错误发现率DDP（Defect Detection Percentage）来表现。DDP越小，软件越成熟。</p><p>DDP&#x3D;测试发现的错误数量&#x2F;已知的全部错误数量</p></li><li><p><strong>容错性</strong>测试在下面一节介绍</p></li><li><p><strong>恢复性</strong>的测试先设法（模拟）使系统崩溃、失效等，然后计算其系统和数据恢复的时间来做出易恢复性评估。</p></li></ul><h2 id="14-容错测试的要点？"><a href="#14-容错测试的要点？" class="headerlink" title="14 容错测试的要点？"></a>14 容错测试的要点？</h2><p>容错测试是一种对抗性的测试过程。在这种测试中，通过各种手段让软件强制性地发生故障，或将把应用程序或系统置于（模拟的）异常条件下，以产生故障，例如设备输入&#x2F;输出（I&#x2F;O）故障或无效的数据库指针和关键字等</p><h2 id="15-什么是A-B测试？有什么特点"><a href="#15-什么是A-B测试？有什么特点" class="headerlink" title="15 什么是A&#x2F;B测试？有什么特点"></a>15 什么是A&#x2F;B测试？有什么特点</h2><p> A&#x2F;B测试（ABTest） 是将用户分成不同的组，同时在线试验产品的不同版本，通过用户反馈的真实数据来确定哪一个方案更好</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666efa05b70c8.png"></p><p><strong>特点</strong></p><ul><li><strong>先验性</strong>：采用流量分割与小流量测试的方式，先让线上部分小流量用户使用以验证设计，再根据数据反馈来推广到全流量，减少产品损失</li><li><strong>并行性</strong>：同时运行两个或两个以上版本的试验完成对比分析，而且保证每个版本所处的环境一致的，避免流程周期长的问题，节省验证时间</li><li><strong>科学性</strong>：基于统计的数据来做出决策，避免主观或经验的错误决策</li></ul><h1 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h1><h2 id="1-软件本地化，国际化，全球化，相互关系"><a href="#1-软件本地化，国际化，全球化，相互关系" class="headerlink" title="1 软件本地化，国际化，全球化，相互关系"></a>1 软件本地化，国际化，全球化，相互关系</h2><p><strong>I18N——软件国际化</strong></p><p>I18N是借助功能设计和代码实现中软件系统有能力处理多种语言和不同文化，使创建不同语言版本时，不需要重新编写代码的软件工程方法。</p><ul><li><p>支持Unicode字符集、双字节的字符</p></li><li><p>分离程序代码和显示内容</p></li><li><p>消除Hard code</p></li><li><p>使用Header files 去定义经常被调用的代码段</p></li><li><p>改善翻译文本尺寸，具有调整的灵活</p></li><li><p>支持各个国家的键盘设置</p></li><li><p>支持文字排序和大小写转换</p></li><li><p>支持各个国家的度量衡，时区，货币单位格式等的设置</p></li><li><p>国际化用户界面设计（自我定义）。</p></li></ul><p><strong>L10N——软件本地化</strong></p><p>L10N是将一个软件产品按特定国家&#x2F;地区或语言市场的需要进行加工，使之满足特定市场上的用户对语言和文化的特殊要求的软件生产活动。</p><ul><li>翻译</li><li>地区文化、宗教</li><li>度量衡和时区等</li><li>软件用户界面（UI）</li><li>联机文档 (帮助文档和功能性的PDF文档)</li><li>热键设置</li></ul><p><strong>G11N——软件全球化</strong><br>G11N &#x3D; I18N + L10N</p><p><strong>关系和区别</strong></p><ul><li>I18N是L10N的基础和前提，为L10N做准备</li><li>L10N是I18N向特定本地语言环境的转换</li><li>I18N 是软件产品源语言开发的一部分，属于Engineering</li><li>L10N 可以独立于Engineering，可由第三方完成</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/18/667146ea9cc4a.png"></p><h2 id="2-unicode与utf-x关系，特点"><a href="#2-unicode与utf-x关系，特点" class="headerlink" title="2 unicode与utf-x关系，特点"></a>2 unicode与utf-x关系，特点</h2><h3 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h3><ul><li><strong>Unicode</strong>：是一种在计算机上使用的字符编码标准，旨在将全世界常用文字都涵盖进去。它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。</li><li><strong>UTF-X</strong>：是Unicode的实现方式或编码格式，其中“X”表示码元的宽度（比特数）。Unicode编码本身并不直接决定字符在内存或磁盘上的存储方式，而是由UTF-X这样的编码格式来决定的。</li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><h4 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h4><ol><li><strong>唯一性</strong>：为每种语言中的每个字符设定了统一并且唯一的二进制编码。</li><li><strong>跨平台性</strong>：满足跨语言、跨平台进行文本转换、处理的要求。</li><li><strong>可扩展性</strong>：不断扩展以支持新的字符和符号，新版本会引入新的码点。</li><li><strong>广泛字符支持</strong>：能够表示非常广泛的字符范围，包括各种文字、符号、表情符号等。</li></ol><h4 id="UTF-X"><a href="#UTF-X" class="headerlink" title="UTF-X"></a>UTF-X</h4><ul><li>UTF-8<ul><li><strong>8位变长编码</strong>：对于大多数常用字符集（如ASCII中的0~127字符）只使用单字节，而对其他常用字符（如中文）使用多字节（通常是3字节）。</li><li><strong>兼容性</strong>：与ASCII编码兼容，使得ASCII字符在UTF-8中仍然只占用一个字节。</li><li><strong>广泛使用</strong>：由于其高效的编码方式和兼容性，UTF-8成为互联网上最为常见的字符编码方式。</li></ul></li><li>UTF-16<ul><li><strong>16位编码</strong>：大部分情况下，UTF-16使用两个字节（16位）来表示一个字符，但某些特殊字符可能需要使用四个字节（称为“代理对”或“surrogate pairs”）。</li><li><strong>与Unicode码点关联</strong>：UTF-16编码大致相当于Unicode编码的实现，与CPU字序有关。</li></ul></li><li>UTF-32<ul><li><strong>32位固定编码</strong>：每个字符都使用四个字节（32位）进行编码，因此也被称为UCS-4或Unicode编码的直接表示。</li><li><strong>简洁性</strong>：由于每个字符都使用固定长度的编码，因此编码和解码过程相对简单。</li></ul></li></ul><h2 id="3-软件本地化基本步骤"><a href="#3-软件本地化基本步骤" class="headerlink" title="3 软件本地化基本步骤"></a>3 软件本地化基本步骤</h2><ul><li>建立配置管理体系，跟踪目标语言各个版本的源代码</li><li>创造和维护术语表</li><li>源语言代码和资源文件分离、或提取需要本地化的文本</li><li>把分离或提取的文本、图片等翻译成目标语言</li><li>把翻译好的文本、图片重新检入目标语言的源代码版本</li><li>如果需要，编译目标语言的源代码</li><li>测试翻译后的软件，调整UI 以适应翻译后的文本</li><li>测试本地化后的软件，确保格式和内容都正确</li></ul><h2 id="4-本地化测试主要有哪些工作"><a href="#4-本地化测试主要有哪些工作" class="headerlink" title="4 本地化测试主要有哪些工作"></a>4 本地化测试主要有哪些工作</h2><p><strong>功能性测试</strong>，所有基本功能、安装、升级等测试；</p><p><strong>翻译测试</strong>，包括语言完整性、术语准确性等的检查；</p><p><strong>可用性测试</strong>，包括用户界面、度量衡和时区等；</p><p><strong>兼容性调试</strong>，包括硬件兼容性、版本兼容性等测试；</p><p><strong>文化、宗教、喜好等适用性测试</strong></p><p><strong>手册验证</strong>，包括联机文件、在线帮助、PDF文件等测试</p><h2 id="5-软件本地化测试完整路线"><a href="#5-软件本地化测试完整路线" class="headerlink" title="5 软件本地化测试完整路线"></a>5 软件本地化测试完整路线</h2><p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666efe28ba72a.png"></p><h1 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h1><h2 id="1-自动化测试与测试自动化"><a href="#1-自动化测试与测试自动化" class="headerlink" title="1 自动化测试与测试自动化"></a>1 自动化测试与测试自动化</h2><p>通过平台、系统或工具自动地完成测试的某类工作都可以归为<strong>测试自动化</strong></p><p><strong>自动化测试</strong>更侧重的测试用例或测试数据生成、测试执行和测试结果呈现等自动化</p><h2 id="2-如何理解测试自动化"><a href="#2-如何理解测试自动化" class="headerlink" title="2 如何理解测试自动化"></a>2 如何理解测试自动化</h2><ul><li><strong>定义</strong>：测试自动化是把以人为驱动的测试行为转化为机器执行的一种过程。它旨在通过自动化工具和脚本执行测试用例，自动比对测试结果与预期结果，以评估系统的功能和性能。</li><li><strong>目的</strong>：通过测试自动化，可以节省人力、时间和硬件资源，提高测试覆盖率、减少回归测试的工作量，并确保测试的一致性和准确性。</li></ul><h2 id="3-测试自动化实现的原理，几种技术"><a href="#3-测试自动化实现的原理，几种技术" class="headerlink" title="3 测试自动化实现的原理，几种技术"></a>3 测试自动化实现的原理，几种技术</h2><p><strong>代码分析</strong>：类似于高级编译系统，在工具中定义类、对象、函数、变量等定义规则、语法规则等，在分析时对代码进行语法扫描，找出不符合编码规范的地方。</p><p><strong>对象识别</strong>  ：Windows对象 、Mac对象、Web DOM对象</p><p><strong>脚本技术：</strong>  线性脚本 结构化脚本 数据驱动脚本、关键字驱动脚本 </p><p><strong>自动比较技术：</strong>静态比较和动态比较，简单比较和复杂比较，敏感性测试比较和健壮性测试比较，比较过滤器</p><p><strong>测试自动化系统的构成：</strong>测试工具的分类、测试工具的选择、测试自动化普遍存在的问题、自动化测试的引入和应用</p><p> <strong>自动化测试的引入和应用</strong></p><p>  找准测试自动化的切入点</p><p>  把测试开发纳入整个软件开发体系</p><p>  测试自动化依赖测试流程和测试用例</p><p>  软件测试自动化的投入较大</p><p>  进行资源的合理调度</p><h2 id="4-自动化测试的流程"><a href="#4-自动化测试的流程" class="headerlink" title="4 自动化测试的流程"></a>4 自动化测试的流程</h2><p><strong>需求分析</strong>：</p><ul><li>确定测试范围：识别哪些功能适合自动化测试。</li><li>定义测试目标：明确自动化测试的目的和预期结果。</li></ul><p><strong>测试计划</strong>：</p><ul><li>制定测试策略：确定测试工具、框架和技术。</li><li>资源分配：分配测试人员、硬件和软件资源。</li><li>时间安排：制定测试时间表，包括开发、执行和维护时间。</li></ul><p><strong>测试设计</strong>：</p><ul><li>编写测试用例：根据需求文档和功能说明编写详细的测试用例。</li><li>选择测试数据：确定并准备所需的测试数据。</li></ul><p><strong>环境搭建</strong>：</p><ul><li>配置测试环境：搭建所需的硬件和软件环境，包括服务器、数据库和网络配置。</li><li>安装测试工具：安装和配置自动化测试工具和框架。</li></ul><p><strong>脚本开发</strong>：</p><ul><li>编写自动化测试脚本：根据测试用例使用编程语言编写自动化测试脚本。</li><li>参数化测试脚本：使脚本能够处理不同的数据输入，支持数据驱动测试。</li></ul><p><strong>脚本调试</strong>：</p><ul><li>调试和验证：运行测试脚本，确保其能够正确执行并捕获预期的结果。</li><li>修正错误：修复调试过程中发现的脚本问题。</li></ul><p><strong>测试执行</strong>：</p><ul><li>自动化执行：将测试脚本集成到CI&#x2F;CD流水线，通过持续集成工具（如Jenkins、GitLab CI）自动触发测试执行。</li><li>手动执行：在必要时手动触发测试执行，例如在开发和调试阶段。</li></ul><p><strong>结果分析</strong>：</p><ul><li>生成报告：收集和整理测试执行的结果，生成详细的测试报告。</li><li>结果验证：验证测试结果是否符合预期，分析测试失败的原因。</li></ul><p><strong>缺陷管理</strong>：</p><ul><li>缺陷报告：记录在测试过程中发现的缺陷，使用缺陷管理工具（如JIRA、Bugzilla）进行跟踪。</li><li>缺陷修复：开发团队根据缺陷报告修复问题，修复完成后重新测试。</li></ul><p><strong>回归测试</strong>：</p><ul><li>自动化回归测试：在每次代码变更后执行自动化回归测试，确保新的修改没有引入新的缺陷。</li><li>更新测试脚本：根据需求变化和缺陷修复情况更新测试脚本。</li></ul><p><strong>测试优化</strong>：</p><ul><li>反馈和改进：根据测试结果和反馈，不断优化测试用例、测试脚本和测试流程。</li><li>提高覆盖率：增加新的自动化测试用例，提高测试覆盖率和深度。</li></ul><p><strong>维护和管理</strong>：</p><ul><li>脚本维护：定期维护和更新测试脚本，确保其与软件版本一致。</li><li>测试环境管理：维护测试环境的稳定性和一致性，避免环境差异导致的测试失败。</li></ul><h2 id="5-几种脚本技术"><a href="#5-几种脚本技术" class="headerlink" title="5 几种脚本技术"></a>5 几种脚本技术</h2><p>线性脚本<br>结构化脚本<br>数据驱动脚本<br>关键字驱动脚本</p><h2 id="6-自动化功能测试基本构成"><a href="#6-自动化功能测试基本构成" class="headerlink" title="6 自动化功能测试基本构成"></a>6 自动化功能测试基本构成</h2><ol><li><strong>测试工具和框架</strong></li></ol><ul><li><strong>自动化测试工具</strong>：用于执行自动化测试脚本的工具，如Selenium、Appium、QTP&#x2F;UFT等。</li><li><strong>测试框架</strong>：用于组织和运行测试的框架，如JUnit、TestNG、PyTest等。</li><li><strong>辅助工具</strong>：如CI&#x2F;CD工具（Jenkins、GitLab CI）、版本控制系统（Git）和缺陷管理工具（JIRA、Bugzilla）。</li></ul><ol start="2"><li><strong>测试脚本</strong></li></ol><ul><li><strong>脚本开发</strong>：使用编程语言（如Java、Python、JavaScript）编写测试脚本，模拟用户操作并验证功能。</li><li><strong>脚本管理</strong>：组织和维护测试脚本，包括版本控制和代码复用。</li><li><strong>数据驱动测试</strong>：通过参数化脚本使其能够处理不同的数据输入，从而进行广泛的测试。</li></ul><ol start="3"><li><strong>测试数据</strong></li></ol><ul><li><strong>数据准备</strong>：创建和管理用于测试的数据集，包括输入数据和预期结果。</li><li><strong>数据存储</strong>：测试数据可以存储在文件（如CSV、JSON、XML）或数据库中，以便于读取和使用。</li></ul><ol start="4"><li><strong>测试环境</strong></li></ol><ul><li><strong>环境配置</strong>：设置和配置测试所需的硬件和软件环境，包括测试服务器、操作系统、浏览器、数据库等。</li><li><strong>环境管理</strong>：确保测试环境的稳定性和一致性，避免环境差异导致的测试失败。</li></ul><ol start="5"><li><strong>测试执行</strong></li></ol><ul><li><strong>自动化执行</strong>：通过自动化工具和脚本执行测试，通常集成到CI&#x2F;CD流水线中以实现持续测试。</li><li><strong>手动触发</strong>：在必要时手动运行测试脚本，特别是在调试和开发阶段。</li></ul><ol start="6"><li><strong>测试结果分析</strong></li></ol><ul><li><strong>结果报告</strong>：生成测试执行结果报告，包括测试通过与失败的详细信息。</li><li><strong>日志记录</strong>：记录测试执行日志，用于分析测试失败原因和调试脚本。</li></ul><ol start="7"><li><strong>缺陷管理</strong></li></ol><ul><li><strong>缺陷报告</strong>：记录测试中发现的缺陷，并使用缺陷管理工具进行跟踪和管理。</li><li><strong>缺陷修复</strong>：开发团队根据缺陷报告修复问题，测试团队重新验证修复后的功能。</li></ul><ol start="8"><li><strong>反馈和优化</strong></li></ol><ul><li><strong>结果反馈</strong>：分析测试结果和缺陷报告，反馈给开发和测试团队。</li><li><strong>测试优化</strong>：根据反馈不断优化测试脚本、测试数据和测试流程，提高测试效率和覆盖率。</li></ul><ol start="9"><li><strong>维护和更新</strong></li></ol><ul><li><strong>脚本维护</strong>：定期更新和维护测试脚本，以确保其与软件最新版本保持一致。</li><li><strong>环境维护</strong>：保持测试环境的最新配置，定期检查和更新环境设置。</li></ul><h2 id="7-TA框架的构成及各部分特点"><a href="#7-TA框架的构成及各部分特点" class="headerlink" title="7 TA框架的构成及各部分特点"></a>7 TA框架的构成及各部分特点</h2><p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/06/16/666f0417e509b.png"></p><ol><li><strong>Harness&#x2F;IDE</strong></li></ol><ul><li><strong>集成开发环境</strong>：提供开发和执行测试脚本的统一平台。</li><li><strong>调试功能</strong>：支持调试测试脚本，提供断点设置、变量监控等功能。</li><li><strong>结果显示</strong>：集成报告功能，展示测试结果和日志。</li></ul><ol start="2"><li><strong>脚本语言（Script Language）</strong></li></ol><ul><li><strong>灵活性</strong>：使用高级编程语言（如Python、Java、JavaScript）编写测试脚本，灵活性高。</li><li><strong>可读性</strong>：脚本语法清晰易懂，便于测试人员编写和维护。</li><li><strong>可复用性</strong>：支持模块化编程，方便代码复用和维护。</li></ul><ol start="3"><li><strong>代理（Agents）</strong></li></ol><ul><li><strong>分布式执行</strong>：支持在不同环境或机器上执行测试，适合大规模测试任务。</li><li><strong>资源管理</strong>：管理和分配测试资源，优化测试执行效率。</li><li><strong>监控功能</strong>：实时监控测试执行状态，记录执行日志。</li></ul><ol start="4"><li><strong>工具（Tools）</strong></li></ol><ul><li><strong>测试工具集成</strong>：支持集成各种测试工具，如Selenium、Appium等，用于不同类型的测试（功能测试、性能测试等）。</li><li><strong>自动化功能</strong>：提供自动化操作的支持，模拟用户行为、进行界面操作等。</li><li><strong>扩展性</strong>：支持插件机制，可以扩展和定制工具功能。</li></ul><ol start="5"><li><strong>任务安排（Scheduler）</strong></li></ol><ul><li><strong>自动调度</strong>：根据预设计划自动安排测试任务的执行，支持定时和触发机制。</li><li><strong>任务管理</strong>：管理测试任务的生命周期，包括任务的创建、启动、暂停和终止。</li><li><strong>并发执行</strong>：支持并发执行多个测试任务，提高测试效率。</li></ul><ol start="6"><li><strong>报告（Report）</strong></li></ol><ul><li><strong>结果汇总</strong>：汇总测试结果，生成详细的测试报告。</li><li><strong>可视化</strong>：提供图表和统计信息，直观展示测试结果和覆盖率。</li><li><strong>可追溯性</strong>：详细记录测试执行过程，便于追踪和分析问题。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 大学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目实训个人周报7</title>
      <link href="/2024/06/11/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%AE%AD%E4%B8%AA%E4%BA%BA%E5%91%A8%E6%8A%A57/"/>
      <url>/2024/06/11/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%AE%AD%E4%B8%AA%E4%BA%BA%E5%91%A8%E6%8A%A57/</url>
      
        <content type="html"><![CDATA[<h3 id="转换为Alpaca数据集和Json格式用于模型训练和微调"><a href="#转换为Alpaca数据集和Json格式用于模型训练和微调" class="headerlink" title="转换为Alpaca数据集和Json格式用于模型训练和微调"></a>转换为Alpaca数据集和Json格式用于模型训练和微调</h3><p>之前得到了csv格式的数据集，而模型训练和微调需要用到json格式，于是进行转换。下面是代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取CSV文件</span></span><br><span class="line">data = pd.read_csv(<span class="string">&#x27;cleaned_translated_train.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换数据为JSON格式，每一行变成一个字典</span></span><br><span class="line">json_data = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;instruction&quot;</span>: row[<span class="string">&quot;question&quot;</span>],</span><br><span class="line">        <span class="string">&quot;input&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">        <span class="string">&quot;output&quot;</span>: row[<span class="string">&quot;answer&quot;</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> index, row <span class="keyword">in</span> data.iterrows()</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将JSON数据保存到文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;data_for_training.json&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> json_file:</span><br><span class="line">    json.dump(json_data, json_file, ensure_ascii=<span class="literal">False</span>, indent=<span class="number">4</span>)</span><br></pre></td></tr></table></figure><ol><li>读取CSV文件：使用Pandas读取<code>cleaned_translated_train.csv</code>文件。</li><li>构建JSON格式数据：对于数据框中的每一行，创建一个字典，其中<code>instruction</code>键对应问题列的内容，<code>input</code>键为空字符串，<code>output</code>键对应答案列的内容。</li><li>保存JSON数据：将构建的JSON数据列表保存到名为<code>data_for_training.json</code>的文件中，使用<code>json.dump</code>进行序列化，保持格式化输出以提高可读性。</li></ol><h3 id="多个处理好的Json文件进行拼接，用于最后的Lora微调和Rag向量化"><a href="#多个处理好的Json文件进行拼接，用于最后的Lora微调和Rag向量化" class="headerlink" title="多个处理好的Json文件进行拼接，用于最后的Lora微调和Rag向量化"></a>多个处理好的Json文件进行拼接，用于最后的Lora微调和Rag向量化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 所有JSON文件都存放在一个名为 &#x27;json_files&#x27; 的目录中</span></span><br><span class="line">directory_path = <span class="string">&#x27;json_files&#x27;</span></span><br><span class="line">all_data = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历目录中的每个文件</span></span><br><span class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> os.listdir(directory_path):</span><br><span class="line">    <span class="keyword">if</span> filename.endswith(<span class="string">&#x27;.json&#x27;</span>):</span><br><span class="line">        file_path = os.path.join(directory_path, filename)</span><br><span class="line">        <span class="comment"># 打开并读取JSON文件</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">            data = json.load(file)</span><br><span class="line">            all_data.append(data)  <span class="comment"># 将读取的数据添加到列表中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将合并后的数据保存到一个新的JSON文件中</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;combined_data.json&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> output_file:</span><br><span class="line">    json.dump(all_data, output_file, ensure_ascii=<span class="literal">False</span>, indent=<span class="number">4</span>)</span><br></pre></td></tr></table></figure><ol><li>导入所需的库：使用<code>json</code>进行数据的序列化和反序列化，使用<code>os</code>来处理文件和目录路径。</li><li>设置文件目录：所有的JSON文件都放在名为<code>json_files</code>的目录中。</li><li>读取JSON文件<ul><li>使用<code>os.listdir()</code>遍历指定目录中的所有文件。</li><li>检查文件扩展名是否为<code>.json</code>，确保只处理JSON文件。</li><li>对于每个JSON文件，打开并使用<code>json.load()</code>读取内容，然后将这些内容添加到<code>all_data</code>列表中。</li></ul></li><li>写入合并后的JSON数据<ul><li>所有文件的数据被存储在<code>all_data</code>列表中，该列表包含了从每个文件读取的数据。</li><li>使用<code>json.dump()</code>将这个列表写入一个名为<code>combined_data.json</code>的新文件中，设置<code>ensure_ascii=False</code>来支持非ASCII字符，<code>indent=4</code>提供了格式化的输出，使得JSON文件易于阅读。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 大学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目实训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络安全期末复习</title>
      <link href="/2024/06/10/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/"/>
      <url>/2024/06/10/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h5 id="ssh-authorized-keys"><a href="#ssh-authorized-keys" class="headerlink" title=".ssh&#x2F;authorized_keys"></a>.ssh&#x2F;authorized_keys</h5><p>就是为了让两个 Linux 机器之间使用 ssh 不需要用户名和密码。采用了数字签名 RSA 或者 DSA 来完成这个操作。</p><h5 id="ssh-id-rsa"><a href="#ssh-id-rsa" class="headerlink" title=".ssh&#x2F;id_rsa"></a>.ssh&#x2F;id_rsa</h5><p>是SSH（Secure Shell）协议使用的默认私钥文件。当连接到支持SSH的远程服务器或系统时，id_rsa文件用于SSH身份验证。 它包含SSH密钥对的私钥部分。相应的公钥（通常存储在id_rsa.pub文件中）被添加到远程服务器上的~&#x2F;.ssh&#x2F;authorized_keys文件中，以允许使用关联的私钥进行身份验证。</p><h5 id="ssh-id-rsa-pub"><a href="#ssh-id-rsa-pub" class="headerlink" title=".ssh&#x2F;id_rsa.pub"></a>.ssh&#x2F;id_rsa.pub</h5><p>是与用于SSH身份验证的私钥文件(id_rsa)对应的公钥文件。它包含可以与支持SSH的远程服务器或系统共享的加密密钥。当您想要通过远程服务器进行身份验证时，通常需要将您的公钥添加到服务器上的~&#x2F;.ssh&#x2F;authorized_keys文件中。这允许服务器通过将您在SSH连接期间提供的公钥与存储在authorized_keys文件中的公钥进行匹配来验证您的身份。</p><p>与应保持安全且不可共享的私钥不同，公钥可以自由分发并与他人共享，而不会危及SSH连接的安全性。</p><h5 id="ssh-known-hosts"><a href="#ssh-known-hosts" class="headerlink" title=".ssh&#x2F;known_hosts"></a>.ssh&#x2F;known_hosts</h5><p>是由SSH(Secure Shell)客户端自动生成和维护的文件。用途是存储SSH客户端先前连接到的远程服务器或系统的公钥。当连接到远程服务器时，客户端根据known_hosts文件中的条目检查服务器的公钥以验证服务器的真实性。如果服务器的公钥与存储的条目匹配，则客户端继续连接。如果不匹配或密钥已更改，客户端可能会发出警告或拒绝连接以防止潜在的安全风险，如中间人攻击。</p><p>known_hosts文件中的每一行通常包含远程服务器的主机名或IP地址、使用的密钥类型以及公钥本身。</p><h5 id="802-11i"><a href="#802-11i" class="headerlink" title="802.11i"></a>802.11i</h5><p>IEEE 802.11i是802.11工作组为新一代WLAN制定的安全标准，是无线安全标准。这种安全标准为增强WLAN的<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86/11048982?fromModule=lemma_inlink">数据加密</a>和认证性能，定义了RSN（Robust Security Network）的概念，并且针对<a href="https://baike.baidu.com/item/WEP%E5%8A%A0%E5%AF%86/10328386?fromModule=lemma_inlink">WEP加密</a>机制的各种缺陷做了多方面的改进。</p><h5 id="802-1x"><a href="#802-1x" class="headerlink" title="802.1x"></a>802.1x</h5><p>为解决<a href="https://info.support.huawei.com/info-finder/encyclopedia/zh/WLAN.html">无线局域网</a>的安全问题，IEEE 802委员会提出了802.1X协议。802.1X协议可以控制用户的网络访问权限，防止身份不明或未经授权的用户传输和接收数据。由于802.1X协议的普适性，因此后来也广泛应用于有线局域网。</p><h5 id="AH（Authentication-header）"><a href="#AH（Authentication-header）" class="headerlink" title="AH（Authentication header）"></a>AH（Authentication header）</h5><p>是IPsec（互联网协议安全）协议套件的一个组件，用于提供IP网络上的安全通信。它是IPsec中的两个主要协议之一，用来提供数据完整性校验和源校验，即只提供校验功能，并没有提供加密功能。</p><p>传输模式下IPv4的AH协议封装的数据包，原始的数据包是一个IP header 紧接着一个TCP header，然后就是data，AH协议封装的数据包，会在IP Header和TCP Header之间增加一个AH header。</p><p>隧道模式下的AH数据包封装,这种模式把整个数据包都进行封装，然后再源的IP header之前增加AH header，然后再增加一个新的IPV4 header完成封装。</p><h5 id="ALL-PROXY"><a href="#ALL-PROXY" class="headerlink" title="ALL_PROXY"></a>ALL_PROXY</h5><p>ALL_PROXY环境变量用于配置代理服务器，该代理服务器将用于源自系统的所有类型的网络流量。设置后，ALL_PROXY变量会覆盖任何其他代理设置，并通过指定的代理服务器引导所有网络请求。这对于需要通过特定代理配置访问互联网的场景非常有用，例如在公司或受限网络环境中。</p><h5 id="Apache2-mod-proxy"><a href="#Apache2-mod-proxy" class="headerlink" title="Apache2 mod_proxy"></a>Apache2 mod_proxy</h5><p>Apache的mod_proxy是一个Apache HTTP Server模块，可以代理HTTP和其他协议。它允许Apache充当反向代理或正向代理，分别将客户端请求转发到后端服务器或代表客户端缓存和处理请求。</p><h5 id="apt-yum"><a href="#apt-yum" class="headerlink" title="apt&#x2F;yum"></a>apt&#x2F;yum</h5><p>用于处理软件包的安装、更新和删除。</p><p>apt update：从存储库更新本地包索引，确保最新的包信息可用。</p><p>apt upgrade：将已安装的软件包升级到最新的可用版本。</p><p>apt install <package>：安装包及其依赖项。</p><p>apt remove <package>：从系统中删除一个包。</p><p>apt search <keyword>：根据关键字搜索包。</p><p>apt show <package>：显示有关包的详细信息。</p><p>yum是由centos发布的</p><p>yum update：将所有已安装的软件包更新到最新版本。</p><p>yum install <package>：安装包及其依赖项。</p><p>yum remove <package>：从系统中删除一个包。</p><p>yum search <keyword>：根据关键字搜索包。</p><p>yum info <package>：显示有关软件包的详细信息。</p><p>apt和yum都依赖于存储库，存储库是托管软件包的在线服务器。这些工具会自动从配置的存储库下载包并管理依赖项以确保顺利安装和更新。</p><h5 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h5><p>地址解析协议，是计算机网络中用于将IP地址映射到本地网络上的物理(MAC)地址的协议。它主要用于IPv4网络，而IPv6网络使用NDP。ARP在OSI模型的数据链路层运行，并且对IP等更高级别的协议是透明的。</p><p>当一个设备想要向同一网络上的另一个设备发送数据时，它会检查其ARP缓存（一个存储最近IP到MAC地址映射的表）。如果在缓存中没有找到所需的映射，设备会向本地网络发送一个ARP请求广播消息，询问“谁有这个IP地址？请告诉我你的MAC地址”，具有相应IP地址的设备随后单播发送回复消息进行响应，提供其MAC地址。</p><p>一旦请求设备收到MAC地址，它就可以使用该信息将数据封装到一个帧中并将其发送给预期的接收者。相关设备将使用新的IP到MAC地址映射更新它们的ARP缓存。</p><p>值得注意的是，ARP容易受到ARP欺骗攻击，攻击者操纵ARP消息将他们自己的 MAC 地址与目标 IP 地址相关联，这可能会导致各种安全问题，例如中间人攻击。为了减轻ARP欺骗，网络管理员可以实施ARP检查、动态ARP 检查(DAI)或安全ARP等技术。</p><h5 id="Bastion-host"><a href="#Bastion-host" class="headerlink" title="Bastion host"></a>Bastion host</h5><p>堡垒主机是放置在网络外围的专用计算机或服务器，用于提供对专用网络中其他系统的安全访问。它充当从外部网络（例如Internet）安全访问的网关和管理内部资源的管理员。</p><p>堡垒主机的主要目的是通过限制对内部系统的直接访问和减少攻击面来增强安全性，不允许直接连接到敏感的内部系统，所有外部连接都通过堡垒主机进行定向。堡垒主机可以被强化和密切监控以检测和防止未经授权的访问。</p><h5 id="brctl"><a href="#brctl" class="headerlink" title="brctl"></a>brctl</h5><p>是一个命令行实用程序，用于在Linux系统上管理和配置以太网桥接设备。 可用于创建、删除、修改和显示有关桥接设备的信息。brctl被认为是一个遗留工具，较新的Linux发行版通常使用ip或bridge命令来管理网桥。</p><h5 id="brctl-addbr-addif"><a href="#brctl-addbr-addif" class="headerlink" title="brctl addbr&#x2F;addif"></a>brctl addbr&#x2F;addif</h5><p>brctl addbr创建新网桥：</p><p>sudo brctl addbr mybridge</p><p>brctl addif将以太网端口添加到网桥：</p><p>sudo brctl addif mybridge eth0</p><p>sudo brctl addif mybridge eth0 eth1 eth2</p><h5 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h5><p>CentOS（社区企业操作系统）是一个基于Red Hat Enterprise Linux (RHEL)源代码的Linux发行版。它旨在提供一个免费的、社区支持的RHEL替代品，为服务器和工作站提供稳定可靠的操作系统。</p><h5 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h5><p>chmod用于改变文件或目录的访问权限。用户用它控制文件或目录的访问权限。该命令有两种用法。一种是文字设定法，另一种是数字设定法。</p><h5 id="circuit-level-gateway"><a href="#circuit-level-gateway" class="headerlink" title="circuit-level gateway"></a>circuit-level gateway</h5><p>是一种在OSI模型的传输层运行的网络安全设备。它通过建立和管理两个网络端点之间的连接来工作，充当网络流量的中介。</p><p>电路级网关的主要功能是通过监视和管理底层TCP连接来提供安全性和对网络连接的控制。电路级网关不像传统的包过滤防火墙那样检查网络包的内容，而是专注于TCP会话的建立、终止和管理。</p><p>电路级网关虽然提供一定程度的安全性，但可能无法提供与现代下一代防火墙或应用程序级网关相同级别的检查和粒度。它们通常与其他安全措施结合使用，以在网络基础设施内提供分层防御策略。</p><h5 id="ClamAV"><a href="#ClamAV" class="headerlink" title="ClamAV"></a>ClamAV</h5><p>是一种开源防病毒软件，主要用于检测和删除恶意软件，包括病毒、特洛伊木马、蠕虫和其他恶意软件。它广泛应用于Linux系统，提供对文件和目录的实时扫描和按需扫描。</p><h5 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h5><p>用于发出HTTP请求并与各种协议（包括HTTP、HTTPS、FTP、SCP、SFTP等）进行交互。</p><p>curl的主要目的是从指定的URL检索数据或将数据发送到指定的URL。</p><p>发送GET请求、发送POST请求、发送json格式请求。</p><h5 id="Data-loss-prevention-DLP"><a href="#Data-loss-prevention-DLP" class="headerlink" title="Data loss prevention(DLP)"></a>Data loss prevention(DLP)</h5><p>数据丢失防护(DLP)是一组策略和技术，旨在防止组织内敏感和机密数据的未经授权或意外丢失、盗窃或暴露。DLP的目标是保护敏感信息不被泄露给未经授权的个人或离开组织的安全环境。DLP解决方案可以作为软件应用程序、硬件设备或两者的组合来实施。</p><p>DLP策略包含数据分类、数据发现和监控、数据丢失预防控制、数据备份和恢复等。</p><h5 id="Deep-packet-inspection"><a href="#Deep-packet-inspection" class="headerlink" title="Deep packet inspection"></a>Deep packet inspection</h5><p>深度数据包检测 (DPI)是一种用于在网络数据包穿越网络时对其内容进行实时检测和分析的技术。它涉及检查网络数据包的整个有效负载，包括标头和数据部分，以详细了解数据包的内容及其相关元数据。</p><p>DPI具有隐私含义，因为它涉及检查网络数据包的内容，DPI的使用应符合法律和法规要求，并且应通过适当的政策和做法谨慎解决隐私问题。</p><p>DPI通常用于网络安全设备，例如防火墙、入侵检测系统(IDS)、入侵防御系统(IPS)和网络监控工具。互联网服务提供商(ISP)和网络管理员也利用它来有效地管理和保护他们的网络。</p><h5 id="demilitarized-zone"><a href="#demilitarized-zone" class="headerlink" title="demilitarized zone"></a>demilitarized zone</h5><p>DMZ，是英文“demilitarized zone”的缩写，中文名称为“隔离区”，也称“非军事化区”。它是为了解决安装防火墙后外部网络的访问用户不能访问内部网络服务器的问题，而设立的一个非安全系统与安全系统之间的缓冲区。该缓冲区位于企业内部网络和外部网络之间的小网络区域内。在这个小网络区域内可以放置一些必须公开的服务器设施，如企业Web服务器、FTP服务器和论坛等。另一方面，通过这样一个DMZ区域，更加有效地保护了内部网络。因为这种网络部署，比起一般的防火墙方案，对来自外网的攻击者来说又多了一道关卡。</p><h5 id="dmesg"><a href="#dmesg" class="headerlink" title="dmesg"></a>dmesg</h5><p>dmesg（display message）命令用于查看和控制内核环形缓冲区。它可以在排查内核或硬件问题时提供很大的帮助。这些消息包含有关硬件检测、设备初始化以及内核可能遇到的任何潜在问题的重要信息。</p><h5 id="docker"><a href="#docker" class="headerlink" title="docker"></a>docker</h5><p>Docker是一个开源平台，允许开发人员使用容器化自动部署、扩展和管理应用程序。容器是轻量级和隔离的环境，用于打包应用程序及其依赖项，从而实现跨不同环境的一致且可移植的执行。通过利用容器化来简化应用程序的开发和部署，增强可扩展性和灵活性。</p><h5 id="EJBCA"><a href="#EJBCA" class="headerlink" title="EJBCA"></a>EJBCA</h5><p>EJBCA代表Enterprise JavaBeans Certificate Authority，是一个开源软件包，它提供了一个强大且可扩展的平台，用于在公钥基础设施(PKI)环境中管理和颁发数字证书。它是用Java编写的，并遵循Java Enterprise Edition(JavaEE)标准。</p><p>EJBCA被包括政府实体、金融机构和企业在内的组织广泛用于建立和管理其内部PKI环境。它的灵活性、可扩展性和全面的功能集使其适用于范围广泛的证书管理场景。</p><h5 id="ESP（Encapsulating-Security-Payload）"><a href="#ESP（Encapsulating-Security-Payload）" class="headerlink" title="ESP（Encapsulating Security Payload）"></a>ESP（Encapsulating Security Payload）</h5><p>ESP(Encapsulating Security Payload)是IPsec(Internet Protocol Security) 中使用的一种协议，用于为IP网络上的数据传输提供机密性、完整性和身份验证。它是IPsec的两个主要组件之一。</p><p>ESP 运行在OSI模型的网络层，主要负责对IP数据包的有效载荷（实际数据）进行加密和认证。它封装了原始IP数据包，添加了新的ESP报头和报尾以保护数据。</p><h5 id="export-ALL-PROXY"><a href="#export-ALL-PROXY" class="headerlink" title="export ALL_PROXY"></a>export ALL_PROXY</h5><p>设置环境变量ALL_PROXY，以在端口的ip上指定一个代理服务器。</p><p>设置此环境变量后，支持代理配置的应用程序将使用指定代理服务器进行网络连接。这对于通过代理服务器重定向网络流量以达到各种目的非常有用，例如绕过网络限制或增强隐私。</p><h5 id="Fake-WiFi"><a href="#Fake-WiFi" class="headerlink" title="Fake WiFi"></a>Fake WiFi</h5><p>A创建一个假的热点，然后等待B来连接，然后去获取B的数据。虽然名称叫做fake-wifi,但本质上这是一个真正的wifi，使用者可以借此上网，但是开放者可以监听到其中的数据包。</p><h5 id="gateway"><a href="#gateway" class="headerlink" title="gateway"></a>gateway</h5><p>在计算机网络中，网关是充当另一个网络入口点的网络节点。它充当不同网络之间的连接或接口，允许它们之间进行通信和数据路由。网关是网络基础设施中的重要组成部分，可以在使用不同协议或具有不同寻址方案的网络之间交换信息。</p><p>以下是网络中常用的几类网关：默认网关、路由器、代理服务器、防火墙、应用程序网关。</p><h5 id="GEOIP"><a href="#GEOIP" class="headerlink" title="GEOIP"></a>GEOIP</h5><p>GEOIP，或Geolocation IP，是指确定IP地址的地理位置的过程。它涉及将IP地址映射到物理位置，例如国家、城市或坐标（纬度和经度）。通过GEOIP获得的信息可用于多种目的，包括有针对性的广告、内容交付、欺诈预防和网站个性化。</p><p>有几种用于GEOIP的方法和数据库，包括：IP到位置数据库、反向DNS查找、互联网服务提供商(ISP)数据。</p><p>在线服务通常使用GEOIP来根据用户的位置定制内容或服务。例如，它可用于显示本地化广告、提供区域特定内容或将用户重定向到网站的适当语言版本。</p><p>需要注意的是，GEOIP并不总是100%准确，精度会因所使用的方法和数据库而异。使用VPN、代理或动态IP地址等因素可能会导致地理定位结果不准确。</p><p>此外，GEOIP数据的使用受隐私法规的约束，应根据适用法律和用户同意进行处理。</p><h5 id="GET-POST-Connect"><a href="#GET-POST-Connect" class="headerlink" title="GET&#x2F;POST&#x2F;Connect"></a>GET&#x2F;POST&#x2F;Connect</h5><p>GET、POST和CONNECT是三种常用的HTTP方法，它们定义了向服务器发出的请求的类型。这些方法决定了服务器应该如何处理请求以及客户端和服务器应该如何交互。以下是每种方法的概述：</p><p>GET：GET方法用于从服务器检索数据。当客户端发送GET请求时，它要求服务器返回特定资源的表示。请求参数（如果有）通常包含在URL查询字符串中。GET请求被认为是安全的，这意味着它们不应该对服务器有任何副作用，并且可以在不改变服务器状态的情况下重复多次。</p><p>POST：POST方法用于将数据提交给服务器进行处理。它通常用于在服务器上创建或更新资源。与GET不同，使用POST请求发送的数据通常包含在请求正文中，而不是URL。POST请求可能导致服务器上的不同状态更改，例如创建新资源或修改现有数据。</p><p>CONNECT：CONNECT方法用于HTTP隧道，通过HTTP代理服务器建立安全连接。</p><h5 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h5><p>用于在您的机器上创建Git存储库的本地副本。它允许您从远程服务器（例如GitHub、GitLab或Bitbucket）下载存储库的整个历史记录和文件，并设置一个可以使用的本地副本。</p><p>git clone URL</p><h5 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h5><p>用于将本地提交上传到远程 Git 存储库。它允许您将本地分支的提交发送到远程存储库上的相应分支，使它们保持同步。</p><p>git push <remote> <branch></p><p>在此命令中，<remote>指的是远程仓库的名称，<branch>指的是你要推送的分支。默认情况下，远程存储库通常命名为“origin”。</p><h5 id="GnuPG"><a href="#GnuPG" class="headerlink" title="GnuPG"></a>GnuPG</h5><p>GnuPG 是一个完整的免费 OpenPGP 标准实现，根据 RFC4880 定义（也称为 PGP）。这个软件可以帮助你加密和签名数据和通信。它具有多用途的密钥管理系统，并提供了各种公钥目录的访问模块。</p><h5 id="Honeypot"><a href="#Honeypot" class="headerlink" title="Honeypot"></a>Honeypot</h5><p>蜜罐是一种网络安全技术，用于捕获和检测计算机网络或系统上的恶意活动或未经授权的访问尝试。它创建一个看起来对攻击者有吸引力的诱饵系统或网络，引诱他们进入并转移他们对实际有价值或敏感信息的注意力。</p><p>蜜罐的主要目的是收集攻击者使用的策略、技术和工具及其动机和意图的信息。通过分析攻击者在蜜罐环境中的活动和行为，网络安全专业人员可以深入了解新出现的威胁、漏洞和攻击模式，这些信息随后可用于增强实际生产系统和网络的安全措施。</p><p>蜜罐可以部署在组织的内部网络中，也可以放置在面向外部的位置，例如互联网，以吸引更广泛的攻击者。它们通常用作其他安全措施的补充。</p><p>部署蜜罐需要仔细规划和考虑，以确保它们不会引入额外的安全风险。应实施适当的隔离、监视和控制措施，以防止攻击者将蜜罐用作攻击真实系统的跳板。</p><h5 id="htop"><a href="#htop" class="headerlink" title="htop"></a>htop</h5><p> htop 是Linux系统中的一个互动的进程查看器，一个文本模式的应用程序(在控制台或者X终端中)。与Linux传统的top相比，htop更加人性化。它可让用户交互式操作，支持颜色主题，可横向或纵向滚动浏览进程列表，并支持鼠标操作。</p><h5 id="http-proxy"><a href="#http-proxy" class="headerlink" title="http_proxy"></a>http_proxy</h5><p>http_proxy是类Unix操作系统（例如 Linux、macOS）中常用的环境变量，用于配置网络通信的HTTP代理设置。此变量指定用于发出HTTP请求的代理服务器。</p><p>但是，请务必注意，并非所有应用程序都默认遵守此环境变量，某些应用程序可能需要额外的配置或特定的代理设置。</p><h5 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h5><p>HTTPS 协议是 HyperText Transfer Protocol Secure（超文本传输安全协议）的缩写，是一种通过计算机网络进行安全通信的传输协议。</p><p>HTTP 本身是不安全的，因为传输的数据未经加密，可能会被窃听或篡改，为了解决这个问题，引入了 HTTPS，即在 HTTP 上加入 SSL&#x2F;TLS 协议，为数据传输提供了加密和身份验证。</p><p>HTTPS 经由 HTTP 进行通信，但利用 SSL&#x2F;TLS 来加密数据包，HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换资料的隐私与完整性。</p><p>HTTP 的 URL 是由 http:&#x2F;&#x2F; 起始与默认使用端口 80，而 HTTPS 的 URL 则是由 https:&#x2F;&#x2F; 起始与默认使用端口443。</p><h5 id="https-proxy"><a href="#https-proxy" class="headerlink" title="https_proxy"></a>https_proxy</h5><p>https_proxy 环境变量类似于 http_proxy，但它专门为 HTTPS（安全 HTTP）连接配置代理设置。 它通常用于类 Unix 操作系统（例如 Linux、macOS），以指定用于发出安全 HTTP 请求的 HTTPS 代理服务器。</p><p>请务必注意，并非所有应用程序都会自动接受https_proxy环境变量。某些应用程序可能需要为HTTPS连接进行显式配置或特定代理设置。</p><h5 id="I2P"><a href="#I2P" class="headerlink" title="I2P"></a>I2P</h5><p>I2P（Invisible Internet Project即“隐形网计划”），是一项混和授权的匿名网络项目。</p><p>I2P网络是按照Tor的洋葱网络改良设计出的相对更具有隐蔽性、安全性的匿名网络。</p><h5 id="ICAP"><a href="#ICAP" class="headerlink" title="ICAP"></a>ICAP</h5><p>ICAP是Internet Content Adaptation Protocol的缩写，它在本质上是在HTTP message上执行RPC远程过程调用的一种轻量级的协议，也就是说，它让ICAP客户端可以把HTTP Message传给ICAP 服务器，然后ICAP服务器可以对其进行某种变换或者其他处理，被变换的message可以是HTTP请求也可以是HTTP应答。<br>ICAP是和HTTP协议在结构和用法上都相似的请求&#x2F;应答式的协议。虽然和HTTP协议类似，但它并不是HTTP，也并不是以HTTP协议为底层协议在其上实现的应用层协议，也就是说，ICAP的message不能够被HTTP代理所处理和转发。</p><h5 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h5><p>ICMP代表Internet Control Message Protocol，它是一种网络协议，是Internet协议套件（通常称为TCP&#x2F;IP）的一部分。ICMP主要用于网络通信中的诊断和控制。</p><p>ICMP允许IP网络中的设备向其他设备发送控制消息以报告错误、提供故障排除信息并交换操作状态更新，在网络故障排除、网络管理和整个Internet连接中起着至关重要的作用。</p><h5 id="IDS"><a href="#IDS" class="headerlink" title="IDS"></a>IDS</h5><p>IDS （Intrusion detection service）代表入侵检测系统。它是一种安全技术，用于检测和响应计算机网络或系统中潜在的安全漏洞或恶意活动。IDS的主要功能是监控网络流量或系统事件，分析它们是否存在可疑或未经授权的行为迹象，并生成警报或采取主动措施来减轻检测到的威胁。</p><p>IDS有两种主要类型：基于网络的IDS(NIDS)、基于主机的IDS(HIDS)</p><p>IDS使用各种检测技术，包括基于签名的检测和基于异常的检测。</p><h5 id="IETF"><a href="#IETF" class="headerlink" title="IETF"></a>IETF</h5><p>IETF代表互联网工程任务组。它是一个开放的国际社区，由网络设计人员、运营商、供应商和研究人员组成，负责开发和标准化Internet上使用的协议和技术。</p><p>其目标是通过开发和维护高质量、可互操作的标准来确保Internet的平稳运行和发展。IETF的工作有助于塑造互联网的发展，确保不同系统之间的兼容性，并促进新技术和应用程序的开发。</p><h5 id="ifconfig-ipconfig"><a href="#ifconfig-ipconfig" class="headerlink" title="ifconfig&#x2F;ipconfig"></a>ifconfig&#x2F;ipconfig</h5><p>用于检索不同操作系统上的网络配置信息。</p><p>ifconfig：主要用于类Unix操作系统，包括Linux、macOS等。它显示或配置系统上的网络接口，可查看IP地址、网络掩码、广播地址、MAC地址等信息。</p><p>ipconfig：命令特定于Windows操作系统，它提供与ifconfig类似的功能。</p><p>都可用于解决网络问题、检查IP配置和验证网络连接。ifconfig在许多现代Linux发行版中已被弃用，这些发行版已过渡到用于网络配置和管理的ip命令。</p><h5 id="IGMP-multicast"><a href="#IGMP-multicast" class="headerlink" title="IGMP(multicast)"></a>IGMP(multicast)</h5><p>IGMP代表互联网组管理协议。它是IP网络上的主机和相邻路由器用来建立多播组成员资格的通信协议。</p><p>多播是一种通信方法，其中单个发送者可以同时向多个接收者传输数据。IGMP使主机能够加入或离开特定的多播组，并通知相邻路由器其多播组成员身份。这允许路由器有效地管理网络内的多播流量。</p><h5 id="Intrusion-detection-service-IDS"><a href="#Intrusion-detection-service-IDS" class="headerlink" title="Intrusion detection service (IDS)"></a>Intrusion detection service (IDS)</h5><p>入侵检测系统 (IDS) 是一种网络安全工具，用于监控网络流量和设备，以发现已知的恶意活动、可疑活动或违反安全策略的行为。</p><p>IDS 可以通过向安全管理员发出已知或潜在威胁的警报，或者向集中式安全工具发送警报，来帮助加速和自动化网络威胁检测。安全信息和事件管理 (SIEM) 系统就是这种安全工具的一个示例，在该系统中，警报可以与其他来源的数据相结合，帮助安全团队识别和应对可能被其他安全措施忽略的网络威胁。</p><h5 id="Intrusion-prevention-service-IPS"><a href="#Intrusion-prevention-service-IPS" class="headerlink" title="Intrusion prevention service(IPS)"></a>Intrusion prevention service(IPS)</h5><p>IPS代表入侵防御系统。它是一种网络安全技术，与防火墙和入侵检测系统(IDS)一起工作，以检测和防止网络中的恶意活动或未经授权的访问尝试。</p><p>IPS的主要功能是实时监控网络流量，分析已知攻击模式或可疑行为的迹象，并立即采取措施防止检测到的威胁到达目标。与专注于检测和警报的IDS不同，IPS会主动干预和阻止恶意流量或采取其他预防措施。</p><h5 id="ip-tunnel"><a href="#ip-tunnel" class="headerlink" title="ip tunnel"></a>ip tunnel</h5><p>IP隧道，也称为IP封装，是一种允许一种网络协议通过另一种网络协议进行传输的技术。它涉及将原始网络数据包封装在封装协议的有效负载中，有效地创建一个隧道，数据包可以通过该隧道穿越原本不支持原始协议的网络。</p><h5 id="ip-forward"><a href="#ip-forward" class="headerlink" title="ip_forward"></a>ip_forward</h5><p>IP转发，也称为数据包转发，是一种网络功能，它允许网络设备（例如路由器或网关）在一个接口上接收传入的IP数据包，然后将其转发到另一个接口上的适当目的地。它支持不同网络之间的IP流量路由，允许数据包穿越多个网段到达其预定目的地。</p><p>当在网络设备上启用IP转发时，它会检查每个传入数据包的目标IP地址，并根据其路由表确定下一跳。</p><p>一旦设备确定了下一跳，它就会将数据包封装在适当的数据链路层协议（例如，以太网、Wi-Fi）中，添加必要的报头，并在选定的接口上将其发送到目的地。</p><p>在大多数操作系统（包括Linux和Windows）上，出于安全原因，默认情况下禁用IP转发，它可以通过修改系统的网络设置或使用特定的命令或配置文件来启用。</p><h5 id="IPSec"><a href="#IPSec" class="headerlink" title="IPSec"></a>IPSec</h5><p>IPSec代表互联网协议安全。它是一组协议和标准，用于通过在网络层提供机密性、完整性和身份验证服务来保护IP通信。</p><p>IPSec主要用于建立虚拟专用网络(VPN)以及通过公共或不受信任的网络（例如Internet）进行的安全通信。它可以在IPv4和IPv6网络中实现。</p><p>IPSec的关键组件包括：AH、ESP。</p><p>IPSec可以以两种主要模式实施：</p><p>传输模式：在传输模式下，IPSec保护IP数据包的有效载荷，同时保持IP报头不变。传输模式通常用于两台主机之间的端到端通信。</p><p>隧道模式：在隧道模式下，IPSec将整个IP数据包封装在一个新的IP数据包中，添加一个额外的IP报头。这允许在两个网络之间创建安全隧道，通常用于站点到站点VPN或远程访问VPN。</p><h5 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h5><p>iptables是一个命令行工具，用于在基于Linux的操作系统中配置和管理netfilter防火墙。它允许系统管理员为数据包过滤、网络地址转换(NAT)和其他网络相关任务定义规则和策略。</p><h5 id="iptables-F"><a href="#iptables-F" class="headerlink" title="iptables -F"></a>iptables -F</h5><p>命令iptables -F用于刷新iptables防火墙配置中的所有规则。当您以root用户身份运行此命令时，它将删除所有现有规则、链和策略，有效地将iptables配置重置为其默认状态。</p><p>-F：该选项代表flush并指示iptables删除所有链中的所有规则。</p><h5 id="iptunnel"><a href="#iptunnel" class="headerlink" title="iptunnel"></a>iptunnel</h5><p>iptunnel命令是Linux中用于配置和管理IP隧道的实用程序。它提供创建和管理各种类型的IP隧道的功能，允许将IP数据包封装在其他IP数据包中。</p><h5 id="ISO-7498"><a href="#ISO-7498" class="headerlink" title="ISO 7498"></a>ISO 7498</h5><p>ISO 7498是ISO&#x2F;OSI模型的一个特定版本。描述了七层OSI模型，它将网络通信划分为不同的层，每一层都有自己的功能和协议。这些层从下到上分别是物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。该标准概述了每一层的目的和职责，并为网络协议的互操作性和标准化提供了指南。</p><h5 id="ISO-7498-2-GB-T-9387-2"><a href="#ISO-7498-2-GB-T-9387-2" class="headerlink" title="ISO 7498-2(GB&#x2F;T 9387.2)"></a>ISO 7498-2(GB&#x2F;T 9387.2)</h5><p>ISO 7498-2（GB&#x2F;T 9387.2）是关于信息处理系统开放系统互连（OSI）安全体系结构的国际标准。</p><p>ISO 7498-2描述了开放系统互联安全的体系结构，提出了设计安全的信息系统的基础架构中应该包含的多种安全服务和安全机制。</p><p>ISO 7498-2及其对应的中国国家标准GB&#x2F;T 9387.2为设计、开发和评估安全的信息系统提供了指导和参考，确保信息在开放系统互连环境中的安全传输和处理。</p><h5 id="ISO-OSI"><a href="#ISO-OSI" class="headerlink" title="ISO&#x2F;OSI"></a>ISO&#x2F;OSI</h5><p>ISO&#x2F;OSI（国际标准化组织&#x2F;开放系统互连）模型，也称为OSI参考模型，是一个标准化计算机网络功能和交互的概念框架。它是由国际标准化组织(ISO)在1980年代开发的。</p><p>ISO&#x2F;OSI是一种网络通信的参考模型，由国际标准化组织（ISO）制定。</p><h5 id="libpcap"><a href="#libpcap" class="headerlink" title="libpcap"></a>libpcap</h5><p>libpcap，即Packet Capture Library（数据包捕获库），是一个在Unix&#x2F;Linux平台下广泛使用的网络数据包捕获函数库。</p><p>它提供了系统独立的用户级别网络数据包捕获接口，并充分考虑到应用程序的可移植性。</p><h5 id="llamafile"><a href="#llamafile" class="headerlink" title="llamafile"></a>llamafile</h5><p>Llamafile是一种可以在用户电脑上运行的可执行大型语言模型（LLM），它包含了给定的开放LLM的权重，以及运行该模型所需的一切。用户无需进行任何安装或配置，即可使用Llamafile来运行LLM，并生成各种内容，如代码、诗歌、故事等。</p><h5 id="lsmod"><a href="#lsmod" class="headerlink" title="lsmod"></a>lsmod</h5><p>Linux中的lsmod命令用于显示当前加载的内核模块。内核模块是一段代码，可以动态加载和卸载到正在运行的内核中，扩展其功能或添加对特定硬件或功能的支持。</p><p>lsmod命令通常用于故障排除、验证加载了哪些模块以及检查模块依赖性或冲突。它还有助于识别哪些模块负责提供Linux内核中的特定功能或驱动程序。</p><h5 id="MAC-address"><a href="#MAC-address" class="headerlink" title="MAC address"></a>MAC address</h5><p>MAC（媒体访问控制）地址，也称为物理地址或硬件地址，是由制造商分配给网络接口卡(NIC)的唯一标识符。它是一个48位（6字节）的地址，通常以十六进制格式表示，通常显示为六对，用冒号或连字符分隔。</p><p>下面是关于MAC地址的几个要点：</p><p>唯一性：每个NIC在制造过程中都分配有一个全球唯一的MAC地址。这可确保网络上没有两个设备具有相同的MAC地址。</p><p>结构：MAC地址由两部分组成：组织唯一标识符(OUI)和设备标识符。OUI代表NIC的制造商或供应商，而Device Identifier用于区分制造商生产的各个设备。</p><h5 id="MASQUERADE"><a href="#MASQUERADE" class="headerlink" title="MASQUERADE"></a>MASQUERADE</h5><p>MASQUERADE是Linux中Netfilter防火墙子系统提供的一个特性。用于将出包的源IP地址改写为防火墙对外接口的IP地址。当与本地网络上的多个设备共享单个公共IP地址时，此功能通常用于网络地址转换(NAT)。</p><h5 id="MDNS"><a href="#MDNS" class="headerlink" title="MDNS"></a>MDNS</h5><p>MDNS代表多播DNS，它是一种无需DNS服务器即可将主机名解析为本地网络上的IP地址的协议。它允许本地网络上的设备使用域名而不是IP地址来发现彼此并相互通信。</p><p>MDNS使用多播通信进行操作，其中DNS查询和响应消息被发送到特定的多播IP地址(224.0.0.251)和指定端口(5353)。这允许设备广播它们的存在并在同一网络中本地解析域名。</p><h5 id="NAS"><a href="#NAS" class="headerlink" title="NAS"></a>NAS</h5><p>NAS，全称Network Attached Storage，即网络附加存储，是一种具有很大存储容量的电脑外敷设备。</p><p>它是一种专用数据存储服务器，以数据为中心，将存储设备与服务器彻底分离，集中管理数据。</p><p>NAS通过网络直接连接磁盘储存阵列，磁阵列具备了高容量、高效能、高可靠等特征。</p><h5 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h5><p>NAT代表网络地址转换。它是计算机网络中用于在不同网络域之间转换IP地址的技术。NAT允许本地网络中的多个设备在连接到Internet时共享一个公共IP地址。</p><p>NAT可能会引入某些限制和复杂性，例如某些依赖直接对等连接的网络应用程序或在其有效负载中嵌入IP地址的协议的问题。随着采用可提供更大地址空间的IPv6，减少了对NAT的需求。但是，NAT在IPv4网络中仍然广泛使用，并且在网络连接和地址管理中起着至关重要的作用。</p><h5 id="netsh-exe"><a href="#netsh-exe" class="headerlink" title="netsh.exe"></a>netsh.exe</h5><p>netsh是Windows操作系统中用于配置和管理各种网络相关设置的命令行工具。它代表“网络外壳”，并提供一个命令行界面，用于与网络组件、接口和配置进行交互。</p><h5 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h5><p>netstat是Windows和类Unix操作系统（例如Linux和macOS）中可用的命令行实用程序，可显示各种与网络相关的信息。它允许您查看活动的网络连接、打开的端口、路由表和其他网络统计信息。</p><h5 id="npcap"><a href="#npcap" class="headerlink" title="npcap"></a>npcap</h5><p>Npcap是一个强大的网络数据包捕获库，它是WinPcap库的改进版本，为开发人员提供了更灵活、可靠的网络数据包捕获功能。</p><h5 id="ntopng"><a href="#ntopng" class="headerlink" title="ntopng"></a>ntopng</h5><p>ntopng是一个强大且全面的网络流量分析和管理系统，由nttop团队开发并维护。</p><h5 id="OpenSearch："><a href="#OpenSearch：" class="headerlink" title="OpenSearch："></a>OpenSearch：</h5><p>OpenSearch是一种用于在Web上构建和使用搜索功能的开放标准。它旨在提供分散和可互操作的搜索体验，允许网站和应用程序提供搜索功能，而无需依赖专有搜索引擎。</p><h5 id="OpenSSL-demoCA"><a href="#OpenSSL-demoCA" class="headerlink" title="OpenSSL&#x2F;demoCA"></a>OpenSSL&#x2F;demoCA</h5><p>OpenSSL&#x2F;demoCA是指由OpenSSL工具包作为用于测试和学习目的的演示证书颁发机构(CA)创建的目录结构和文件集。OpenSSL是一个开源密码库，提供各种密码功能，包括数字证书的生成和管理。</p><p>demoCA目录结构通常位于OpenSSL安装目录中。</p><p>OpenSSL&#x2F;demoCA目录用于演示建立简单CA层次结构和颁发自签名或测试证书的过程。它提供了用于创建和管理证书的基本结构，可用于教育或测试目的。</p><p>重要的是要注意OpenSSL&#x2F;demoCA目录不适用于作为真正CA的生产用途。对于生产环境，建议使用适当的安全措施设置安全且配置正确的CA基础设施。</p><h5 id="OpenVPN："><a href="#OpenVPN：" class="headerlink" title="OpenVPN："></a>OpenVPN：</h5><p>OpenVPN是一种开源虚拟专用网络(VPN)解决方案，允许通过Internet安全地远程访问网络。它提供了一个灵活且可扩展的VPN框架，支持多种认证方式和加密算法。</p><h5 id="packet-filtering"><a href="#packet-filtering" class="headerlink" title="packet filtering"></a>packet filtering</h5><p>数据包过滤是指在单个数据包通过网络设备（例如防火墙或路由器）时对其进行检查，并根据预定义的规则或标准决定是允许还是阻止它们的过程。它是网络安全的重要组成部分，在保护网络免受未经授权的访问和恶意活动方面发挥着至关重要的作用。</p><h5 id="PDP-11"><a href="#PDP-11" class="headerlink" title="PDP-11"></a>PDP-11</h5><p>PDP-11（Programmed Data Processor-11）是数字设备公司（DEC）在1970年代开发的一系列16位小型计算机。它是当时最成功、使用最广泛的计算机体系结构之一，在早期的计算历史中发挥了重要作用。</p><h5 id="PEM-Privacy-Enhanced-Mail"><a href="#PEM-Privacy-Enhanced-Mail" class="headerlink" title="PEM(Privacy Enhanced Mail)"></a>PEM(Privacy Enhanced Mail)</h5><p>这是一种最初为安全电子邮件通信而开发的文件格式。然而，它现在通常用作通用文件格式，用于存储和传输各种类型的加密数据，例如数字证书、私钥和加密算法。</p><h5 id="PPP-PPPoE"><a href="#PPP-PPPoE" class="headerlink" title="PPP&#x2F;PPPoE"></a>PPP&#x2F;PPPoE</h5><p>PPP（点对点协议）和PPPoE（以太网点对点协议）是网络通信中常用的两种协议，用于建立和管理客户端设备与互联网服务提供商(ISP)之间的连接。</p><p>PPP是一种数据链路层协议，用于在两个网络设备（通常是客户端和服务器）之间建立直接的点对点连接。</p><p>它支持各种网络层协议，如IP（互联网协议）、IPv6、IPX（网际包交换），允许传输不同类型的网络流量。</p><p>PPP提供身份验证、错误检测和更高级别协议封装等功能。</p><p>PPPoE是PPP的扩展，可以通过以太网传输PPP帧。</p><p>它通常用于DSL（数字用户线）和电缆调制解调器连接，以在客户的设备和ISP的网络之间建立PPP连接。</p><p>PPPoE使用以太网帧来承载PPP数据包，允许将PPP帧封装在以太网帧中，以便在基于以太网的网络上传输。</p><p>PPP和PPPoE涉及客户端和服务器（通常是ISP的网络）之间建立连接的过程。</p><p>客户端设备通过发送PPPoE发现请求来启动连接，其中包括会话ID（服务名称）和所需的最大传输单元(MTU)大小。</p><p>服务器使用PPPoE发现响应进行响应，如果需要身份验证，则客户端提供凭据。</p><p>一旦建立连接，PPP或PPPoE帧就会在客户端和服务器之间传输，封装更高级别的网络流量。</p><h5 id="PPTP-L2TP"><a href="#PPTP-L2TP" class="headerlink" title="PPTP&#x2F;L2TP"></a>PPTP&#x2F;L2TP</h5><p>PPTP（点对点隧道协议）和L2TP（第2层隧道协议）是在Internet上创建虚拟专用网络(VPN)连接的两种常用协议。这两种协议都用于在远程设备和VPN服务器之间建立安全和私有的通信通道。</p><p>PPTP（点对点隧道协议）：</p><p>PPTP是一种较旧的VPN协议，它在OSI模型的数据链路层运行。</p><p>它由Microsoft开发，并得到大多数操作系统的原生支持，包括Windows、macOS和Linux。</p><p>PPTP结合使用点对点协议(PPP)进行数据封装和通用路由封装(GRE)协议进行隧道传输。</p><p>它使用Microsoft点对点加密(MPPE)提供身份验证和加密，以保护VPN流量。</p><p>L2TP（第2层隧道协议）：</p><p>L2TP是一种更现代的VPN协议，它在OSI模型的数据链路层运行。</p><p>它结合了PPTP和Cisco的第2层转发(L2F)协议的最佳功能。</p><p>L2TP本身不提供加密或身份验证，但通常与IPsec（Internet协议安全）结合使用以实现安全通信。</p><p>L2TP使用UDP（用户数据报协议）建立隧道，并在L2TP隧道内封装PPP帧。</p><h5 id="PPTPD"><a href="#PPTPD" class="headerlink" title="PPTPD"></a>PPTPD</h5><p>PPTPD是一种在Linux上运行的VPN服务器软件，它使用PPP协议来实现远程用户的安全接入。PPTP（Point-to-Point Tunneling Protocol）是VPN客户端，而PPTPD是与之对应的服务器软件。两者共同工作，实现远程用户的安全接入。</p><h5 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h5><p>代理服务器充当客户端设备（例如计算机、智能手机或平板电脑）和互联网之间的中介。它通过将请求从客户端转发到其他服务器并将响应返回给客户端来促进网络通信。</p><h5 id="RDP"><a href="#RDP" class="headerlink" title="RDP"></a>RDP</h5><p>RDP全称Remote Desktop Protocol，是微软开发的专有协议，用于通过网络连接远程访问和控制计算机。RDP允许用户连接到远程计算机并与其桌面环境交互，就好像他们实际存在于该计算机上一样。</p><h5 id="remote-bridge"><a href="#remote-bridge" class="headerlink" title="remote bridge"></a>remote bridge</h5><p>远程网桥是一种将两个独立网络连接在一起的网络设备，允许它们相互通信。它充当两个网络之间的桥梁，在它们之间转发数据包。远程网桥通常用于两个网络位于不同物理位置或长距离连接的情况。</p><h5 id="RFB"><a href="#RFB" class="headerlink" title="RFB"></a>RFB</h5><p>RFB指的是Remote Frame Buffer（远程帧缓冲）协议。RFB协议是一个用于远程访问图形用户界面的简单协议。由于它工作在帧缓冲层，因此它适用于所有的窗口系统和应用程序，如Windows 3.1&#x2F;95&#x2F;NT和Macintosh等。RFB协议允许用户通过网络连接到远程计算机，并实时控制其桌面。用户可以通过鼠标、键盘等设备来控制远程计算机的显示屏图像。</p><h5 id="RFC"><a href="#RFC" class="headerlink" title="RFC"></a>RFC</h5><p>RFC代表征求意见。在计算机网络和互联网标准的上下文中，RFC是描述互联网各个方面的协议、过程或规范的文档。RFC由互联网工程任务组(IETF)开发和发布，用于记录和标准化构成互联网的技术和协议。RFC是动态文档，并且随着技术的发展，会发布新的RFC以更新或替换旧的。它们在塑造互联网基础设施和确保网络技术的互操作性和兼容性方面发挥着至关重要的作用。</p><h5 id="RFC822"><a href="#RFC822" class="headerlink" title="RFC822"></a>RFC822</h5><p>RFC 822，全称是“ARPA Internet Text Messages: Standards or Format of Messages”（ARPA互联网文本消息：消息的标准格式），是1982年颁布的一个标准，用于规定电子邮件的格式。它定义了电子邮件的基本框架，确保电子邮件的正确传递和正确处理。</p><h5 id="rocky-linux"><a href="#rocky-linux" class="headerlink" title="rocky linux"></a>rocky linux</h5><p>Rocky Linux是一个社区驱动的企业级开源操作系统(OS)，旨在为CentOS提供免费且稳定的替代方案。该项目的目标是提供与RHEL的长期支持和兼容性，确保用户可以自信地将他们的CentOS部署过渡到Rocky Linux，而无需在兼容性、可靠性和安全性方面做出重大改变或牺牲。</p><h5 id="route"><a href="#route" class="headerlink" title="route"></a>route</h5><p>路由是指数据包到达其目的地所遵循的路径或网络设备和链接的序列。路由涉及确定数据在网络中从源设备到目标设备的最佳路径。</p><h5 id="RRAS"><a href="#RRAS" class="headerlink" title="RRAS"></a>RRAS</h5><p>RRAS代表路由和远程访问服务。它是一个Microsoft Windows服务器角色，提供路由、虚拟专用网络(VPN)和拨号服务。RRAS使Windows服务器可以充当网络路由器，允许它在不同网络或子网之间路由IP流量。此外，它还提供安全的远程访问功能，允许客户端通过VPN或拨号连接连接到服务器。</p><h5 id="SA-Security-Association"><a href="#SA-Security-Association" class="headerlink" title="SA(Security Association)"></a>SA(Security Association)</h5><p>是IPsec上下文中使用的术语，SA表示两个网络实体之间的逻辑连接或关联，它们已就安全通信的一组安全参数达成一致。SA定义了管理两个实体之间数据安全交换的安全属性和参数。</p><h5 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h5><p>screen命令是类Unix操作系统中功能强大的终端多路复用器。它允许您在单个shell会话中创建和管理多个终端会话。使用屏幕，您可以同时运行多个虚拟终端或“屏幕”，分离并重新连接它们，并运行即使您与服务器断开连接也能继续运行的进程。</p><h5 id="socat"><a href="#socat" class="headerlink" title="socat"></a>socat</h5><p>socat是一个强大的命令行工具，用于在两个端点之间建立双向数据传输。它允许您在两个进程、网络套接字、文件、设备或其他I&#x2F;O流之间创建虚拟连接。socat通常用于网络调试、测试和创建复杂的数据传输场景。</p><h5 id="SOCKS"><a href="#SOCKS" class="headerlink" title="SOCKS"></a>SOCKS</h5><p>SOCKS代表Socket Secure，是一种互联网协议，允许在客户端和服务器之间进行安全和匿名的通信。它充当客户端应用程序和服务器之间的中间协议，为数据传输提供安全通道。</p><h5 id="SOCKS5"><a href="#SOCKS5" class="headerlink" title="SOCKS5"></a>SOCKS5</h5><p>SOCKS5是SOCKS（Socket Secure）协议的第五个版本。它是一种互联网协议，允许客户端与SOCKS代理服务器建立安全且经过身份验证的连接。SOCKS5在其前身的基础上提供了多项增强功能，包括改进的身份验证机制和对各种类型网络流量的支持。</p><h5 id="squid"><a href="#squid" class="headerlink" title="squid"></a>squid</h5><p>Squid是一种流行的开源缓存代理服务器，可提供广泛的特性和功能。它充当客户端和服务器之间的中介，使客户端能够通过从缓存中检索Web内容或将请求转发到适当的服务器来访问Web内容。</p><h5 id="ssh-D-L-R"><a href="#ssh-D-L-R" class="headerlink" title="ssh-D&#x2F;-L&#x2F;-R"></a>ssh-D&#x2F;-L&#x2F;-R</h5><p>选项-D、-L和-R在SSH（安全外壳）命令行实用程序中用于创建各种类型的端口转发隧道。端口转发允许您通过SSH服务器在本地和远程系统之间建立安全连接。</p><p>-D：此选项设置动态端口转发，也称为SOCKS代理。</p><p>-L：-L选项建立本地端口转发。</p><p>-R：-R选项设置远程端口转发。</p><h5 id="SSH-OpenSSH"><a href="#SSH-OpenSSH" class="headerlink" title="SSH&#x2F;OpenSSH"></a>SSH&#x2F;OpenSSH</h5><p>SSH（Secure Shell）是一种加密网络协议，用于在远程系统上进行安全的远程登录和命令执行。它在不安全的网络上提供安全和加密的通信通道，允许用户安全地连接到远程服务器并与之交互。</p><p>OpenSSH是使用最广泛的SSH协议实现。它是由OpenBSD项目开发的开源工具套件，可用于各种操作系统，包括Linux、Unix和Windows。</p><h5 id="ssl-bump"><a href="#ssl-bump" class="headerlink" title="ssl_bump"></a>ssl_bump</h5><p>ssl_bump是Squid缓存代理服务器的一项功能，它允许拦截和检查SSL&#x2F;TLS流量。它使Squid代理充当客户端和服务器之间的中间人(MITM)，允许代理解密和检查加密的流量。</p><p>当squid中启用ssl_bump时，代理服务器拦截SSL&#x2F;TLS连接并即时生成新的SSL&#x2F;TLS证书以替换原始服务器证书。此新证书由客户端信任的本地证书颁发机构(CA)签名。客户端然后与Squid代理建立安全连接，认为它直接连接到预期的服务器。</p><p>通过拦截SSL&#x2F;TLS连接，squid可以解密加密的流量并检查内容。此检查允许在重新加密并将其转发到预期服务器之前，将内容过滤、访问控制、缓存和日志记录等各种操作应用于解密的流量。来自服务器的响应同样被拦截、解密、检查，然后在被发送回客户端之前重新加密。</p><h5 id="stateful-inspection"><a href="#stateful-inspection" class="headerlink" title="stateful inspection"></a>stateful inspection</h5><p>状态检查是一种防火墙技术，用于根据网络连接的上下文和状态监视和控制网络流量。通过考虑整个通信会话及其相关状态，它超越了传统的数据包过滤。状态检查通过提供更好的可见性和对网络连接的控制来增强网络安全。通过了解连接状态和分析数据包流，状态检测防火墙可以就允许或拒绝流量做出更明智的决定。</p><h5 id="stunnel"><a href="#stunnel" class="headerlink" title="stunnel"></a>stunnel</h5><p>Stunnel是一款自由的跨平台软件，主要用于提供全局的TLS&#x2F;SSL服务。</p><p>Stunnel针对那些本身无法进行TLS或SSL通信的客户端及服务器，提供安全的加密连接。该软件可以运行在许多操作系统上，包括Unix-like系统以及Windows。它基于OpenSSL或SSLeay等独立的库来实现TLS或SSL协议，确保数据传输的安全性。</p><h5 id="tap-tap-adapter"><a href="#tap-tap-adapter" class="headerlink" title="tap(tap adapter)"></a>tap(tap adapter)</h5><p>TAP（网络TAP）适配器是一个虚拟网络接口，允许在数据链路层捕获和分析网络流量。它在比传统网络适配器更低的级别上运行，从而能够监控和拦截网络数据包。</p><h5 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP&#x2F;IP"></a>TCP&#x2F;IP</h5><p>TCP&#x2F;IP（传输控制协议&#x2F;互联网协议）是一套通信协议，它定义了跨网络传输数据的标准方法和规则。它是互联网的基础，广泛用于局域网(LAN)和广域网(WAN)中，以实现设备之间的通信。</p><p>以下是TCP&#x2F;IP的关键组件：</p><p>IP（互联网协议）：IP负责跨网络寻址和路由数据包。它为连接到网络的设备分配唯一的IP地址，并确保根据这些地址将数据包从源正确地传递到目的地。</p><p>TCP（传输控制协议）：TCP在设备之间提供可靠的、面向连接的通信。它将数据分成称为数据包的更小单元，对它们进行编号，并确保它们按顺序无误地传送。TCP使用端口号来建立和管理设备之间的连接，以识别特定的服务或应用程序。</p><p>UDP（用户数据报协议）：UDP是一种无连接的轻量级协议，可提供不可靠的、尽力而为的通信。它不像TCP那样建立连接，而是独立发送数据包（数据报）。UDP通常用于实时应用程序，例如视频流和IP语音(VoIP)，其中速度优先于可靠性。</p><p>ICMP（互联网控制消息协议）：ICMP用于IP网络中的诊断和错误报告目的。它允许设备发送和接收控制消息以指示网络状态、解决问题和交换错误信息。</p><p>IP寻址：TCP&#x2F;IP使用IP地址，IP地址是分配给网络设备的数字标识符。IPv4（Internet协议版本4）是使用最广泛的寻址方案，由以点十进制格式编写的32位地址组成（例如192.168.0.1）。IPv6（Internet协议版本6）是较新的寻址方案，它使用以十六进制格式编写的128位地址（例如，2001:0db8:85a3:0000:0000:8a2e:0370:7334）。</p><p>协议和服务：TCP&#x2F;IP包括在网络上启用特定功能的各种协议和服务，例如用于网页浏览的HTTP（超文本传输协议）、用于文件传输的FTP（文件传输协议）、用于网络的SMTP（简单邮件传输协议）电子邮件传输，以及用于将域名解析为IP地址的DNS（域名系统）。</p><h5 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h5><p>tcpdump是一个命令行数据包分析工具，用于实时捕获和分析网络流量。它可用于各种类Unix操作系统，包括Linux、macOS和BSD。</p><h5 id="telnet"><a href="#telnet" class="headerlink" title="telnet"></a>telnet</h5><p>Telnet是一种网络协议和应用程序，允许用户通过网络与远程服务器或设备建立远程终端会话。它提供了一个命令行界面来与远程系统进行交互，就像您身临其境一样。</p><h5 id="tor"><a href="#tor" class="headerlink" title="tor"></a>tor</h5><p>Tor是“The Onion Router”的缩写，是一个免费的开源软件项目，可在Internet上提供匿名和隐私保护。它通过一系列加密中继路由他们的互联网流量，帮助用户保护他们的在线身份和通信。</p><h5 id="tun-tunnel-adapter"><a href="#tun-tunnel-adapter" class="headerlink" title="tun(tunnel adapter)"></a>tun(tunnel adapter)</h5><p>TUN（网络隧道）适配器是一个虚拟网络接口，可以创建虚拟点对点网络隧道。它在网络层（第3层）运行，并允许在不同网络端点或设备之间封装和传输网络数据包。</p><h5 id="tunnel"><a href="#tunnel" class="headerlink" title="tunnel"></a>tunnel</h5><p>隧道是指一种机制，它允许将一种网络协议封装在另一种协议中，从而实现跨不同网络或网段的网络流量传输。隧道提供了一种在网络端点之间创建虚拟连接或路径的方法，允许以安全和受控的方式传输数据包。</p><h5 id="UPnP"><a href="#UPnP" class="headerlink" title="UPnP"></a>UPnP</h5><p>UPnP代表通用即插即用。它是一组网络协议，允许设备在本地网络上发现、连接和相互通信，而无需手动配置或用户干预。UPnP通过提供自动网络配置和服务发现功能简化了设置和管理联网设备的过程。</p><h5 id="UTM（统一威胁管理United-Threat-Management）"><a href="#UTM（统一威胁管理United-Threat-Management）" class="headerlink" title="UTM（统一威胁管理United Threat Management）"></a>UTM（统一威胁管理United Threat Management）</h5><p>UTM代表统一威胁管理。它是指将多种安全特性和功能组合到单个平台或设备中的综合安全解决方案。UTM解决方案旨在针对广泛的网络安全威胁提供保护，包括病毒、恶意软件、入侵、垃圾邮件和其他恶意活动。</p><h5 id="vmnet0-1-8"><a href="#vmnet0-1-8" class="headerlink" title="vmnet0&#x2F;1&#x2F;8"></a>vmnet0&#x2F;1&#x2F;8</h5><p>vmnet0、vmnet1和vmnet8是VMware软件（特别是VMware Workstation和VMware Fusion）使用的虚拟网络接口，用于促进虚拟机与主机系统之间的网络通信。</p><h5 id="VNC"><a href="#VNC" class="headerlink" title="VNC"></a>VNC</h5><p>VNC代表虚拟网络计算。它是一种远程桌面协议，允许用户通过网络连接查看和控制远程计算机的图形桌面。VNC支持远程访问和控制计算机，就像您坐在计算机前一样，提供了一种管理系统或提供远程支持的方法。</p><h5 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h5><p>VPN代表虚拟专用网络。它是一种通过公共网络（例如互联网）提供安全和加密连接的技术，允许用户访问和传输数据，就像他们直接连接到专用网络一样。VPN通常用于增强隐私、安全性和远程可访问性。</p><h5 id="VPS"><a href="#VPS" class="headerlink" title="VPS"></a>VPS</h5><p>VPS代表虚拟专用服务器。它是由托管提供商提供的模拟专用物理服务器的虚拟化服务器环境。使用VPS，用户可以访问专用资源，并可以配置和管理他们的服务器，就好像它是一台独立的机器一样。</p><h5 id="vtun-vtund"><a href="#vtun-vtund" class="headerlink" title="vtun&#x2F;vtund"></a>vtun&#x2F;vtund</h5><p>VTun和VTund是两个开源软件包，它们通过IP网络提供虚拟专用网络(VPN)解决方案。它们允许在多个网络位置之间创建安全隧道，从而实现通过公共网络的安全通信和数据传输。</p><h5 id="WAPI"><a href="#WAPI" class="headerlink" title="WAPI"></a>WAPI</h5><p>WAPI 的全称为 Wireless LAN Authentication and Privacy Infrastructure，翻译成中文就是无线局域网鉴别和保密基础结构。WAPI 既是安全协议，也是中国无线局域网安全强制性标准。</p><h5 id="WEP"><a href="#WEP" class="headerlink" title="WEP"></a>WEP</h5><p>WEP是Wired Equivalent Privacy的简称，有线等效保密（WEP）协议是对在两台设备间无线传输的数据进行加密的方式，用以防止非法用户窃听或侵入无线网络。</p><h5 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h5><p>wget是一个命令行实用程序，用于使用HTTP、HTTPS和FTP协议从Web服务器检索文件。它通常在类Unix操作系统（包括Linux）以及Windows上通过使用第三方端口或包提供。</p><h5 id="whoosh"><a href="#whoosh" class="headerlink" title="whoosh"></a>whoosh</h5><p>Whoosh是一个快速、功能丰富的纯Python搜索引擎库。它提供了一个易于使用的界面，用于在Python应用程序中索引和搜索基于文本的数据。Whoosh被设计为轻量级、高效和可定制的，使其成为在各种Python项目中实现搜索功能的流行选择。</p><h5 id="WiFi"><a href="#WiFi" class="headerlink" title="WiFi"></a>WiFi</h5><p>WiFi是一种允许电子设备连接到一个无线局域网（WLAN）的技术，通常使用2.4G或5G射频频段。WiFi这个名字是无线以太网相容联盟（Wireless Ethernet Compatibility Alliance, WECA）所创造的，用来代替IEEE 802.11标准的无线网络技术。</p><h5 id="Wireguard："><a href="#Wireguard：" class="headerlink" title="Wireguard："></a>Wireguard：</h5><p>WireGuard是一种开源虚拟专用网络(VPN)协议和软件应用程序，可提供安全高效的网络通信。它旨在为IPsec和OpenVPN等传统VPN协议提供更简单、更高效的替代方案。</p><h5 id="WPA"><a href="#WPA" class="headerlink" title="WPA"></a>WPA</h5><p>WPA（Wi-Fi Protected Access）</p><ul><li>WPA是Wi-Fi保护访问的缩写，它是为了应对前一代系统有线等效加密（WEP）中的严重弱点而诞生的。</li><li>WPA实现了IEEE 802.11i标准的大部分，作为在802.11i完备之前替代WEP的过渡方案。</li><li>WPA的设计可以用在所有的无线网卡上，但未必能用在第一代的无线取用点上。</li><li>WPA的数据加密使用了128位的密钥和一个48位的初向量（IV）的RC4 stream cipher。</li><li>WPA的主要改进包括动态改变密钥的“临时密钥完整性协议”（Temporal Key Integrity Protocol，TKIP），加上更长的初向量，以及名为“Michael”的更安全的消息认证码。</li></ul><h5 id="WPA2"><a href="#WPA2" class="headerlink" title="WPA2"></a>WPA2</h5><p>WPA2（Wi-Fi Protected Access II）</p><ul><li>WPA2是WPA的升级版，是基于WPA的一种新的加密方式。</li><li>WPA2是Wi-Fi联盟对采用IEEE 802.11i安全增强功能的产品的认证计划。</li><li>WPA2在WPA的基础上引入了更高级别的安全性和加密算法，如AES（高级加密标准）和CCMP（计数模式密码块连接消息认证码协议）。</li><li>WPA2需要采用AES的芯片组来支持，并且有两种风格：WPA2个人版和WPA2企业版。</li><li>WPA2已经成为许多企业和新的住宅Wi-Fi产品的标准，截至2006年3月，它已成为一种强制性的标准。</li></ul><h5 id="WPA3"><a href="#WPA3" class="headerlink" title="WPA3"></a>WPA3</h5><p>WPA3（Wi-Fi Protected Access 3）</p><ul><li>WPA3是Wi-Fi联盟在2018年发布的Wi-Fi新加密协议，是WPA2技术的后续版本。</li><li>WPA3的主要改进特点包括：<ul><li>对使用弱密码的人采取“强有力的保护”，通过锁定攻击行为和屏蔽WiFi身份验证过程来防止暴力攻击。</li><li>简化显示接口受限设备的安全配置流程，通过个性化数据加密增强用户隐私的安全性。</li><li>将密码算法提升至192位的CNSA等级算法，增加字典法暴力密码破解的难度。</li><li>提供Easy Connect技术，允许用户通过扫描QR码等方式将新的物联网设备连接至Wi-Fi。</li></ul></li></ul><h5 id="XDMCP"><a href="#XDMCP" class="headerlink" title="XDMCP"></a>XDMCP</h5><p>XDMCP（X显示管理器控制协议）是X窗口系统使用的一种网络协议，用于在类Unix系统上启用远程图形登录会话。它允许用户连接到远程X服务器（显示器）并与远程系统的图形用户界面(GUI)交互。</p><h5 id="x-server-x-terninal"><a href="#x-server-x-terninal" class="headerlink" title="x-server&#x2F;x-terninal"></a>x-server&#x2F;x-terninal</h5><p>X-Server，全称为X Window System的显示服务器（display server），是X Window System（简称X11或X）系统中的一个核心组件。</p><p>功能：它负责监听X客户端（X client）发送来的图形界面显示请求，并将这些请求转化为图形界面，然后绘制并显示在屏幕上。</p><p>通信方式：X客户端与X服务器之间的通信方式主要有三种：TCP、Unix socket和通过内存通信。后两种方式通常用于X客户端和X服务器位于同一台机器的情况，因为它们提供了更高的通信效率。</p><p>关系：一台电脑上可以运行多个X服务器，一个X服务器可以管理多个逻辑屏幕（screen），而一个逻辑屏幕可以对应单个或多个物理显示器。</p><p>重要性：在Linux系统中，X服务器是图形界面的基础，它独立于Linux核心，通过X协议与窗口管理器进行交互，为各种应用程序提供图形界面支持。</p><p>X-Terminal通常指的是Xterm或类似的终端模拟器软件，它是X Window System中的一个应用程序，用于提供命令行界面。</p><p>功能：X-Terminal允许用户通过图形界面启动和使用命令行工具，从而方便地进行系统管理、文件操作等任务。</p><p>特性：X-Terminal通常具有可定制性强、支持多标签页、支持SSH连接等特性，使得用户能够更加高效地使用命令行界面。</p><p>应用：除了Xterm之外，还有许多其他类似的X-Terminal软件可供选择，如GNOME Terminal、Konsole等。这些软件通常作为Linux桌面环境的一部分提供，也可以单独安装和使用。</p><h5 id="x-window"><a href="#x-window" class="headerlink" title="x-window"></a>x-window</h5><p>X-Window，也被称为X Window System或简称X11、X，是一种在UNIX、类UNIX以及OpenVMS等操作系统上广泛使用的图形用户界面（GUI）系统。</p><p>X-Window系统主要由X服务器（X Server）、X客户端（X Client）和通讯通道（Communication Channel）三部分组成。</p><ul><li>X服务器是管理显示器和输入设备（如键盘、鼠标）的软件，它接收X客户端的请求，并在屏幕上绘制图形。</li><li>X客户端是产生图形输出的应用程序，如文本编辑器、浏览器等。它们通过X协议与X服务器进行通信。</li><li>通讯通道可以是本地连接（如Unix socket）或网络连接（如TCP&#x2F;IP），这使得X-Window系统具有网络透明性，即X客户端和X服务器可以位于不同的机器上。</li></ul><h5 id="z数据安全法"><a href="#z数据安全法" class="headerlink" title="z数据安全法"></a>z数据安全法</h5><p>数据安全法，全称为《中华人民共和国数据安全法》，是由中华人民共和国第十三届全国人民代表大会常务委员会第二十九次会议于2021年6月10日通过的。该法自2021年9月1日起施行，是数据领域的基础性法律，也是国家安全领域的一部重要法律。</p><ol><li>主要目的：制定数据安全法的主要目的是为了规范数据处理活动，保障数据安全，促进数据开发利用，保护个人、组织的合法权益，以及维护国家主权、安全和发展利益。</li><li>适用范围：本法适用于在中华人民共和国境内开展数据处理活动及其安全监管。同时，对于在中华人民共和国境外开展数据处理活动，损害中华人民共和国国家安全、公共利益或者公民、组织合法权益的行为，也将依法追究法律责任。</li><li>数据定义：本法所称数据，是指任何以电子或者其他方式对信息的记录。数据处理则包括数据的收集、存储、使用、加工、传输、提供、公开等。</li><li>治理原则：维护数据安全应当坚持总体国家安全观，建立健全数据安全治理体系，提高数据安全保障能力。</li></ol><h5 id="z网络安全法"><a href="#z网络安全法" class="headerlink" title="z网络安全法"></a>z网络安全法</h5><p>网络安全法，全称为《中华人民共和国网络安全法》，是由全国人民代表大会常务委员会于2016年11月7日发布的，自2017年6月1日起施行。</p><ol><li>主要目的：制定网络安全法的主要目的是为了保障网络安全，维护网络空间主权和国家安全、社会公共利益，保护公民、法人和其他组织的合法权益，促进经济社会信息化健康发展。</li><li>重要性：网络安全法对中国网络空间法治化建设具有重要意义，它明确了网络空间主权的原则，规定了网络运行安全、网络信息安全、网络数据安全等方面的基本要求，并规定了网络安全监督管理体制。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 大学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目实训个人周报6</title>
      <link href="/2024/06/03/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%AE%AD%E4%B8%AA%E4%BA%BA%E5%91%A8%E6%8A%A56/"/>
      <url>/2024/06/03/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%AE%AD%E4%B8%AA%E4%BA%BA%E5%91%A8%E6%8A%A56/</url>
      
        <content type="html"><![CDATA[<h2 id="去除过短或者过长训练数据"><a href="#去除过短或者过长训练数据" class="headerlink" title="去除过短或者过长训练数据"></a>去除过短或者过长训练数据</h2><p>在机器学习中，去除过短或过长的训练数据通常是为了提高模型的性能和稳定性。以下是具体的原因：</p><ol><li>质量控制</li></ol><p>过短的文本：</p><ul><li>可能包含太少的信息，无法提供足够的上下文。</li><li>可能是噪音或无用的内容，如单个字符或单词。</li></ul><p>过长的文本：</p><ul><li>可能包含冗余信息或噪音。</li><li>处理起来资源消耗较大，增加计算开销。</li></ul><ol start="2"><li>计算效率</li></ol><p>过长的文本：</p><ul><li>需要更多的计算资源和时间。</li><li>可能导致内存不足或训练时间过长。</li></ul><ol start="3"><li>模型训练稳定性</li></ol><p>过短的文本：</p><ul><li>可能导致模型过拟合，无法泛化到更长或更复杂的句子。</li><li>模型可能学不到有用的特征。</li></ul><p>过长的文本：</p><ul><li>可能导致模型在训练时遇到梯度消失或爆炸的问题。</li><li>增加模型的复杂性，可能需要更复杂的架构来处理。</li></ul><ol start="4"><li>数据均衡性</li></ol><p>去除过短或过长的文本有助于确保训练数据的长度分布更加均衡，避免模型对特定长度的文本过度拟合。</p><ol start="5"><li>一致性和可解释性</li></ol><p>保持数据长度在一个合理的范围内，可以提高模型预测结果的一致性和可解释性。</p><p>下面是我去除过短或者过长训练数据的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取CSV文件</span></span><br><span class="line">data = pd.read_csv(<span class="string">&#x27;data.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 过滤数据，保留满足条件的行</span></span><br><span class="line">filtered_data = data[(data[<span class="string">&#x27;question&#x27;</span>].<span class="built_in">str</span>.<span class="built_in">len</span>() &gt;= <span class="number">5</span>) &amp; (data[<span class="string">&#x27;question&#x27;</span>].<span class="built_in">str</span>.<span class="built_in">len</span>() &lt;= <span class="number">50</span>) &amp;</span><br><span class="line">                     (data[<span class="string">&#x27;answer&#x27;</span>].<span class="built_in">str</span>.<span class="built_in">len</span>() &gt;= <span class="number">50</span>) &amp; (data[<span class="string">&#x27;answer&#x27;</span>].<span class="built_in">str</span>.<span class="built_in">len</span>() &lt;= <span class="number">512</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存过滤后的数据到新的CSV文件</span></span><br><span class="line">filtered_data.to_csv(<span class="string">&#x27;filtered_data.csv&#x27;</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><ol><li>读取CSV文件：使用<code>pd.read_csv()</code>函数读取名为<code>data.csv</code>的文件</li><li>过滤数据<ul><li>使用Pandas的字符串方法<code>.str.len()</code>来计算每一行中<code>question</code>和<code>answer</code>列的长度。</li><li>使用布尔索引过滤出满足所有条件的行：<ul><li>问题列的长度至少为5个字符且不超过50个字符。</li><li>答案列的长度至少为50个字符且不超过512个字符。</li></ul></li></ul></li><li>保存过滤后的数据：使用<code>to_csv()</code>方法将过滤后的数据保存到一个名为<code>filtered_data.csv</code>的新文件中。设置<code>index=False</code>参数来避免写入行索引到文件。</li></ol><h3 id="删除相似的问题或者相似的答案"><a href="#删除相似的问题或者相似的答案" class="headerlink" title="删除相似的问题或者相似的答案"></a>删除相似的问题或者相似的答案</h3><p>在大模型训练中，删除相似的问题或相似的答案有以下几个主要原因：</p><ol><li>减少数据冗余</li></ol><p>相似的问题和答案:</p><ul><li>会导致数据集中存在大量重复信息。</li><li>增加数据量但不提供新的有价值的信息。</li></ul><p>通过删除相似的样本，可以减少数据冗余，使模型更专注于学习多样化和有代表性的信息。</p><ol start="2"><li>提高训练效率</li></ol><p>减少冗余数据:</p><ul><li>可以显著减少训练时间和计算资源的消耗。</li><li>使模型训练更高效，因为训练时不需要反复处理相似的信息。</li></ul><ol start="3"><li>防止过拟合</li></ol><p>相似的问题和答案:</p><ul><li>可能导致模型对某些特定模式过拟合。</li><li>模型可能会记住这些重复的样本，而不是学会如何处理更多样化的数据。</li></ul><p>删除相似的样本有助于提高模型的泛化能力，使其在面对新数据时表现更好。</p><ol start="4"><li>增强模型的多样性学习</li></ol><p>多样化数据:</p><ul><li>使模型能够学习到更广泛的模式和特征。</li><li>提高模型在不同情境下的表现能力。</li></ul><p>删除相似的样本可以确保模型接触到更多样化的训练数据，从而提高模型的鲁棒性和应对不同情况的能力。</p><ol start="5"><li>改善数据集质量</li></ol><p>清理数据集:</p><ul><li>可以去除那些重复或者几乎相同的问答对，提升数据集的整体质量。</li><li>有助于确保数据集中的每个样本都提供有价值的训练信息。</li></ul><p>高质量的数据集有助于模型更有效地学习和推理。</p><p>下面是我的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> difflib <span class="keyword">import</span> SequenceMatcher</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">similar</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> SequenceMatcher(<span class="literal">None</span>, a, b).ratio()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取CSV文件</span></span><br><span class="line">data = pd.read_csv(<span class="string">&#x27;data.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化要删除的索引列表</span></span><br><span class="line">indices_to_drop = <span class="built_in">set</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查问题列的相似度</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(data) - <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, <span class="built_in">len</span>(data)):</span><br><span class="line">        <span class="comment"># 比较问题列</span></span><br><span class="line">        <span class="keyword">if</span> similar(data.loc[i, <span class="string">&#x27;question&#x27;</span>], data.loc[j, <span class="string">&#x27;question&#x27;</span>]) &gt; <span class="number">0.8</span>:</span><br><span class="line">            indices_to_drop.add(j)  <span class="comment"># 添加问题二的索引到删除列表</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 比较答案列</span></span><br><span class="line">        <span class="keyword">if</span> similar(data.loc[i, <span class="string">&#x27;answer&#x27;</span>], data.loc[j, <span class="string">&#x27;answer&#x27;</span>]) &gt; <span class="number">0.8</span>:</span><br><span class="line">            indices_to_drop.add(j)  <span class="comment"># 添加答案二的索引到删除列表</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除相似度高的行</span></span><br><span class="line">data = data.drop(indices_to_drop)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保存过滤后的数据到新的CSV文件</span></span><br><span class="line">data.to_csv(<span class="string">&#x27;filtered_data.csv&#x27;</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><ol><li><p>相似度计算函数</p><ul><li>使用<code>SequenceMatcher</code>函数比较两个字符串的相似度。这个函数返回一个介于0和1之间的数值，表示两个字符串的相似度百分比。</li></ul></li><li><p>读取CSV文件</p><ul><li>使用<code>pd.read_csv()</code>读取CSV文件。</li></ul></li><li><p>初始化索引列表</p><ul><li>使用一个集合<code>indices_to_drop</code>来存储需要删除的行索引。使用集合可以避免重复添加同一索引。</li></ul></li><li><p>双重循环比较每行</p><ul><li>用双重循环遍历数据框，比较每一对问题和答案。</li></ul></li></ol><ul><li>如果发现问题或答案的相似度超过80%，将较后的行索引添加到<code>indices_to_drop</code>集合中。</li></ul><ol start="5"><li><p>删除指定行</p><ul><li>使用<code>DataFrame.drop</code>方法删除所有标记为删除的行。</li></ul></li><li><p>保存结果</p><ul><li>使用<code>to_csv()</code>方法将处理后的数据保存到新的CSV文件<code>filtered_data.csv</code>中，<code>index=False</code>参数确保不保存行索引。</li></ul></li></ol><p>这段代码将根据问题和答案的相似度过滤出唯一的行，是处理大量文本数据</p>]]></content>
      
      
      <categories>
          
          <category> 大学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目实训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目实训个人周报5</title>
      <link href="/2024/05/26/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%AE%AD%E4%B8%AA%E4%BA%BA%E5%91%A8%E6%8A%A55/"/>
      <url>/2024/05/26/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%AE%AD%E4%B8%AA%E4%BA%BA%E5%91%A8%E6%8A%A55/</url>
      
        <content type="html"><![CDATA[<p>数据采集后的文本并不全是中文的，这很正常。我下一步对这部分文本数据进行了翻译，实现方法是通过DeepL这个工具api用python代码实现。不过要订阅申请DeepL的api密钥。</p><p>翻译数据结构知识数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> deepl</span><br><span class="line"></span><br><span class="line"><span class="comment"># DeepL API认证密钥</span></span><br><span class="line">auth_key = <span class="string">&quot;&quot;</span></span><br><span class="line">translator = deepl.Translator(auth_key)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取XLSX文件</span></span><br><span class="line">data = pd.read_csv(<span class="string">&#x27;ds.xlsx&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个标志位，用于指示是否停止翻译</span></span><br><span class="line">stop_translation = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 翻译文本的函数，从英文翻译成中文</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">translate_to_chinese</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="keyword">global</span> stop_translation</span><br><span class="line">    <span class="keyword">if</span> stop_translation:</span><br><span class="line">        <span class="keyword">return</span> text  <span class="comment"># 如果已经出现异常，直接返回原文</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        translation = translator.translate_text(text, target_lang=<span class="string">&quot;ZH&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> translation.text</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;翻译文本时出错: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        stop_translation = <span class="literal">True</span>  <span class="comment"># 发生异常，设置标志位，停止后续翻译</span></span><br><span class="line">        <span class="keyword">return</span> text</span><br><span class="line"></span><br><span class="line"><span class="comment"># 翻译 &#x27;question&#x27; 列</span></span><br><span class="line">data[<span class="string">&#x27;question&#x27;</span>] = data[<span class="string">&#x27;question&#x27;</span>].apply(translate_to_chinese)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 翻译 &#x27;answer&#x27; 列</span></span><br><span class="line">data[<span class="string">&#x27;answer&#x27;</span>] = data[<span class="string">&#x27;answer&#x27;</span>].apply(translate_to_chinese)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示翻译后的数据的前几行</span></span><br><span class="line"><span class="built_in">print</span>(data.head())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将翻译后的数据保存到一个CSV文件</span></span><br><span class="line">data.to_csv(<span class="string">&#x27;translated_ds.csv&#x27;</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>下面给出代码解释：</p><ol><li>导入库<ul><li><code>import pandas as pd</code>：导入Pandas库，常用于数据处理和分析。</li><li><code>import deepl</code>：导入DeepL库，用于实现文本的机器翻译。</li></ul></li><li>设置DeepL API密钥<ul><li><code>auth_key = &quot;DeepL API密钥&quot;</code>：这里需要替换为DeepL API密钥，用于身份认证和访问翻译服务。</li></ul></li><li>创建DeepL翻译器实例<ul><li><code>translator = deepl.Translator(auth_key)</code>：使用提供的API密钥创建一个DeepL翻译器实例。</li></ul></li><li>加载数据<ul><li><code>data = pd.read_csv(&#39;train.parquet&#39;)</code>：使用Pandas的read_csv函数加载csv格式的文件。</li></ul></li><li>定义翻译函数<ul><li><code>translate_to_chinese(text)</code>：这是一个函数，输入参数是文本（英文），输出是翻译后的文本（中文）。</li><li><code>global stop_translation</code>：使用<code>global</code>关键字声明<code>stop_translation</code>，这允许函数内部修改全局变量。</li><li><code>if stop_translation</code>：如果<code>stop_translation</code>为真（表示已经发生翻译错误），则函数直接返回原文本，不进行翻译。</li><li><code>try-except</code>块：尝试使用DeepL翻译器翻译文本，如果发生异常（如网络问题、API限制等），则捕获异常，打印错误信息，并设置<code>stop_translation</code>为真，之后的所有翻译调用将直接返回原文。</li></ul></li><li>应用翻译函数到数据列<ul><li><code>data[&#39;question&#39;] = data[&#39;question&#39;].apply(translate_to_chinese)</code>：将<code>translate_to_chinese</code>函数应用于数据框<code>data</code>中名为<code>question</code>的列。这将逐行将英文指令翻译成中文。</li></ul></li><li>显示翻译后的数据<ul><li><code>print(data.head())</code>：打印翻译后的数据框的前几行，用于检查翻译结果。</li></ul></li><li>保存翻译后的数据<ul><li><code>data.to_csv(&#39;translated_train.csv&#39;, index=False)</code>：将翻译后的数据保存到一个名为<code>translated_train.csv</code>的CSV文件，<code>index=False</code>参数表示不保存行索引。</li></ul></li></ol><p>翻译java知识数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> deepl</span><br><span class="line"></span><br><span class="line"><span class="comment"># DeepL API认证密钥</span></span><br><span class="line">auth_key = <span class="string">&quot;cAjDPhRVq1V2y80O&quot;</span></span><br><span class="line">translator = deepl.Translator(auth_key)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取CSV文件</span></span><br><span class="line">data = pd.read_csv(<span class="string">&#x27;java.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个标志位，用于指示是否停止翻译</span></span><br><span class="line">stop_translation = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 翻译文本的函数，从英文翻译成中文</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">translate_to_chinese</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="keyword">global</span> stop_translation</span><br><span class="line">    <span class="keyword">if</span> stop_translation:</span><br><span class="line">        <span class="keyword">return</span> text  <span class="comment"># 如果已经出现异常，直接返回原文</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        translation = translator.translate_text(text, target_lang=<span class="string">&quot;ZH&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> translation.text</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;翻译文本时出错: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        stop_translation = <span class="literal">True</span>  <span class="comment"># 发生异常，设置标志位，停止后续翻译</span></span><br><span class="line">        <span class="keyword">return</span> text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 翻译 &#x27;question&#x27; 列</span></span><br><span class="line">data[<span class="string">&#x27;question&#x27;</span>] = data[<span class="string">&#x27;question&#x27;</span>].apply(translate_to_chinese)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 翻译 &#x27;answer&#x27; 列</span></span><br><span class="line">data[<span class="string">&#x27;answer&#x27;</span>] = data[<span class="string">&#x27;answer&#x27;</span>].apply(translate_to_chinese)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示翻译后的数据的前几行</span></span><br><span class="line"><span class="comment"># print(data.head())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将翻译后的数据保存到一个CSV文件</span></span><br><span class="line">data.to_csv(<span class="string">&#x27;translated_java.csv&#x27;</span>, index=<span class="literal">False</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>翻译操作系统知识数据：（这里源文件是parquet类型）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> deepl</span><br><span class="line"></span><br><span class="line">auth_key = <span class="string">&quot;cAjDPhRVq1V2y80O&quot;</span></span><br><span class="line">translator = deepl.Translator(auth_key)</span><br><span class="line"></span><br><span class="line">data = pd.read_parquet(<span class="string">&#x27;os.parquet&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个标志位，用于指示是否停止翻译</span></span><br><span class="line">stop_translation = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 翻译文本的函数，从英文翻译成中文</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">translate_to_chinese</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="keyword">global</span> stop_translation</span><br><span class="line">    <span class="keyword">if</span> stop_translation:</span><br><span class="line">        <span class="keyword">return</span> text  <span class="comment"># 如果已经出现异常，直接返回原文</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        translation = translator.translate_text(text, target_lang=<span class="string">&quot;ZH&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> translation.text</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;翻译文本时出错: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        stop_translation = <span class="literal">True</span>  <span class="comment"># 发生异常，设置标志位，停止后续翻译</span></span><br><span class="line">        <span class="keyword">return</span> text</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 翻译 &#x27;question&#x27; 列</span></span><br><span class="line">data[<span class="string">&#x27;question&#x27;</span>] = data[<span class="string">&#x27;question&#x27;</span>].apply(translate_to_chinese)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 翻译 &#x27;answer&#x27; 列</span></span><br><span class="line">data[<span class="string">&#x27;answer&#x27;</span>] = data[<span class="string">&#x27;answer&#x27;</span>].apply(translate_to_chinese)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示翻译后的数据的前几行</span></span><br><span class="line"><span class="comment"># print(data.head())</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将翻译后的数据保存到一个CSV文件</span></span><br><span class="line">data.to_csv(<span class="string">&#x27;translated_os.csv&#x27;</span>, index=<span class="literal">False</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>翻译计网知识数据：(这里源文件是俄语版，方法略有改动)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> deepl</span><br><span class="line"></span><br><span class="line"><span class="comment"># DeepL API认证密钥</span></span><br><span class="line">auth_key = <span class="string">&quot;cAjDPhRVq1V2y80O&quot;</span></span><br><span class="line">translator = deepl.Translator(auth_key)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取CSV文件</span></span><br><span class="line">data = pd.read_csv(<span class="string">&#x27;os.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个标志位，用于指示是否停止翻译</span></span><br><span class="line">stop_translation = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 翻译文本的函数，从俄语翻译成中文</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">translate_to_chinese</span>(<span class="params">text</span>):</span><br><span class="line">    <span class="keyword">global</span> stop_translation</span><br><span class="line">    <span class="keyword">if</span> stop_translation:</span><br><span class="line">        <span class="keyword">return</span> text  <span class="comment"># 如果已经出现异常，直接返回原文</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        translation = translator.translate_text(text, source_lang=<span class="string">&quot;RU&quot;</span>, target_lang=<span class="string">&quot;ZH&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> translation.text</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;翻译文本时出错: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line">        stop_translation = <span class="literal">True</span>  <span class="comment"># 发生异常，设置标志位，停止后续翻译</span></span><br><span class="line">        <span class="keyword">return</span> text</span><br><span class="line"></span><br><span class="line"><span class="comment"># 翻译 &#x27;question&#x27; 列</span></span><br><span class="line">data[<span class="string">&#x27;question&#x27;</span>] = data[<span class="string">&#x27;question&#x27;</span>].apply(translate_to_chinese)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 翻译 &#x27;answer&#x27; 列</span></span><br><span class="line">data[<span class="string">&#x27;answer&#x27;</span>] = data[<span class="string">&#x27;answer&#x27;</span>].apply(translate_to_chinese)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示翻译后的数据的前几行</span></span><br><span class="line"><span class="built_in">print</span>(data.head())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将翻译后的数据保存到一个CSV文件</span></span><br><span class="line">data.to_csv(<span class="string">&#x27;translated_os.csv&#x27;</span>, index=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 大学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目实训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目实训个人周报4</title>
      <link href="/2024/05/19/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%AE%AD%E4%B8%AA%E4%BA%BA%E5%91%A8%E6%8A%A54/"/>
      <url>/2024/05/19/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%AE%AD%E4%B8%AA%E4%BA%BA%E5%91%A8%E6%8A%A54/</url>
      
        <content type="html"><![CDATA[<p>前面从广义数据的角度对数据集进行了处理，但是没有考虑到大模型的角度。在和负责大模型部分的同学沟通后，进一步对数据进行了处理，使其更贴合大规模预训练模型。通过一番查找对比，我在这里选择了llm_corpus_quality这个项目。</p><p>llm_corpus_quality集成了包含清洗、敏感词过滤、广告词过滤、语料质量自动评估等功能在内的多个数据处理工具与算法，为中文AI大模型提供安全可信的主流数据。项目采用java实现，完整项目见<a href="https://github.com/jiangnanboy/llm_corpus_quality">https://github.com/jiangnanboy/llm_corpus_quality</a></p><p>llm_corpus_quality支持以下特性：</p><ul><li>规则清洗</li><li>敏感词过滤</li><li>广告过滤</li><li>去重</li><li>质量评估</li></ul><p>处理流程如下</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/29/66570ac0de3ea.png" alt="821577-20240113201957948-1480717496.png"></p><p>大模型训练语料清洗流程，共包括4个阶段5个模块：</p><ol><li>语料清洗规则过滤：通常经过格式转换后的json文件仍存在很多问题，不能直接用于构建训练数据集。通常会以句子或篇章作为过滤单位，通过检测句子或篇章内是否含有大量的怪异符号、是否存在html网页标签等来判断文本是否为合格文本。</li><li>敏感词过滤器：利用自动机，过滤色情、赌博、部分低质量广告等内容的文本。</li><li>广告过滤：利用textcnn模型，过滤涉嫌广告内容。(见<a href="https://github.com/jiangnanboy/ad_detect_textcnn">https://github.com/jiangnanboy/ad_detect_textcnn</a>)</li><li>去重：利用simhash对相似文本片段进行去重。</li><li>质量评估：采用ngram语言模型评估的方法，对语料进行概率预估，文本质量越高的语句，困惑度ppl越低，设定一个ppl阈值，高于这个阈值为低质量语料，可过滤。</li></ol><p>下面是作者给出的示例代码，我稍加改动，对预处理的数据集进行了适配大模型的清洗，得到了最终数据集。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// <span class="built_in">hash</span> data of corpus to deduplication (read <span class="keyword">and</span> save)</span><br><span class="line">     var hashFile = PropertiesReader.get(<span class="string">&quot;dedeplication_hash_path&quot;</span>);</span><br><span class="line"></span><br><span class="line">     //<span class="number">1.</span>rule</span><br><span class="line">     var ruleQuality = new RuleQuality();</span><br><span class="line"></span><br><span class="line">     //<span class="number">2.</span>sensitivity <span class="keyword">and</span> advertising detection</span><br><span class="line">     var simpleSenDetectionProcessor = SimpleSenDetectionProcessor.newInstance();</span><br><span class="line">     var senDetection = simpleSenDetectionProcessor.getKWSeeker(<span class="string">&quot;sensitive_words_path&quot;</span>);</span><br><span class="line"></span><br><span class="line">     var ad_detect_model_path = PropertiesReader.get(<span class="string">&quot;ad_detect_model_path&quot;</span>);</span><br><span class="line">     var ad_dict_path = PropertiesReader.get(<span class="string">&quot;ad_dict_path&quot;</span>);</span><br><span class="line">     var stop_words_path = PropertiesReader.get(<span class="string">&quot;stop_words_path&quot;</span>);</span><br><span class="line">     var adDetection = new AdDetection(ad_detect_model_path, ad_dict_path, stop_words_path);</span><br><span class="line"></span><br><span class="line">     //<span class="number">3.</span>text deduplication</span><br><span class="line">     var deDuplication = new DeDuplication(<span class="number">4</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">     //<span class="number">4.</span>quality evaluation</span><br><span class="line">     var ngramModelPath = PropertiesReader.get(<span class="string">&quot;language_model_path&quot;</span>);</span><br><span class="line">     var qualityEvaluation = new QualityEvaluation(ngramModelPath);</span><br><span class="line"></span><br><span class="line">     // load <span class="built_in">hash</span></span><br><span class="line">     <span class="keyword">if</span>(Files.exists(Paths.get(hashFile))) &#123;</span><br><span class="line">         deDuplication.loadHash(hashFile);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     var corpusQuality = new CorpusQuality(ruleQuality, senDetection, adDetection, deDuplication, qualityEvaluation, <span class="number">100</span>);</span><br><span class="line">     var corpus = <span class="string">&quot;对未按土地、环保和投资管理等法律法规履行相关手续或手续不符合规定的违规项目，地方政府要按照要求进行全面清理。一，凡是未开工的违规项目，一律不得开工建设；二，凡是不符合产业政策、准入标准、环保要求的违规项目一律停建。&quot;</span>;</span><br><span class="line">     var result = corpusQuality.quality(corpus);</span><br><span class="line">     System.out.println(result);</span><br><span class="line"></span><br><span class="line">     // save <span class="built_in">hash</span></span><br><span class="line">     deDuplication.saveHash(hashFile);</span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/29/66570bac4e6a7.png" alt="Snipaste_2024-05-29_19-04-51.png"></p><p>不过在这里，我对清洗前后的数据进行观察，发现并没有明显变化，因为原本的数据集已经是在上传者处理过后上传至平台上的。</p>]]></content>
      
      
      <categories>
          
          <category> 大学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目实训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目实训个人周报3</title>
      <link href="/2024/05/06/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%AE%AD%E4%B8%AA%E4%BA%BA%E5%91%A8%E6%8A%A53/"/>
      <url>/2024/05/06/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%AE%AD%E4%B8%AA%E4%BA%BA%E5%91%A8%E6%8A%A53/</url>
      
        <content type="html"><![CDATA[<p>在大模型训练中，数据集划分、数据增强和数据可视化是至关重要的步骤，确保模型训练的有效性、可靠性和可解释性。下面是对这三个方面的具体实现方法的详细说明。</p><p> <strong>数据集划分：合理划分训练、验证和测试集</strong></p><ol><li><p>比例划分：</p><p>常用的划分比例是70%用于训练，15%用于验证，15%用于测试。具体比例可以根据数据集的规模和任务的需求进行调整。</p></li><li><p>随机划分：</p><p>使用随机数生成器确保数据集划分的随机性，避免样本顺序导致的偏差。</p></li><li><p>分层抽样：</p><p>在分类任务中，确保各类样本在训练、验证和测试集中的比例一致，可以使用分层抽样。</p></li><li><p>时间序列数据划分：</p><p>在时间序列数据中，按照时间顺序划分数据，确保训练集早于验证集，验证集早于测试集。</p></li></ol><p>这里我使用随机划分，使用<code>sklearn.model_selection.train_test_split</code>函数实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line">train_data, test_data = train_test_split(data, test_size=<span class="number">0.3</span>, random_state=<span class="number">42</span>)</span><br><span class="line">train_data, val_data = train_test_split(train_data, test_size=<span class="number">0.2</span>, random_state=<span class="number">42</span>)</span><br></pre></td></tr></table></figure><p><strong>数据增强：同义词替换、回译、随机删除</strong></p><p>1.同义词替换</p><p>随机选择句子中的词，替换为其同义词。</p><p>这里我使用NLTK实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> nltk.corpus <span class="keyword">import</span> wordnet</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">synonym_replacement</span>(<span class="params">text</span>):</span><br><span class="line">    words = text.split()</span><br><span class="line">    new_words = words.copy()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(words)):</span><br><span class="line">        synonyms = wordnet.synsets(words[i])</span><br><span class="line">        <span class="keyword">if</span> synonyms:</span><br><span class="line">            new_words[i] = synonyms[<span class="number">0</span>].lemmas()[<span class="number">0</span>].name()</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join(new_words)</span><br></pre></td></tr></table></figure><p>2.回译：</p><p>将文本翻译成另一种语言，再翻译回来，以生成新的文本。</p><p>我这里使用谷歌的翻译API（Google Translate API）实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> googletrans <span class="keyword">import</span> Translator</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">back_translation</span>(<span class="params">text, src=<span class="string">&#x27;en&#x27;</span>, dest=<span class="string">&#x27;de&#x27;</span></span>):</span><br><span class="line">    translator = Translator()</span><br><span class="line">    translated = translator.translate(text, src=src, dest=dest).text</span><br><span class="line">    back_translated = translator.translate(translated, src=dest, dest=src).text</span><br><span class="line">    <span class="keyword">return</span> back_translated</span><br></pre></td></tr></table></figure><p>3.随机删除：</p><p>随机删除句子中的一些词，生成新的变体。</p><p>实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">random_deletion</span>(<span class="params">text, p=<span class="number">0.1</span></span>):</span><br><span class="line">    words = text.split()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(words) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> text</span><br><span class="line">    new_words = [word <span class="keyword">for</span> word <span class="keyword">in</span> words <span class="keyword">if</span> random.uniform(<span class="number">0</span>, <span class="number">1</span>) &gt; p]</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>.join(new_words)</span><br></pre></td></tr></table></figure><p><strong>数据可视化：文本数据可视化</strong></p><p>词频统计：使用词云（Word Cloud）展示高频词。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> wordcloud <span class="keyword">import</span> WordCloud</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_wordcloud</span>(<span class="params">text</span>):</span><br><span class="line">    wordcloud = WordCloud(width=<span class="number">800</span>, height=<span class="number">400</span>).generate(text)</span><br><span class="line">    plt.figure(figsize=(<span class="number">10</span>, <span class="number">5</span>))</span><br><span class="line">    plt.imshow(wordcloud, interpolation=<span class="string">&#x27;bilinear&#x27;</span>)</span><br><span class="line">    plt.axis(<span class="string">&#x27;off&#x27;</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 大学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目实训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目实训个人周报2</title>
      <link href="/2024/04/23/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%AE%AD%E4%B8%AA%E4%BA%BA%E5%91%A8%E6%8A%A52/"/>
      <url>/2024/04/23/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%AE%AD%E4%B8%AA%E4%BA%BA%E5%91%A8%E6%8A%A52/</url>
      
        <content type="html"><![CDATA[<p>在大模型训练中，数据分析是确保模型性能和训练效率的关键步骤。通过对训练数据进行全面的分析，可以发现潜在的问题和优化空间，提高模型的整体效果。以下是数据分析过程中需要重点关注的方面及其要点：</p><ol><li><strong>数据质量</strong></li></ol><ul><li><strong>准确性</strong>：检查数据是否有错误、错别字或不正确的标签。错误的数据会误导模型学习，降低其准确性。</li><li><strong>完整性</strong>：确保数据集的完整性，避免缺失值或不完整的样本。缺失数据可能导致训练偏差。</li></ul><ol start="2"><li><strong>数据分布</strong></li></ol><ul><li><strong>类别分布</strong>：分析分类任务中的类别分布，确保数据集中的类别分布均衡。如果类别不均衡，模型可能会偏向多数类别。</li><li><strong>特征分布</strong>：对于回归或其他任务，检查特征的分布情况，确保没有异常值或过度偏斜的分布。</li></ul><ol start="3"><li><strong>数据多样性</strong></li></ol><ul><li><strong>文本多样性</strong>：在NLP任务中，检查文本的多样性，包括词汇、句法结构和主题。多样性高的数据集有助于提高模型的泛化能力。</li><li><strong>样本多样性</strong>：确保数据集中包含足够多样的样本，以覆盖不同的场景和情况。</li></ul><ol start="4"><li><strong>文本长度</strong></li></ol><ul><li><strong>长度分布</strong>：分析文本长度的分布情况，确定合适的最大长度和最小长度。这有助于设定模型输入的最大序列长度，优化资源使用。</li><li><strong>截断和填充</strong>：研究需要截断和填充的样本比例，确保截断和填充策略不会显著影响数据质量。</li></ul><ol start="5"><li><strong>数据预处理</strong></li></ol><ul><li><strong>清洗和标准化</strong>：对数据进行必要的清洗和标准化处理，如去除噪声、统一格式和处理特殊字符。</li><li><strong>去重</strong>：检查并去除重复的样本，避免模型在重复数据上过度拟合。</li></ul><p>观察发现，QA数据集中有空格、“答：”、乱码等不需要的字样，于是进行处理。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/29/665707514d0e2.png" alt="Snipaste_2024-05-29_18-46-10.png"></p><p>通过上述模版代码，去除了数据集中”答：”的字样，然后如法炮制，将空格和乱码都进行了去除和清洗。清理完后的部分数据如下图。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/29/665707eaa2fa9.png" alt="Snipaste_2024-05-29_18-48-34.png"></p><p>可以观察到，数据的结构比较清晰，q列是问题，a列是答案，并且数据中的空格、乱码等已经被去除。</p><p>下面我进行了数据分析,主要是分析了文本长度。<strong>文本长度</strong>在大模型训练中很重要，主要有以下几点。</p><ul><li><p><strong>丰富的上下文</strong>：较长的文本通常包含更多的信息和上下文，有助于模型理解复杂的语义关系和捕捉长距离依赖。</p></li><li><p><strong>过长文本的挑战</strong>：处理过长的文本可能导致模型过拟合或者捕捉到过多无关信息，反而可能降低模型性能。需要找到一个平衡点，既包含足够的信息，又不过多冗余。</p></li><li><p><strong>最大长度设定</strong>：在训练过程中，通常会设定一个最大文本长度，超过该长度的文本会被截断。这种策略需要权衡信息完整性和计算资源。</p></li><li><p><strong>任务特定需求</strong>：不同任务对文本长度的需求不同。例如，句子分类任务可能不需要很长的文本，而文档摘要生成则需要处理更长的文本。</p></li><li><p><strong>微调阶段</strong>：在微调阶段，根据具体任务调整文本长度，可以优化模型性能和资源利用效率。</p></li></ul><p>分析文本长度的代码如下。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/29/665708b2dfe85.png" alt="Snipaste_2024-05-29_18-52-10.png"></p>]]></content>
      
      
      <categories>
          
          <category> 大学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目实训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目实训个人周报1</title>
      <link href="/2024/04/14/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%AE%AD%E4%B8%AA%E4%BA%BA%E5%91%A8%E6%8A%A51/"/>
      <url>/2024/04/14/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E8%AE%AD%E4%B8%AA%E4%BA%BA%E5%91%A8%E6%8A%A51/</url>
      
        <content type="html"><![CDATA[<p>我们组的项目是基于大模型的知识问答教育系统，我在前期的任务是数据采集和处理清洗，以便于构建数据集训练大模型。</p><p>基于调查研究，我对于数据收集的关键点做出了以下归纳。</p><ul><li><p><strong>准确性</strong>：确保数据来源可靠，内容准确无误。错误的信息会导致模型输出错误答案，影响用户体验和教育效果。</p></li><li><p><strong>更新性</strong>：确保数据是最新的，特别是对于动态变化的领域，如科技、法律等。</p></li><li><p><strong>教育层次</strong>：覆盖从基础教育到高等教育的内容，适应不同学习阶段的用户需求。</p></li><li><p><strong>结构化数据</strong>：优先选择结构化数据（如数据库、表格），便于处理和分析。</p></li><li><p><strong>隐私保护</strong>：确保用户数据的匿名化处理，避免泄露个人信息。</p></li><li><p><strong>合规性</strong>：遵守数据保护法律法规，如GDPR等，确保数据收集和使用过程中的合法合规性。</p></li></ul><p>在开始的时候，我准备从百度百科、csdn等知识网站上收集数据，但是我发现这些网站上的数据质量良莠不齐，有的甚至有常识性错误，难以在爬取的时候进行分辨；并且这些数据的格式不一致，在后期处理的时候会造成麻烦，于是放弃。</p><p>然后我找到了Hugging Face 的 Datasets 库，这个库提供了大量预构建的数据集，涵盖了广泛的任务和领域，包括文本分类、情感分析、机器翻译、问答、对话系统等。这些数据集经过整理和优化，便于用户直接使用。这个库还可以通过简单的 API 调用轻松下载和加载数据集，无需手动下载和处理数据文件，比较方便。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/29/6657005b61ff9.png" alt="Hugging Face 的 Datasets 库.png"></p><p>于是我决定在这里进行数据的收集。因为我们的项目是问答系统，所以我筛选了可能用得到的QA数据集。以下是我认为能用到的数据集，供给大模型训练。</p><p>医疗：<a href="https://huggingface.co/datasets/lavita/medical-qa-datasets?row=15">https://huggingface.co/datasets/lavita/medical-qa-datasets?row=15</a></p><p>​<a href="https://huggingface.co/datasets/blinoff/medical_qa_ru_data?row=7">https://huggingface.co/datasets/blinoff/medical_qa_ru_data?row=7</a></p><p>​<a href="https://huggingface.co/datasets/medalpaca/medical_meadow_medqa">https://huggingface.co/datasets/medalpaca/medical_meadow_medqa</a></p><p>中医：<a href="https://huggingface.co/datasets/FreedomIntelligence/huatuo_knowledge_graph_qa">https://huggingface.co/datasets/FreedomIntelligence/huatuo_knowledge_graph_qa</a></p><p>​<a href="https://huggingface.co/datasets/FreedomIntelligence/huatuo_encyclopedia_qa/viewer/default/train?p=3624&row=362400">https://huggingface.co/datasets/FreedomIntelligence/huatuo_encyclopedia_qa/viewer/default/train?p=3624&amp;row=362400</a></p><p>中文综合：<a href="https://huggingface.co/datasets/m-a-p/COIG-CQIA">https://huggingface.co/datasets/m-a-p/COIG-CQIA</a></p><p>博客节目：<a href="https://huggingface.co/datasets/wavpub/JinJinLeDao_QA_Dataset">https://huggingface.co/datasets/wavpub/JinJinLeDao_QA_Dataset</a></p><p>哲学：<a href="https://huggingface.co/datasets/sayhan/strix-philosophy-qa/viewer/default/train?p=1337&row=133777">https://huggingface.co/datasets/sayhan/strix-philosophy-qa/viewer/default/train?p=1337&amp;row=133777</a></p><p>心理健康：<a href="https://huggingface.co/datasets/Amod/mental_health_counseling_conversations?row=7">https://huggingface.co/datasets/Amod/mental_health_counseling_conversations?row=7</a></p><p>小学数学：<a href="https://huggingface.co/datasets/microsoft/orca-math-word-problems-200k">https://huggingface.co/datasets/microsoft/orca-math-word-problems-200k</a></p><p><strong>计算机相关</strong></p><p>数学：<a href="https://huggingface.co/datasets/math-ai/StackMathQA">https://huggingface.co/datasets/math-ai/StackMathQA</a></p><p>python编程：<a href="https://huggingface.co/datasets/lucasmccabe-lmi/codex_math_qa_alpaca_style/viewer/default/train?p=280&row=28004">https://huggingface.co/datasets/lucasmccabe-lmi/codex_math_qa_alpaca_style/viewer/default/train?p=280&amp;row=28004</a></p><p>​<a href="https://huggingface.co/datasets/flytech/python-codes-25k">https://huggingface.co/datasets/flytech/python-codes-25k</a></p><p>sql编程：<a href="https://huggingface.co/datasets/b-mc2/sql-create-context">https://huggingface.co/datasets/b-mc2/sql-create-context</a></p><p>代码指令：<a href="https://huggingface.co/datasets/m-a-p/CodeFeedback-Filtered-Instruction?row=38">https://huggingface.co/datasets/m-a-p/CodeFeedback-Filtered-Instruction?row=38</a></p><p>​   <a href="https://huggingface.co/datasets/m-a-p/Code-Feedback/viewer/default/train?p=663&row=66310">https://huggingface.co/datasets/m-a-p/Code-Feedback/viewer/default/train?p=663&amp;row=66310</a></p><p>论文NLP：<a href="https://huggingface.co/datasets/allenai/qasper?row=0">https://huggingface.co/datasets/allenai/qasper?row=0</a></p><p>stackExchange：<a href="https://huggingface.co/datasets/lvwerra/stack-exchange-paired?row=16">https://huggingface.co/datasets/lvwerra/stack-exchange-paired?row=16</a></p><p>综合包括computer science：<a href="https://huggingface.co/datasets/MMMU/MMMU/viewer/Computer_Science/test?row=2">https://huggingface.co/datasets/MMMU/MMMU/viewer/Computer_Science/test?row=2</a></p><p>​   <a href="https://huggingface.co/datasets/cais/mmlu/viewer/college_computer_science?row=29">https://huggingface.co/datasets/cais/mmlu/viewer/college_computer_science?row=29</a></p><p>​   <a href="https://huggingface.co/datasets/ikala/tmmluplus/viewer/computer_science/test">https://huggingface.co/datasets/ikala/tmmluplus/viewer/computer_science/test</a></p><p>然后我在kaggle网站上找到了一个与我们项目适配程度较大的数据集，是关于计算机理论知识的问答集：</p><p><a href="https://www.kaggle.com/datasets/mujtabamatin/computer-science-theory-qa-dataset">https://www.kaggle.com/datasets/mujtabamatin/computer-science-theory-qa-dataset</a></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/29/66570410f2522.png" alt="kaggle数据集.png"></p><p>结合做大模型相关工作的同学的反馈，我选取了上述中的几个数据集，整理成了csv文件，以便于后续的数据清洗等工作。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/05/29/665704bf105aa.png" alt="csv文件.png"></p>]]></content>
      
      
      <categories>
          
          <category> 大学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目实训 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络安全课堂作业 IPTABLES试用</title>
      <link href="/2024/03/17/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E8%AF%BE%E5%A0%82%E4%BD%9C%E4%B8%9A1%20IPTABLES%E8%AF%95%E7%94%A8/"/>
      <url>/2024/03/17/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E8%AF%BE%E5%A0%82%E4%BD%9C%E4%B8%9A1%20IPTABLES%E8%AF%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>记录我大三下学期网络安全课程的作业及实验</p></blockquote><h2 id="作业要求"><a href="#作业要求" class="headerlink" title="作业要求"></a>作业要求</h2><p>作业目的</p><ul><li>试用iptables命令的基本参数和配置功能，为其他实验项目准备；</li><li>练习git提交作业的方法</li></ul><h3 id="任务内容"><a href="#任务内容" class="headerlink" title="任务内容"></a>任务内容</h3><p>在自己的笔记本机器上，</p><ol start="0"><li>使用vmware建立linux虚拟机实验环境，</li><li>先执行“iptables -F”清除可能已有的规则，</li><li>然后自己设计实验步骤和操作命令，通过检查“五元组”实现防火墙的基本功能，包括但不限于：<ul><li>关闭或开放某个服务（端口）</li><li>关闭或开放某个主机（ip）</li><li>关闭或开放某个协议</li><li>其他配置功能</li></ul></li></ol><p>进阶功能：可选</p><ul><li>部署和测试NAT功能</li><li>试用Nftables&#x2F;nft</li></ul><h3 id="git提交"><a href="#git提交" class="headerlink" title="git提交"></a>git提交</h3><p>撰写md格式或doc格式（不是docx格式）完成报告，提交到git。</p><h3 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h3><p>下次课（3.20）之前，git自动记录提交时间。</p><p>报告另起文档，格式可以采用技术博客风格，或者学院实验报告模板。</p><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><h3 id="储备知识"><a href="#储备知识" class="headerlink" title="储备知识"></a>储备知识</h3><blockquote><p>在进行实验前，我先对iptables的知识进行了回顾和查阅拓展，对于其概念和用法有了更清晰的认识。</p></blockquote><ol><li><p><strong>什么是 iptables？</strong><br>iptables 是一个用于配置 Linux 内核中 IPv4 数据包过滤器和网络地址转换 (NAT) 的工具。它允许系统管理员根据特定的规则集控制进出系统的网络流量。iptables 提供了一种灵活而强大的方式来保护网络安全、实现网络地址转换、限制流量等。</p></li><li><p><strong>iptables 的工作原理</strong><br> iptables 是基于 Linux 内核的 Netfilter 框架实现的。当数据包进入或离开系统时，Netfilter 框架会将数据包传递给 iptables 进行处理。iptables 通过检查数据包的源地址、目标地址、协议类型、端口号等信息，并根据预定义的规则集来决定如何处理该数据包。</p></li><li><p><strong>iptables 的基本概念</strong><br>  在使用 iptables 时，有几个基本概念需要了解。</p><p>  链 (Chain)：链是规则的集合，用于确定数据包在系统中的处理路径。iptables 包含几个预定义的链，如 INPUT、OUTPUT 和 FORWARD。每个链都有特定的处理方式和    默认策略。<br>  表 (Table)：表定义了特定类型的规则集。iptables 提供了四个表：filter、nat、mangle 和 raw。每个表用于不同的目的，如过滤数据包、网络地址转换等。<br>  规则 (Rule)：规则是定义在链中的指令，用于决定数据包的处理方式。规则由匹配条件和动作组成。当数据包满足匹配条件时，将执行相应的动作。</p></li><li><p><strong>iptables 的安装和配置</strong><br>  要使用 iptables，需要先安装它并配置相应的规则。在大多数 Linux 发行版中，iptables 已经预装并包含在默认安装中。可以使用包管理器来安装 iptables。安装完成后，可以编辑 iptables 配置文件来定义规则。</p></li><li><p><strong>常见的 iptables 命令</strong><br> iptables 提供了一组命令行工具，用于管理和操作规则。以下是一些常见的 iptables 命令：</p></li></ol><p>  <strong>iptables 的基本语法</strong></p><p>  iptables [选项] &lt;链名&gt; &lt;规则&gt;</p><p>  其中，选项用于指定不同的操作和参数，链名用于确定规则所属的链，规则定义了匹配条件和动作。</p><p>  <strong>添加规则</strong></p><p>  要添加一条规则，可以使用 -A 选项，后跟链名和规则。例如，要向 INPUT 链添加一条允许 ICMP 数据包通过的规则，可以执行以下命令：</p><p>  iptables -A INPUT -p icmp -j ACCEPT</p><p>  此命令将在 INPUT 链末尾添加一条规则，如果数据包的协议类型是 ICMP，则将其接受。</p><p>  <strong>删除规则</strong></p><p>  要删除一条规则，可以使用 -D 选项，后跟链名和规则。例如，要删除 INPUT 链中的第一条规则，可以执行以下命令：</p><p>  iptables -D INPUT </p><p>  此命令将从 INPUT 链中删除第一条规则。</p><p>  <strong>查看规则</strong></p><p>  要查看当前定义的规则，可以使用 -L 选项，后跟链名。例如，要查看当前 INPUT 链中的所有规则，可以执行以下命令：</p><p>  iptables -L INPUT</p><p>  此命令将显示 INPUT 链中的所有规则。</p><ol start="6"><li><strong>iptables 的规则匹配</strong><br> iptables 使用规则中定义的匹配条件来确定数据包的处理方式。以下是一些常见的匹配条件和选项：</li></ol><p>  <strong>匹配条件</strong><br>  -p：指定数据包的协议类型，如 TCP、UDP、ICMP 等。<br>  -s：指定数据包的源地址。<br>  -d：指定数据包的目标地址。<br>  -i：指定数据包进入系统的网络接口。<br>  -o：指定数据包离开系统的网络接口。<br>  <strong>匹配选项</strong><br>  –sport：指定数据包的源端口。<br>  –dport：指定数据包的目标端口。<br>  –state：指定数据包的连接状态，如 NEW、ESTABLISHED、RELATED 等。<br>  –mac-source：指定数据包的源 MAC 地址。<br>  –mac-destination：指定数据包的目标 MAC 地址。<br>  <strong>匹配动作</strong><br>  -j：指定匹配成功时要执行的动作，如 ACCEPT、DROP、REJECT 等。</p><h3 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h3><p>根据实验要求以及有关命令，分别对22端口、192.168.0.1ip、icmp协议进行关闭和开放，结果如下图</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/03/17/65f6cfbf91231.png"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/03/17/65f6cfbf891cd.png"></p><p>进阶功能我简单查阅了有关资料并进行了配置，步骤大概是：</p><ol><li><p>确保 Linux 系统已启用 IP 转发功能。通过编辑 <code>/etc/sysctl.conf</code> 文件并取消注释 <code>net.ipv4.ip_forward=1</code> 行来实现。然后运行 <code>sudo sysctl -p</code> 命令使修改的配置生效。</p></li><li><p>配置 iptables 规则以实现 NAT 转换。：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 清空现有的 iptables 规则</span><br><span class="line">sudo iptables -F</span><br><span class="line">sudo iptables -t nat -F</span><br><span class="line"></span><br><span class="line"># 设置 NAT 规则</span><br><span class="line">sudo iptables -t nat -A POSTROUTING -o &lt;外部网络接口&gt; -j MASQUERADE</span><br></pre></td></tr></table></figure><p>其中 <code>&lt;外部网络接口&gt;</code> 是连接到互联网的网络接口，例如 <code>eth0</code> 或 <code>wlan0</code>。这个规则将对从私有网络发出的数据包进行地址转换，使用外部网络接口的 IP 地址作为源 IP 地址。</p></li><li><p>将 iptables 规则保存，以便在系统重启后仍然生效。可以使用以下命令将规则保存到文件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo sh -c &quot;iptables-save &gt; /etc/iptables/rules.v4&quot;</span><br></pre></td></tr></table></figure></li><li><p>配置私有网络中的主机以使用 NAT 主机作为默认网关。将私有网络中的每个主机的默认网关设置为 NAT 主机的 IP 地址。这可以通过在每个主机上编辑网络配置文件或通过 DHCP 服务器进行配置来实现。</p></li><li><p>测试 NAT 功能。确保私有网络中的主机可以通过 NAT 主机访问互联网，并能够使用 NAT 主机的公共 IP 地址进行通信。测试结果如下</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/03/17/65f6d22d725ef.png"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 大学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nosql复习</title>
      <link href="/2024/01/09/Nosql%E5%A4%8D%E4%B9%A0/"/>
      <url>/2024/01/09/Nosql%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-各种aaS"><a href="#1-各种aaS" class="headerlink" title="1.各种aaS"></a>1.各种aaS</h1><h1 id="2-传统ACID"><a href="#2-传统ACID" class="headerlink" title="2.传统ACID"></a>2.传统ACID</h1><p>原子性：undolog ——在SQL执行前先于数据持久化到磁盘</p><p>持久性：都要过磁盘IO（巨大开销）——引入BufferPool机制</p><p>隔离性：隔离级别越高开销越大，同时并发程度下降</p><p>一致性：一致性是事务追求的最终目标，前面提到的原子性、持久性和隔离性，都是为了保证数据库状态的一致性</p><p><strong>支持事务就意味着ACID</strong></p><h1 id="3-why-NoSQL"><a href="#3-why-NoSQL" class="headerlink" title="3.why NoSQL"></a>3.why NoSQL</h1><h2 id="关系型数据库瓶颈"><a href="#关系型数据库瓶颈" class="headerlink" title="关系型数据库瓶颈"></a>关系型数据库瓶颈</h2><p>在上面可以看到，传统数据库为了保证其ACID特性开销是相当大的，几乎所有操作都要到磁盘I&#x2F;O当中，因此在高并发条件下，磁盘I&#x2F;O就很容易导致性能瓶颈。【最终表现是在高并发条件下读写慢，即使有各类缓冲池存在，（设计初衷不同，对内存的优化不够好）】</p><p> 此外，在基于web的结构当中，数据库是最难进行横向扩展的，当一个应用系统的用户量和访问量与日俱增的时候，数据库却没有办法像web server和app server那样简单的通过添加更多的硬件和服务节点来扩展性能和负载能力。对于很多需要提供24小时不间断服务的网站来说，对数据库系统进行升级和扩展是非常痛苦的事情，往往需要停机维护和数据迁移。</p><p><strong>对网站来说，关系型数据库的很多特性不再需要了：</strong></p><p> 事务一致性——允许放弃一部分一致性来换取高可用。关系型数据库在对事物一致性的维护中有很大的开销，而现在很多web2.0系统对事物的读写一致性都不高</p><p> 读写实时性—— 对关系数据库来说，插入一条数据之后立刻查询，是肯定可以读出这条数据的，但是对于很多web应用来说，并不要求这么高的实时性，比如发一条消息之后，过几秒乃至十几秒之后才看到这条动态是完全可以接受的</p><p> 对海量数据的高效率存储和访问的需求—— 类似Facebook，twitter，Friendfeed这样的SNS网站，每天用户产生海量的用户动态，以Friendfeed为例，一个月就达到 了2.5亿条用户动态，对于关系数据库来说，在一张2.5亿条记录的表里面进行SQL查询，效率是极其低下乃至不可忍受的。再例如大型web网站的用户登 录系统，例如腾讯，盛大，动辄数以亿计的帐号，关系数据库也很难应付。或者说，多表联查或大表查询带来的开销不可接受（结构化数据）</p><p> 在关系型数据库中，导致性能欠佳的最主要原因是多表的关联查询，以及复杂的数据分析类型的复杂SQL报表查询。关系型数据库中的表都是存储一个格式化的数据结构，每个元组字段的组成都是一样，即使不是每个元组都需要所有的字段，但数据库会为每个元组分配所有的字段。这样的结构可以便于标语表之间进行链接等操作，但从另一个角度来说它也是关系型数据库性能瓶颈的一个因素。</p><p> Eg.不会局限于固定的结构，可以减少一些时间和空间的开销——KV键值对数据库【不用多表联查】</p><p> 【固定结构带来的是可以复杂查询，但开销上升，拓展性变差】</p><p><strong>总结：</strong></p><p>1.对数据库高并发读写的需求——大量磁盘I&#x2F;O__也可以引出分布式，有新的硬件如CPU等，变相跳开了瓶颈</p><p>2.对海量数据的高效率存储和访问的需求——大表，多表查询，结构化数据——OLAP分析型业务，大数据下的查询</p><p>3.对数据库的高可扩展性和高可用性的需求——分布式</p><p>4.半结构化&#x2F;非结构化数据存储——大数据下模式和数据的关系，模式难以先确定，甚至要反推模式来处理其他领域问题</p><h2 id="NoSQL缺点"><a href="#NoSQL缺点" class="headerlink" title="NoSQL缺点"></a>NoSQL缺点</h2><p> 非关系型数据库由于很少的约束，他也不能够提供像SQL所提供的where这种对于字段属性值情况的查询。并且难以体现设计的完整性。他只适合存储一些较为简单的数据，对于需要进行较复杂查询的数据，SQL数据库显的更为合适。</p><p> 非关系型数据库的实质：非关系型数据库产品是传统关系型数据库的功能阉割版本，通过减少用不到或很少用的功能，来大幅度提高产品性能。具体应用需要权衡。</p><h2 id="why-NOSQL种类多"><a href="#why-NOSQL种类多" class="headerlink" title="why NOSQL种类多"></a>why NOSQL种类多</h2><p>大数据环境下不可能存在一种数据库可以满足所有需求，NoSQL是一类数据库的统称</p><h2 id="关系型数据库与非关系型数据库的区别"><a href="#关系型数据库与非关系型数据库的区别" class="headerlink" title="关系型数据库与非关系型数据库的区别"></a>关系型数据库与非关系型数据库的区别</h2><p>关系型数据库的最大特点就是事务的一致性：传统的关系型数据库读写操作都是事务的，具有ACID的特点，这个特性使得关系型数据库可以用于几乎所有对一致性有要求的系统中，如典型的银行系统。</p><p>但是，在网页应用中，尤其是SNS应用中，一致性却不是显得那么重要，用户A看到的内容和用户B看到同一用户C内容更新不一致是可以容忍的，或者说，两个人看到同一好友的数据更新的时间差那么几秒是可以容忍的，因此，关系型数据库的最大特点在这里已经无用武之地，起码不是那么重要了。</p><p>相反地，关系型数据库为了维护一致性所付出的巨大代价就是其读写性能比较差，而像微博、facebook这类SNS的应用，对并发读写能力要求极高，关系型数据库已经无法应付【在读方面，传统上为了克服关系型数据库缺陷，提高性能，都是增加一级memcache来静态化网页，而在SNS中，变化太快，memcache已经无能为力了】，因此，必须用新的一种数据结构存储来代替关系数据库。</p><p>关系数据库的另一个特点就是其具有固定的表结构，因此，其扩展性极差，而在SNS中，系统的升级，功能的增加，往往意味着数据结构巨大变动，这一点关系型数据库也难以应付，需要新的结构化数据存储。</p><p>于是，非关系型数据库应运而生，由于不可能用一种数据结构化存储应付所有的新的需求，因此，非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合。 <strong>必须强调的是，数据的持久存储，尤其是海量数据的持久存储，还是需要一种关系数据库。</strong></p><p>SQL为什么并发读写慢？反之其他两个为什么快？<br>1.ACID的开销2.传统的全部要过硬盘3.结构性数据4.单点？分布式？</p><h2 id="关系型数据库分布式（如MySQL）"><a href="#关系型数据库分布式（如MySQL）" class="headerlink" title="关系型数据库分布式（如MySQL）"></a>关系型数据库分布式（如MySQL）</h2><ol><li><p>由于关系数据库支持事务，切分可能引入分布式事务，但分布式事务对系统资源消耗大，性能也并不高</p></li><li><p>跨节点的join和排序操作：尽管能在数据库端解决(Oracle DBlink, MySQL Federated)，但可能耗费大量的网络资源。通常推荐在应用层进行数据的整合，这需要应用层做很多额外的工作，也加重了应用服务器的负担</p></li></ol><h1 id="4-一致性理论模型"><a href="#4-一致性理论模型" class="headerlink" title="4.一致性理论模型"></a>4.一致性理论模型</h1><h2 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h2><p><strong>CAP理论</strong></p><p>一个分布式系统不可能满足一致性，可用性和分区容错性这三个需求，最多只能同时满足两个</p><p>可用性： 一直可以正常的做读写操作。简单而言就是客户端一直可以正常访问并得到系统的正常响应。用户角度来看就是不会出现系统操作失败或者访问超时等问题</p><p>一致性：在分布式系统完成某写操作后任何读操作，都应该获取到该写操作写入的那个最新的值。相当于要求分布式系统中的各节点时时刻刻保持数据的一致性</p><p>分区容错性：指的分布式系统中的某个节点或者网络出现了故障的时候，其他节点仍然能对外提供满足一致性和可用性的服务，也就是说部分故障不影响整体使用</p><p>事实上在设计分布式系统时都会考虑到bug、硬件、网络等各种原因造成的故障，所以即使部分节点或者网络出现故障，也要求整个系统还是要继续使用的</p><p>【分区可用性不可以舍弃，则只能在可用性和一致性中做取舍】</p><p><strong>CAP取舍</strong></p><p>CA: 优先保证一致性和可用性，放弃分区容错。 这也意味着放弃系统的扩展性，系统不再是分布式的，有违设计的初衷。【非分布式系统】【关系型数据库】</p><p>CP: 优先保证一致性和分区容错性，放弃可用性。在数据一致性要求比较高的场合(如:Zookeeper，Hbase) 是比较常见的做法，一旦发生网络故障或者消息丢失，就会牺牲用户体验，等恢复之后用户才逐渐能访问。【分布式数据库】</p><p>AP: 优先保证可用性和分区容错性，放弃一致性。放弃一致性不是说一致性就不保证了，而是逐渐的变得一致【保证最终一致性】【BASE模型】</p><p>分析时会发现不少数据库宣称同时高可用和强一致，这时要看错误恢复，如HBase，他某个region错误后，会暂停服务并作redo，放弃了可用，则为CP，但这时别的region依然在服务，所以是降低了可用性，不是完全不可用。</p><h2 id="一致性强弱"><a href="#一致性强弱" class="headerlink" title="一致性强弱"></a>一致性强弱</h2><p>强一致性（即时一致性）：假如A先写入了一个值到存储系统，存储系统保证后续A，B，C的读取操作都将返回最新值；单副本数据容易保证强一致性，多副本数据需要使用分布式事务协议。</p><p>弱一致性：假如A先写入了一个值到存储系统，存储系统不能保证后续A，B，C的读取操作能读取到最新值</p><p>不一致性窗口：从A写入到后续操作A，B，C读取到最新值这一段时间</p><p>窗口的大小依赖于以下的几个因素：交互延迟，系统的负载，以及复制技术中replica的个数（这个可以理解为master&#x2F;salve模式中，salve的个数）</p><p>最终一致性是弱一致性的一种特例</p><p>raft协议保证写强一致，读顺序一致</p><h2 id="BASE模型"><a href="#BASE模型" class="headerlink" title="BASE模型"></a>BASE模型</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/01/09/659ce7bf32c98.png"></p><p>BA—基本可用：指分布式系统在出现不可预知故障的时候，允许损失部分可用性——但请注意，这绝不等价于系统不可用（可能出现如响应时间，功能上的损失）</p><p>S—软状态&#x2F;柔性事务：指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时（即存在不一致性窗口）</p><p>E—最终一致性：强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性</p><p>在没有发生故障的前提下，数据达到一致状态的时间延迟，取决于网络延迟，系统负载和数据复制方案设计等因素（即不一致性窗口大小，当然也和分布式事务协议有关）</p><h2 id="NWR模型——一致性"><a href="#NWR模型——一致性" class="headerlink" title="NWR模型——一致性"></a>NWR模型——一致性</h2><p>N: 复制的节点数量，即副本数</p><p>R: 成功读操作的最小节点数</p><p>W: 成功写操作的最小节点数</p><p>只需W + R &gt; N，就可以保证强一致性，因为读取数据的节点和被同步写入的节点是有重叠的</p><p>Eg. TIDB中使用Raft协议，两阶段提交保证写强一致，而不是全部强一致，他读是顺序一致</p><p>根据CAP理论，一致性、可用性和分区容错 性最多只能满足两个，因此需要在一致性和可用性之间做一平衡。<br>如果要高的一致性，那么就配置N&#x3D;W，R&#x3D;1,这个时候可用性特别是写操作的性能就会大大降低。<br>如果想要高的可用性，那么此时就需要放松一致性的要求，此时可以配置W&#x3D;1，这样使得写操作延迟最低，同时通过异步的机制更新剩余的N-W个节点。<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/01/09/659ce81184d96.png"></p><h2 id="两阶段提交协议——分布式事务"><a href="#两阶段提交协议——分布式事务" class="headerlink" title="两阶段提交协议——分布式事务"></a>两阶段提交协议——分布式事务</h2><p>以保证分布式事务中，要么所有参与的进程都提交事务成功，要么都取消事务，这样做可以在分布式环境中保持ACID中A(原子性)在两阶段提交协议中，包含了两种角色：参与者就是实际处理事务的机器，协调者就是其中一台单独的处理分布式事务的机器。</p><p>两个阶段：</p><p><strong>投票阶段</strong>：在请求阶段，协调者将通知事务参与者准备提交或取消事务，然后进入表决过程<br>在表决过程中，参与者将告知协调者自己的决策：同意（事务参与者本地作业执行成功）或取消（本地作业执行故障）。</p><p> <strong>提交阶段</strong>：协调者将基于第一个阶段的投票结果进行决策：提交或取消。当且仅当所有的参与者同意提交事务协调者才通知所有的参与者提交事务，否则协调者将通知所有的参与者取消事务</p><p>优点：实现简单</p><p>缺点：</p><p><strong>同步阻塞问题：</strong>执行过程中，所有参与节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。</p><p><strong>单点故障：</strong>由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）【可以重选举，但依然有阻塞开销】</p><p><strong>数据不一致：</strong>commit请求提交时，部分节点挂掉会导致数据不一致。【日志可以解决】</p><p><strong>二阶段无法解决的问题：</strong>协调者commit发出后宕机，接收者也宕机，则事务出现不确定。</p><h1 id="5-数据复制"><a href="#5-数据复制" class="headerlink" title="5.数据复制"></a>5.数据复制</h1><p>复制是将数据同步在多个服务器的过程。复制至少需要两个节点，一个是主节点，负责处理客户端请求，其余的都是从节点，负责复制主节点上的数据</p><p>常见有一主一从，一主多从</p><p>主节点记录在其上的所有操作oplog，从节点定期轮询主节点获取这些操作，然后对自己的数据副本执行这些操作，从而保证从节点的数据与主节点一致</p><p>优点：<br>安全性，高可用，灾难恢复，无需停机维护，分布式读取数据</p><h1 id="6-文档数据库（MongoDB）"><a href="#6-文档数据库（MongoDB）" class="headerlink" title="6.文档数据库（MongoDB）"></a>6.文档数据库（MongoDB）</h1><h2 id="文档是数据库中的主要概念"><a href="#文档是数据库中的主要概念" class="headerlink" title="文档是数据库中的主要概念"></a>文档是数据库中的主要概念</h2><p>可存放并获取文档，其格式可以是XML、JSON、BSON等</p><p>数据库中的文档彼此相似，但结构不必完全相同，不像关系型数据库那样，表格中每行数据的模式都要相同【模式相似但可以不同】</p><p>向文档中新增属性时，既无需预先定义，也不用修改已有文档内容</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/01/09/659d0ab6571b8.png"></p><h2 id="文档数据库特性"><a href="#文档数据库特性" class="headerlink" title="文档数据库特性"></a>文档数据库特性</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/01/09/659d0aeeaba14.png"></p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><ol><li>应用在应用服务器的日志记录。</li><li>主要用来存储一些监控数据，No schema 对开发人员来说，真的很方便，增加字段不用改表结构，而且学习成本极低。</li><li>使用MongoDB做了O2O快递应用，将送快递骑手、快递商家的信息（包含位置信息）存储在 MongoDB，然后通过 MongoDB 的地理位置查询，这样很方便的实现了查找附近的商家、骑手等功能，使得快递骑手能就近接单。</li></ol><p>ALL：大型电商（如商品介绍页），博客网站(比如Twitter)，内容管理系统(WordPress和Windows注册表)，分析平台【主要出于海量，结构不完全相同的数据】</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>1.所有内容都在一个数据库当中，而不是信息分散在多个链接数据库中。因此，与SQL数据库相比可以获得更好的性能，只要不使用关系型流程。</p><p>2.不像每个信息都有一个字段的传统数据库，即使没有任何内容，文档存储数据库也更加灵活。实际上，不需要文档有一致性，您就可以存储大量数据，基本上没有问题。如果要保证多文档间的一致性，不建议用文档数据库。</p><p>3.同样，由于文档存储更灵活，因此集成新数据根本不是问题。与必须将任何新类型的信息添加到所有数据集的关系数据库相比，文档存储数据库只需要添加到几个数据集即可。【指字段】</p><p>4.可以在不造成任何停机的情况下修改模式，或者由于您将来可能不知道用户需求</p><p>5.文档存储还有助于数据分析，因为公司可以轻松存储众多信息供日后使用。</p><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>不支持多文档事务，业务中存在大量复杂的事务逻辑操作不要用【但MongoDB也开始支持了】</p><p>查询持续变化的聚合结构，虽然文档数据库对模式不施加任何限制，但是如果要即时查询这些持续可变的实体，那么所用的查询命令也要不断变化，所以就需要以最低级别的粒度来保存聚合，这实际上就等于要统一数据格式。</p><h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><p>文档型，分布式【高并发】，CP型</p><p>类JSON格式，文档内数据结构是kv，value既可以是简单的数据类型，如字符串、数字和日期等。也可以是复杂的类型，如有序列表和关联对象</p><p>最小单位是文档，同一个集合中存储的文档属性可以是不同的，每个文档都是自包含的数据单元，是一系列数据项的集合</p><p><strong>场景</strong><br>网站数据：Mongo 非常适合实时的插入，更新与查询，并具备网站实时数据存储所需的复制及高度伸缩性<br>缓存：由于性能很高，Mongo 也适合作为信息基础设施的缓存层，在系统重启之后，由Mongo 搭建的持久化缓存层可以避免下层的数据源过载<br>满足海量存储需求和访问||大尺寸、低价值的数据：使用传统的关系型数据库存储一些数据时可能会比较昂贵【有开销浪费，而且Mongo有WiredTiger 存储引擎，高性能，高压缩】，在此之前，很多时候程序员往往会选择传统的文件进行存储<br>高伸缩性的场景【如上面的网站数据】：Mongo 非常适合由数十或数百台服务器组成的数据库，Mongo 的路线图中已经包含对MapReduce 引擎的内置支持<br>用于对象及JSON 数据的存储：Mongo 的BSON 数据格式非常适合文档化格式的存储及查询</p><p><strong>不适合场景</strong><br>高度事务（如银行），传统的商业智能应用（数据仓库），一定要SQL的复杂查询</p><p><strong>优缺点</strong>：PPT3 21 22 23 MongoDB存储引擎wiredtiger默认高压缩、高性能。省磁盘，能在大数据量下比MySQL多存很多。</p><p><strong>数据模型</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/01/09/659d0d4e5c411.png"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/01/09/659d0d4e1fa00.png"></p><p><strong>特殊集合——固定集合</strong><br>很像环形队列，如果空间不足，最早的文档就会被删除，为新的文档腾出空间，适用于任何想要自动淘汰过期属性的场景，比如日志文件，聊天记录，通话信息记录等只需保留最近某段时间内的应用场景</p><p><strong>嵌入式文档</strong> PPT116 </p><p><strong>引用式文档</strong>PPT117 这东西的性能不太好，涉及到了一点多文档事务</p><p><strong>RDB转换MongoDB</strong><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/01/09/659d0e8f5bb89.png"></p><p><strong>数据类型</strong><br>只记特别的，详细见PPT3 29</p><p>Object—内嵌文档 Object ID—文档ID</p><p>Binary Data—二进制数据</p><p>Code—js代码</p><p>Regular Expression—正则表达式</p><p><strong>分片</strong></p><p>分片是指将数据拆分,将其分散存在不同机器上的过程.有时也叫分区.将数据分散在不同的机器上,不需要功能强大的大型计算机就可以存储更多的数据,处理更大的负载.<br>使用几乎所有数据库软件都能进行手动分片,应用需要维护与若干不同数据库服务器的连接,每个连接还是完全独立的.应用程序管理不同服务器上的不同数据,存储查村都需要在正确的服务器上进行.这种方法可以很好的工作,但是也 难以维护,比如向集群添加节点或从集群删除节点都很困难,调整数据分布和负载模式也不轻松.</p><p> MongoDB支持自动分片,可以摆脱手动分片的管理.集群自动切分数据,做负载均衡.</p><p> MongoDB中分片是拆大集合。</p><p><strong>实例</strong><br>可以看到都是混合数据源，各取所长很重要。</p><p>用电信息采集案例PPT3 179 缓存策略【安全，加快Mongo写入】，Mongo高并发读写，负载均衡</p><p>人社大数据平台PPT3 188 Oracle+HBase+Mongo【+并行计算+数据同步平台】</p><p> 注意其中档案袋结构，需求拓展，很好用Mongo，辅助智能助理，主要用于查询等具体操作。</p><p>文档及评论PPT3 194 点赞表，评论表等都不用了——&gt;一个集合搞定</p><p> 查询流程PPT3 196 不用多表联查，不需要同时执行大量SQL</p><h2 id="CouchDB"><a href="#CouchDB" class="headerlink" title="CouchDB"></a>CouchDB</h2><p>文档型，分布式【高并发】，AP型</p><p><strong>数据模型</strong></p><p>不需要范式，直接存储JSON就可以，CouchDB默认会生成 id，rev 两个键</p><p>数据库直接包含文档，没有集合概念</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>文档类数据库适合像聊天记录一样，掐头去尾一些必要用户信息外，中间有大量重复性结构的存储，相比SQL去掉了多表联查，数据也放在一起，开销更小，开发也更方便。</p><p> 也适合相似但不完全一样的海量数据存储，他在大数据下查询比SQL快得多</p><p> 但复杂事务就不要用了 ，因为不支持事务（只支持文档级别事务），手动保证一致性性价比太低了。</p><h1 id="7-列族数据库（Hbase）"><a href="#7-列族数据库（Hbase）" class="headerlink" title="7.列族数据库（Hbase）"></a>7.列族数据库（Hbase）</h1><h2 id="和行式比较"><a href="#和行式比较" class="headerlink" title="和行式比较"></a>和行式比较</h2><p>大量降低I&#x2F;O:【有利于海量查询】只读指定列，可以少很多数据</p><p>高压缩—省硬盘</p><p><strong>应用上</strong></p><p>行式：更有利于传统的OLTP业务，即增删改查</p><p>列式：更有利于OLAP业务，列式数据库在并行查询处理和压缩上更有优势。而且数据是以列为单元存储，完全不用考虑数据建模或者说建模更简单了。要查询计算哪些列上的数据，直接读取列就行。非常适合于在数据仓库领域发挥作用，比如数据分析、海量存储和商业智能;涉及不经常更新的数据【改就要用Rowkey去重组数据，这个性能并不算好】。</p><h2 id="HBase"><a href="#HBase" class="headerlink" title="HBase"></a>HBase</h2><p>列族型，分布式【高并发】，CP型</p><p>文件存储系统HDFS，数据处理方式MapReduce， 协同服务Zookeeper</p><p>HBase仅能通过主键(row key)和主键的range来检索数据，仅支持单行事务(可通过Hive支持来实现多表连接等复杂操作)</p><p>主要用来存储非结构化和半结构化的松散数据【列可以灵活增加】</p><p>Hbase表特点：大，面向列，稀疏【可以为null不占空间】</p><p><strong>Hbase结构</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/01/09/659d39c4c516a.png"></p><p>Hadoop实现的是一个分布式文件系统</p><p>Hadoop生态系统中的各层系统<br>HBase位于结构化存储层<br>HDFS为HBase提供了高可靠性的底层存储支持<br>MapReduce为HBase提供了高性能的计算能力<br>Zookeeper为HBase提供了稳定服务和失败恢复机制</p><p>主要是极大的表，大读写，少或无修改，要分析</p><p><strong>Hbase和传统关系数据库对比</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/01/09/659d39fb41c2e.png"></p><p><strong>数据模型</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/01/09/659d39c22d840.png"></p><p>列名字的格式是“ &lt; family &gt;:&lt; label &gt;”：如上图anchor所示，如果列族中有多个列，会和上面一样存储，头一格&lt; 列族名 &gt;：&lt; 列名 &gt;，第二格才是具体内容</p><p><strong>列族</strong>（Column Family）：表在水平方向有一个或者多个列族组成，一个列族中可以由任意多个列组成，即列族支持动态扩展，无需预先定义列的数量以及类型，所有列均以二进制格式存储，用户需要自行进行类型转换</p><p>【表由列族组成，列族下可能由多个列，定义时先列族名，列名可有可无，多列才需要列名】</p><p><strong>行键</strong>（Row Key）：HBase表的主键，表中的记录按照行键排序。行键用来检索记录的主键</p><p>【根据RowKey查询时，如果不指定timeStamp，会返回每个列的最新值，实际上更新也是插入新值来完成的】</p><p><strong>时间戳</strong>（Timestamp）：每次数据操作对应的时间戳，可看作是数据的版本号，不同版本通过时间戳来进行索引</p><p>NULL值实际上不会被存储，物理视图见PPT4 25</p><p>查询限制：PPT4 56 57<br>由于只能用RowKey和时间戳去查，rowkey的设计是至关重要的，设计不好会让功能做不出来，容易造成数据热点等</p><p>不同表通常需要不同的rowkey策略</p><p><strong>RowKey设计</strong></p><ul><li><p>在Hbase中，使用单调增加的rowkey值是不推荐的</p><p>因为rowkey字典序，这种设计优化了scan操作，可以将相关的行以及会被一起读取的行存取在临近位置，便于scan</p><p>但正因为这样，单调递增的rowkey会导致</p></li><li><p>Reverse反转：因为RowKey尾部随机性不错，这样的话可以把数据分布在各个节点上。这样是优化Get，牺牲Scan，因为相关数据被分散了；反转手段是多样的，可以把尾部数据拿到前面来，也可以使用减法等</p><p>时间戳反转：需要查询最近一段时间的场景还是很多的，但时间戳前半段基本一样，很容易造成数据热点，反转则会好不少</p><p>实际生产中可以用 Long.Max_Value - timestamp 追加到 key 的末尾，比如 [key] [reverse_timestamp]</p><p>【PS.这感觉像是出于原则才这么做，减这一下可能还是会造成数据热点，递增变递减而已，关键处应该是前置key】</p></li><li><p>Salt加盐：Salt是将每一个Rowkey加一个前缀，前缀使用一些随机字符，使得数据分散在多个不同的Region，达到Region负载均衡的目标，把数据分布在不同region中，增加写吞吐量，牺牲读性能</p></li><li><p>散列：改进加盐。使用确定性Hash加盐，前缀可以被算出来，从而直接拿到Rowkey来get，提高读性能，同时也让负载分散到整个集群。</p></li><li><p>尽量减少行键和列族的大小：当具体的值在系统间传输时，它的rowkey，列名，时间戳也会一起传输，如果rowkey和列名很大，将会占用大量的存储空间；冗长的属性名虽然可读性好，但是更短的属性名存储在HBase中会更好</p></li></ul><h2 id="Cassandra"><a href="#Cassandra" class="headerlink" title="Cassandra"></a>Cassandra</h2><p>列族型，分布式【高并发】，AP型</p><p>在混合模式可以将超级列添加到5维</p><p><strong>和Hbase比较</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/01/09/659d3b28bef60.png"></p><p><a href="https://zhuanlan.zhihu.com/p/341426602">Cassandra与HBase：双胞胎还是外表相似的陌生人？</a></p><p><strong>数据模型</strong><br>逻辑上是KeySpace-ColumnFamily-Key-Columns【数据模型含义和HBase是不一样的，考到看上面链接】</p><p>有超级列</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/01/09/659d3b8fd9c44.png"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/01/09/659d3bfa72b0d.png"></p><h2 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h2><p>MapReduce是一种编程模型，用于大规模数据集（大于1TB）的并行运算。</p><p>当前的软件实现是指定一个Map（映射）函数，用来把一组键值对映射成一组新的键值对，指定并发的Reduce（归约）函数，用来保证所有映射的键值对中的每一个共享相同的键组。</p><h2 id="HBase二级索引"><a href="#HBase二级索引" class="headerlink" title="HBase二级索引"></a>HBase二级索引</h2><h1 id="8-键值对数据库（Redis）"><a href="#8-键值对数据库（Redis）" class="headerlink" title="8.键值对数据库（Redis）"></a>8.键值对数据库（Redis）</h1><p>键值数据库将数据存储为键值对集合，其中键作为唯一标识符</p><p>键和值都可以是从简单对象到复杂复合对象的任何内容</p><p>键值数据库是高度可分区的，并且允许以其他类型的数据库无法实现的规模进行水平扩展【可水平拓展程度很高】</p><h2 id="优缺点，适用情景"><a href="#优缺点，适用情景" class="headerlink" title="优缺点，适用情景"></a><strong>优缺点，适用情景</strong></h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/01/09/659d3c45471ea.png"></p><p>KV数据库只能通过键值查询，意味着value是不可查的</p><p>没有事务，不能关联两个或两个以上的键来关联数据</p><p>某些KV数据库中，故障不能回滚</p><p>适用于：频繁读写，数据模型简单，内容缓存</p><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>KV型，分布式【高并发】，CP型，内存式</p><p>支持的数据类型包括string、list、set、zset(有序集合)和hash</p><p>支持push&#x2F;pop、add&#x2F;remove及取交集并集和差集及更丰富的操作，而且操作都是原子性的，支持各种不同方式的排序</p><p>【操作丰富且原子】</p><p>有主控，Redis支持主从同步</p><p><strong>数据模型</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/01/09/659d3ca4c899d.png"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/01/09/659d3cbb3614a.png"></p><p>Key为String类型</p><p>value类型丰富，支持string, list, hash, set, zset</p><p>只能通过Key对value查询</p><p>【KV结构是简单的，灵活的同时也把更多设计任务交给了用户，怎么把数据存入由用户自己负责】</p><p>注：</p><ul><li><p>Redis的String可以是字符串，整数，浮点数，但都存储为String</p></li><li><p>所有容器包含的都是String</p></li><li><p>set实际上是用散列表来存Key，散列表保证Key不重复，只有Key！！！没有Key对应的Value</p></li><li><p>hash存的是键值对</p></li><li><p>zset存的也是键值对，但有序集合的键被称为成员（member），值则被称为分值（score），分值必须为浮点数</p><p>zset是Redis里面唯一一个既可以根据成员访问元素（这一点和散列一样），又可以根据分值以及分值的排列顺序来访问元素的结构</p><p>【键值对，同时支持有序访问】</p></li><li><p>需要存的是KV时，请考虑hash或zset，存一系列值时，请考虑set和list，只有一个值时，使用string</p></li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/01/09/659d3d095dfba.png"></p><p>分区：PPT5 41-43<br>Redis总的来说还是得分区来达成分布式的，好坏见PPT</p><p><strong>数据恢复</strong></p><p>其实这个部分应该是很重要的，redis作为内存式数据库，这是他快的根源，一旦断电没备份是灾难式的，不知道为啥没讲</p><p>下文分别介绍了RDB、AOF、混合持久化，主要思路都是备份文件，但中间会有各种取舍</p><p>[探索分析服务数据同步持久化机制](<a href="https://blog.csdn.net/l569590478/article/details/128332826#:~:text=%E9%80%9A%E5%B8%B8%E6%83%85%E5%86%B5%E4%B8%8Bredis%E7%9A%84%E6%95%B0%E6%8D%AE%E5%85%A8%E9%83%A8%E5%AD%98%E5%82%A8%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%EF%BC%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%80%E6%97%A6%E6%95%85%E9%9A%9C%E5%8F%91%E7%94%9F%E9%87%8D%E5%90%AF%E6%95%B0%E6%8D%AE%E4%BC%9A%E5%85%A8%E9%83%A8%E4%B8%A2%E5%A4%B1">https://blog.csdn.net/l569590478/article/details/128332826#:~:text=通常情况下redis的数据全部存储在内存中，数据库一旦故障发生重启数据会全部丢失</a> ，,持久化功能在于能够有效地避免因进程退出造成的数据丢失问题 ， 在下次重启时利用之前持久化的文件即可实现数据恢复。)<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/01/09/659d3d4b239b7.png"></p><p><strong>文章投票实例</strong>：PPT 50-62</p><p>它是不需要事务的，存文章信息的格式为 article: 文章ID ——hash，hash里存各种键值对信息【这意味着文章间信息联系弱，因为没有跨文章的事务】</p><p>文章间的联系通过另外两个key来解决</p><p>time和score——zset</p><p>在zset中，以文章ID为key，time和score的值为value</p><p>同时需要已投票用户集合，可以用used——hash，文章ID为key，value是一个由用户ID组成的set【也可以看PPT中一样】</p><p>Redis是内存式的，需要节约内存</p><p>可行的方案比如，限定投票时间，过期就淘汰掉相关的已投票用户表，或者评选到期后，可以把分数不够的分数和时间集合都不要了，具体看内存情况</p><p>ZINTERSTORE命令表明，Redis还是支持在set、zset、hash中key上的相关运算的，如果只是Key间有联系，Redis还是可以进行筛选部分值。</p><h2 id="DynamoDB"><a href="#DynamoDB" class="headerlink" title="DynamoDB"></a>DynamoDB</h2><p>KV型，分布式【高并发】，AP型，完全托管（来自亚马逊）</p><p><strong>数据模型</strong>：PPT5 68 69<br>Redis是单纯的key-value键值对存储。<br>DynamoDB虽然也是以key-value形式存储数据的，但是也引入了传统关系型数据库(RDBMS)中的表的概念有了表就有主键的概念，DynamoDB中的分区键和排序键以及二级索引可以应对很多不同场景下的需求。<br>所以DynamoDB更像是处于NoSQL和RDBMS之间的一种数据库。</p><p>Redis由于其性能更多的被用于做缓存。<br>DynamoDB则更接近于RDBMS的应用场景，比如数据存储，增删查改等。<br>不难理解的是，在一款大型线上游戏的服务端，应该是客户端 — 服务端 — 缓存(Redis) — DynamoDB这样的层级结构。</p><h1 id="9-图数据库（Neo4j）"><a href="#9-图数据库（Neo4j）" class="headerlink" title="9.图数据库（Neo4j）"></a>9.图数据库（Neo4j）</h1><h2 id="why图数据库？"><a href="#why图数据库？" class="headerlink" title="why图数据库？"></a><strong>why图数据库？</strong></h2><p><strong>关系数据库的不足</strong></p><p>随着离散数据的增加，数据集的宏观结构会越发复杂和不规整，关系模型将造成大量表连接、稀疏行和非空检查逻辑，<br>关系世界中连通性的增强将转换为连接操作的增加，会阻碍性能，使得数据库难以响应变化的业务需求<br>面对一项联系，可能需要不断用SQL执行连接表，递归查询代价比较高</p><p><strong>其他NoSQL的不足</strong></p><p>Key-value、文档和列存储数据库存储的都是无关联的值&#x2F;文档&#x2F;列，很难用于关联数据<br>对于上述数据库而言，一种添加联系的策略是在某个聚合数据(Aggregate)中嵌入另一个聚合数据标识符，即添加外键，这将导致代价剧增【如引用文档，这样做的代价是比较大的】，即使构建了联系，那反向查询也会成为问题</p><p><strong>图数据库优势</strong></p><p>拥抱联系，在查找各类拓展关系时，速度优势巨大</p><h2 id="Neo4j："><a href="#Neo4j：" class="headerlink" title="Neo4j："></a>Neo4j：</h2><p>图型，分布式【高并发】，CP型</p><ul><li><p>Neo4j 中两个最基本的概念是节点和边</p><p>节点表示实体，边则表示实体之间的关系</p><p>节点和边都可以有自己的属性</p></li><li><p>Neo4j 提供了在对象图上进行查找和遍历的功能：深度搜索，广度搜索【遍历可以限制深度】</p></li></ul><p><strong>完整的ACID，支持事务</strong></p><p>高可用，高伸缩</p><p><strong>数据模型</strong></p><p>Neo4j数据记录在节点和联系中</p><ul><li><p>节点和联系都拥有属性（Properties）</p></li><li><p>节点通过联系关联起来</p></li><li><p>联系一定是有方向的，可以单向可以双向</p></li><li><p>节点经常被用于表示实体，可以有多个属性；最简单的节点也要有一个属性</p></li><li><p>每个关系包含“开始节点”或“从节点”和“到节点”或“结束节点”</p><p>【因此通过关系可以找到很多关联的数据，比如节点集合，关系集合以及他们的属性集合】</p></li><li><p>属性（Properties）是键值对</p><p>键名是字符串<br>属性值是要么是原始值，要么是原始值类型的一个数组，原始值就是常见的bool，char等等PPT6 29</p></li><li><p>联系有类型（Type），节点有标签（label），用于区分某一类</p></li></ul><p><strong>路径&#x2F;遍历</strong></p><p>路径由至少一个节点，通过各种关系连接组成，经常是作为一个查询或者遍历的结果</p><ul><li>遍历的路径：通常用关系的类型和方向来表示</li><li>遍历的顺序：常见的遍历顺序有深度优先和广度优先两种【可以指定深度】</li><li>遍历的唯一性：可以指定在整个遍历中是否允许经过重复的节点、关系或路径</li><li>遍历过程的决策器：用来在遍历过程中判断是否继续进行遍历，以及选择遍历过程的返回结果</li><li>起始节点：遍历过程的起点</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/01/09/659d3f7c13856.png"></p><p>索引</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/01/09/659d3f7bbcf6e.png"></p><p><strong>数据转换</strong></p><ul><li>RDB to Neo4j:同张表的给相同的label或type，这要看实体集还是联系集，如果没有联系集的话可以根据平常使用情况进行构造，<br>其他就没啥了，其他按照属性填入就可以了</li><li>Key-value DB to Neo4j：KV数据库的联系就更弱了，首先考虑KV间的联系，再具体考虑value和key，value和value间的关系，但好的设计不应该让这种情况出现，这个转换本身就比较诡异</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/01/09/659d3fd081aaf.png"></p><ul><li>Document DB to Neo4j：和传统数据库相比下多了个数据库实例，【在传统数据库下是模式，其实不太用得到】，每一级呈现包含关系，最后考虑引用文档&#x2F;集合的联系</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/01/09/659d3fd0ceb66.png"></p><p>案例PPT6 46 社交网络</p><h1 id="10-汇总"><a href="#10-汇总" class="headerlink" title="10.汇总"></a>10.汇总</h1><h2 id="数据库汇总"><a href="#数据库汇总" class="headerlink" title="数据库汇总"></a>数据库汇总</h2><p>MongoDB【满足海量存储需求和访问】【文档型】</p><p>HBase（Hadoop）【列簇】列和RDBS转换用sqoop【关系型和HDFS转换】</p><p>Redis【kv+内存式】【高读写】</p><p>Neo4j【图】</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/01/09/659d3dfe01bb1.png"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/01/09/659d3dfda9686.png"></p><p>重要的，Mongo可以直接存文件，有二进制数据这个类型【图片等】</p><p>HBase也可以，但对每个值的大小是有实际限制的【不是文件很难撑爆这个限制】</p><p>Neo4j不能存文件</p><p>Redis也不能，也不好，一个内存式的不应该存</p><h2 id="案例汇总"><a href="#案例汇总" class="headerlink" title="案例汇总"></a>案例汇总</h2><p>新浪—Redis+MySQL</p><p>从微博来看的话，新浪用的MySQL好像不是完美的选择，用Mongo或许不错；</p><p>使用MySQL应该是构建年代比较早，而且有一定的事务需求，使用Redis是为了缓冲，应对高并发场景</p><p>视觉中国—MongoDB</p><p>文章类，Mongo很擅长</p><p>优酷—在线评论MongoDB 运营数据分析Hadoop&#x2F;Hbase</p><p>挺好的，显然的选择</p><p>京东—Redis</p><p>这里说Redis应该还是在大并发上，比如说秒杀级别业务，这类业务是典型的读多写少的应用场景，下单和支付才是写请求。所以这个时候，缓存潇洒的出场。</p><p>写操作肯定还是有高度的事务属性，最后下单和支付肯定是要用传统关系型的</p><p>但前期浏览显然不用，都是读，这时候放在Redis就很好了</p><p>携程—HBase，Redis</p><p>HBase显然的数据分析需求，Redis用于缓冲？旅游网站有点意义不明，不过商业环境下一般都有</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>如果感觉事务性比较强，特别是多表事务，不能接受先重做一个再做另一个中间的时间窗口的，用传统ACID</p><p>感觉分析型，用列族</p><p>感觉联系很多的，图数据库很好，比如朋友圈，本人—朋友ID—根据朋友ID逐一找出文章ID的列表—找到文章—排序，，即完成一项功能需要根据查询结果再查的，可以用图，但他不能存文件，这个就比较尴尬了，要存图片什么的就不要用这个了</p><p>redis啥时候用？多半是个RDB做缓冲，纯的redis几乎没有持久化手段，不太好</p><p>Mongo？我更愿意这么理解，在业务不确定，且没啥对强一致性要求的，可以用Mongo，好处在于随便存，可以存文件！</p><p>最后，某种数据库嗯用也不是不行，但效果可能不太好就是了，也不一定，比如大数据量存储，列族和Mongo感觉都不错</p>]]></content>
      
      
      <categories>
          
          <category> 大学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nosql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据科学导论复习</title>
      <link href="/2023/12/28/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA%E5%A4%8D%E4%B9%A0/"/>
      <url>/2023/12/28/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%AF%BC%E8%AE%BA%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这门课知识体系实在很杂，涉及到大数据、sql&amp;nosql、机器学习很多领域，而且深度不一，浅到概念深到算法原理，整理起来实在麻烦。于是秉承着极简的理念整理了这份概念文档，应付考试绰绰有余了，对某个点感兴趣的自行搜索。</p></blockquote><h1 id="第一二讲-引言"><a href="#第一二讲-引言" class="headerlink" title="第一二讲 引言"></a>第一二讲 引言</h1><p>总体上是概论部分，可能考的也就名词解释了，总结如下：</p><h2 id="什么是大数据，大数据的界限，4V"><a href="#什么是大数据，大数据的界限，4V" class="headerlink" title="什么是大数据，大数据的界限，4V"></a>什么是大数据，大数据的界限，4V</h2><p>大数据是一种数据规模大到 在数据的获取管理，存储处理，分析计算都远远超过传统数据库软件工具处理范围的 数据集合。</p><p>大数据的界限是PB</p><p>4V： 体量巨大、速度极快（高实时性）、模态多样、价值密度低（但商业价值高）</p><h2 id="什么是数据科学"><a href="#什么是数据科学" class="headerlink" title="什么是数据科学"></a>什么是数据科学</h2><p> 基于传统的数学，统计学的理论和方法，运用计算机技术进行大规模的数据计算，分析，应用的学科</p><h2 id="数据处理的一般步骤是什么"><a href="#数据处理的一般步骤是什么" class="headerlink" title="数据处理的一般步骤是什么"></a>数据处理的一般步骤是什么</h2><p> 采集，表示与存储，预处理（清洗，集成等），建模分析，可视化，决策</p><h1 id="第四五讲-数据采集与整理"><a href="#第四五讲-数据采集与整理" class="headerlink" title="第四五讲 数据采集与整理"></a>第四五讲 数据采集与整理</h1><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><p>基本方法：数据清理，数据集成，数据变换，数据规约</p><h3 id="why预处理"><a href="#why预处理" class="headerlink" title="why预处理"></a>why预处理</h3><p>因为有<strong>脏数据</strong>，在数据挖掘工作中，脏数据是指不完整、含噪声、不一致的数据</p><p>why脏数据？</p><ul><li>不完整，有些数据属性的值丢失或不确定；缺失必要数据，例：缺失学生成绩</li><li>不准确，属性值错误，例：成绩 &#x3D; -10； 噪声数据：包含孤立（偏离期望）的离群</li><li>不一致，数据结构有较大差异；存在数据重复和信息冗余现象；数据需求改动，例，评价等级:“百分制”与“A, B, C”</li></ul><p>数据错误是不可避免的</p><p>数据质量的含义：正确性，一致性，完整性，可靠性</p><h3 id="数据清洗"><a href="#数据清洗" class="headerlink" title="数据清洗"></a>数据清洗</h3><p>数据缺失或出错（噪声）的原因就很多了：采集出错，反爬虫，加密，存储出错，人为，等等</p><h4 id="处理缺失方法"><a href="#处理缺失方法" class="headerlink" title="处理缺失方法"></a>处理缺失方法</h4><h5 id="数据缺失的类型"><a href="#数据缺失的类型" class="headerlink" title="数据缺失的类型"></a>数据缺失的类型</h5><p>完全随机缺失：不依赖其他属性&#x2F;变量，不影响样本的无偏性</p><p>随机缺失：缺失与其他完全属性&#x2F;变量有关系<br>                “期末成绩”的依赖于“平时表现”<br>                “工资”与“人群背景”的关系</p><p>非随机缺失: 数据缺失与属性&#x2F;变量自身的取值有关 Eg.工资问卷</p><h5 id="数据删除"><a href="#数据删除" class="headerlink" title="数据删除"></a>数据删除</h5><p>（可能丢失信息，或改变分布），但如果数据是完全随机缺失，对结果不产生影响，则可以删除</p><h5 id="数据填充"><a href="#数据填充" class="headerlink" title="数据填充"></a>数据填充</h5><ul><li>特殊值填充<ul><li>空值填充，不同于任何属性值。例，NLP词表补0，DL补mask</li><li>样本&#x2F;属性的均值、中位数、众数填充</li></ul></li><li>使用最可能的数据填充<ul><li>热卡填充（找相似的样本，并就近补齐）</li><li>K最近距离法（KNN，找最近的K个相似的样本，并加权平均估计样本缺失数据）</li><li>利用回归等估计方法（基于数据集建立回归方程模型）</li><li>期望值最大化方法（EM算法）</li></ul></li></ul><h4 id="处理噪声方法"><a href="#处理噪声方法" class="headerlink" title="处理噪声方法"></a>处理噪声方法</h4><p>噪声是测量误差的随机部分</p><ul><li>包括错误值，或偏离期望的孤立点值</li><li>需要对数据进行平滑</li></ul><h5 id="分箱-binning"><a href="#分箱-binning" class="headerlink" title="分箱(binning)"></a>分箱(binning)</h5><p>利用近邻数据对数据进行平滑，步骤如下：</p><ol><li><p>排序数据，并将他们分到等深的箱中</p></li><li><p>按箱平均值平滑、按箱中值平滑、按箱边界平滑等(离散化)</p></li></ol><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/28/658d99474fd46.png"></p><h5 id="回归-Regression"><a href="#回归-Regression" class="headerlink" title="回归(Regression)"></a>回归(Regression)</h5><p>回归模型可以做缺失值填充，也可以做数据平滑，同个道理，把噪声数据用回归模型预测数据替代</p><h5 id="聚类"><a href="#聚类" class="headerlink" title="聚类"></a>聚类</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/28/658d994739175.png"></p><h4 id="特殊处理"><a href="#特殊处理" class="headerlink" title="特殊处理"></a>特殊处理</h4><p>在特定的应用任务中，根据目标不同，需要特殊的数据清理方法</p><p>比如<strong>冷启动问题</strong>：如何在没有大量用户数据的情况下设计个性化推荐系统并让用户对推荐结果满意而愿意使用推荐系统</p><p>几种推荐系统是否存在冷启动问题</p><ul><li>基于人口统计学的推荐：无冷启动问题</li><li>基于内容的推荐：有冷启动问题</li><li>基于协同过滤的推荐：对新物品和新用户都有冷启动问题</li><li>通用推荐问题（两种协同过滤算法）</li></ul><p>UserCF算法推荐的是那些和目标用户有着共同兴趣爱好的其他用户所喜欢的物品</p><p>ItemCF算法推荐的是那些和目标用户之前喜欢的物品类似的其他物品</p><p>UserCF算法的推荐更偏向于社会化，而ItemCF算法的推荐更偏向于个性化</p><h3 id="数据集成"><a href="#数据集成" class="headerlink" title="数据集成"></a>数据集成</h3><p>将多个数据源的数据整合到一个一致的数据存储中,目标是获得更多更完整的数据，获得更全面的数据画像，如用户画像等</p><p>无序数据：每个数据样本的不同维度是没有顺序关系的</p><p>有序数据：对应的不同维度(如特征)是有顺序要求的</p><h4 id="对于无序数据"><a href="#对于无序数据" class="headerlink" title="对于无序数据"></a>对于无序数据</h4><p>集成数据（库）时，经常出现冗余数据</p><ul><li>冗余属性</li><li>冗余样本</li></ul><h5 id="检测冗余属性"><a href="#检测冗余属性" class="headerlink" title="检测冗余属性"></a>检测冗余属性</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658e494459083.png"></p><p>Pearson相关系数：</p><ul><li>＞0：两项属性可以把一个作为冗余删除</li><li>&#x3D;0：相互独立</li><li>&lt;0：负相关</li></ul><p>卡方检验：值越大，两个变量相关的可能越大</p><h5 id="检测冗余样本"><a href="#检测冗余样本" class="headerlink" title="检测冗余样本"></a>检测冗余样本</h5><h6 id="各种距离"><a href="#各种距离" class="headerlink" title="各种距离"></a>各种距离</h6><p>欧几里得距离（对数据标准化很重要）</p><p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658e4996bd9e4.png"></p><p>上面这几个都不咋用，引出马氏距离<br>它在欧式距离的基础上，考虑到各种特性之间的联系（协方差）<br>马氏距离把方差归一化，使得特征之间的关系更加符合实际情况。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658e49e2b4b5f.png"></p><h6 id="各种相似度"><a href="#各种相似度" class="headerlink" title="各种相似度"></a>各种相似度</h6><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658e4a1c3c4b5.png"></p><p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658e4a153e133.png"></p><p>看一下SMC，Jaccard相关系数，余弦相似度怎么算</p><ul><li>Jaccard相关系数用在集合数据上</li><li>余弦相似度用在文档，图片上</li></ul><h4 id="对于有序数据"><a href="#对于有序数据" class="headerlink" title="对于有序数据"></a>对于有序数据</h4><h5 id="Spearman-Rank相关系数"><a href="#Spearman-Rank相关系数" class="headerlink" title="Spearman Rank相关系数"></a>Spearman Rank相关系数</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658e4a961df8f.png"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658e4a94cb8ef.png"> </p><p>怎么算+用途：信息检索，推荐系统</p><h5 id="NDCG"><a href="#NDCG" class="headerlink" title="NDCG"></a>NDCG</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658e50d1bce8f.png"></p><p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658e50d21628f.png"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658e50d1600db.png"></p><h3 id="数据变换"><a href="#数据变换" class="headerlink" title="数据变换"></a>数据变换</h3><h4 id="数据规范化"><a href="#数据规范化" class="headerlink" title="数据规范化"></a>数据规范化</h4><p>目的：将不同数据（属性）按一定规则进行缩放，使它们具有可比性</p><ul><li>最小-最大规范化（对原始数据进行线性变换。把数据A的观察值v从原始的 区间[minA，maxA]映射到新区间 [new_minA，new_maxA]）【0-1规范化又称为归一化】</li><li>z-score规范化【结果仅用于比较】</li></ul><p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658e518fcb300.png"></p><h4 id="数据离散化【熵的计算】"><a href="#数据离散化【熵的计算】" class="headerlink" title="数据离散化【熵的计算】"></a>数据离散化【熵的计算】</h4><p>连续数据过于细致，数据之间的关系难以分析，划分为离散化的区间，发现数据之间的关联，便于算法处理</p><p>Eg. 把年龄离散化为不同年龄段，把成绩离散化为不同等级，总之就是让他们不连续</p><ul><li><p>非监督离散化（可采用噪声清理方法）【无类别信息】</p><ul><li>分箱</li><li>聚类</li></ul></li><li><p>监督离散化（基于熵的离散化）【有类别信息】</p><ul><li><p>熵的计算</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658e5217f238a.png"></p></li><li><p>根据熵确定分割点</p><p>给原来的数据算一个熵<br>计算分割后数据的总熵</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658e52177c694.png"></p><p>相减，得到信息增益<br>确定分割点就是找信息增益最大点的地方</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658e5217d7e77.png"></p><p>答案应该是第二和第三个数据之间</p></li></ul></li></ul><h3 id="数据规约"><a href="#数据规约" class="headerlink" title="数据规约"></a>数据规约</h3><p>数据清理、数据集成之后，获得多源且质量完好的数据集，但数据规模过大</p><p>目标：缩小数据挖掘所需的数据集规模，缩小后的数据集可以产生几乎相同的分析结果</p><p>用于数据归约的时间不应当超过或“抵消”在归约后的数据上 挖掘节省的时间</p><ul><li><p>维度归约（减少所考虑的随机变量或属性的个数）</p><ul><li><p>PCA（主成分分析）【需要复习计算，行列式计算，求特征值，求特征向量】<br>所有行先减去各自行的平均值<br>求协方差矩阵C<br>对协方差矩阵求特征值，特征向量<br>标准化特征向量（长度为1）【不一定要做】<br>用标准化后的特征向量（按特征值大小排序），取K个组成矩阵P<br>Y&#x3D;XP</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658e593fbb6e3.png"></p><p>缺点：求特征值的计算效率是比较低的；映射得到的维度是不可逆的，且不可解释，没有具体意义</p></li><li><p>特征子集选择</p><ul><li>做法：删除不相关或冗余的属性来减少维度与数据量<br>目标：找到最小属性集，使得数据的概率分布尽可能接近使用所有属 性得到的原分布<br>理解：从全部属性中选取一个特征属性子集，使构造出来的模型更好</li></ul></li><li><p>启发式步骤：建立子集集合，构造评价函数，构建停止准则，验证有效性【决策树】</p></li></ul></li><li><p>数值归约（用较小的数据表示形式替换原始数据）【没咋讲】</p><ul><li><p>参数化方法【只存参数，不存数据】：各种回归模型</p></li><li><p>非参数化方法：直方图，聚类，抽样</p></li></ul></li></ul><h2 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h2><p>从这里开始，就和实际任务密切相关了</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p> 在数据预处理以后（或者数据预处理过程中），如何从数据中提取有效的特征，使这些特征能够尽可能的表达原始数据中的信息，使得后续建立的数据模型能达到更好的效果，就是特征工程所要做的工作。</p><h3 id="设计特征"><a href="#设计特征" class="headerlink" title="设计特征"></a>设计特征</h3><ul><li>独热特征表示：将每个属性表示成一个很长的向量（每维代表一个属性值，如词语）<ul><li>优点：直观，简洁</li><li>缺点：<br>维度灾难：当需要表示的属性非常多的时候，独热特征表示在空间和时间上的开销都是十分巨大的<br>语义鸿沟：每个属性都是完全独立的，无法刻画属性间的联系</li></ul></li><li>TF-IDF（词频-逆文档率）<ul><li>词频：TF &#x3D; 某个词(特征值)在句子(数据)中出现的频率</li><li>逆文档率：lg(语料库(数据库)的句子(数据)总数 &#x2F; 包含该词(特征值)的句子(数据)总数)</li><li>应用：搜索引擎；关键词提取；文本相似性；文本摘要</li></ul></li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658e59d964bbf.png"></p><p>例：假如一篇文件的总词语数是100个，而词语“母牛”出现了3次，那么“母牛”一词在该文件中的词频就是3&#x2F;100&#x3D;0.03。一个计算文件频率 (IDF) 的方法是文件集里包含的文件总数除以测定有多少份文件出现过“母牛”一词。所以，如果“母牛”一词在1,000份文件出现过，而文件总数是10,000,000份的话，其逆向文件频率就是 lg(10,000,000 &#x2F; 1,000)&#x3D;4。最后的TF-IDF的分数为0.03 * 4&#x3D;0.12。</p><p>当词语在所有文件中都没有出现时，IDF的分母要加1</p><h3 id="特征子集挑选"><a href="#特征子集挑选" class="headerlink" title="特征子集挑选"></a>特征子集挑选</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658e5a0c3c372.png"></p><h3 id="特征子集评价"><a href="#特征子集评价" class="headerlink" title="特征子集评价"></a>特征子集评价</h3><p>过滤式仅仅是用信息统计的启发式准则来评价</p><p>封装式是直接用最终分类器性能作为评价标准，比过滤式好的代价是泛化性变差，同时计算开销较高</p><p>嵌入式有两种选择：基于奖惩和基于树模型</p><p>奖惩式新增了特征的权重，现在也往往内嵌在深度学习中</p><p>树模型是在说，决策树，随机森林等本身也是一种特征选择</p><h2 id="传统ML和深度学习区别"><a href="#传统ML和深度学习区别" class="headerlink" title="传统ML和深度学习区别"></a>传统ML和深度学习区别</h2><p>从手动特征提取到自动特征提取</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658e5a4a2dca4.png"></p><h1 id="第六讲-数据存储与管理"><a href="#第六讲-数据存储与管理" class="headerlink" title="第六讲 数据存储与管理"></a>第六讲 数据存储与管理</h1><h2 id="数据分类"><a href="#数据分类" class="headerlink" title="数据分类"></a>数据分类</h2><ul><li><p>结构化数据</p><p>可以使用关系型数据库表示和存储的数据，拥有固定结构，如csv等</p></li><li><p>半结构化数据</p><p>弱结构化，虽然不符合关系型数据模型的要求，但是含有相关的标记(自描述结构)，分割实体及其<br>属性 。如：XML，JSON等</p></li><li><p>非结构化数据</p><p>没有固定数据结构，或很难发现统一数据结构的数据<br>文档，文本，图片，视频，音频等</p></li></ul><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658eaa5300ecb.png"></p><p>常见数据库</p><p>关系型：MySQL，Oracle</p><p>非关系型：Redis，Mongo，Neo4j，Hbase等</p><h2 id="SQL类型"><a href="#SQL类型" class="headerlink" title="SQL类型"></a>SQL类型</h2><p>类别一：Data Definition Language (DDL) 数据定义语言(create,delete等)<br>类别二：Data Manipulation Language (DML) 数据操作语言（增删改查）<br>类别三： Data Control Language（DCL）：数据控制语言，用来定义访问权限和安全级别<br>类别四：Data Query Language（DQL）：数据查询语言，用来查询记录（数据）。【Select】</p><ul><li>create，delete（DDL）</li><li>SELECT会结合连接考【Inner Join &#x3D; Join，Outer Join （左，右，全），自然连接】</li></ul><h2 id="关系型数据库优点"><a href="#关系型数据库优点" class="headerlink" title="关系型数据库优点"></a>关系型数据库优点</h2><ul><li>数据结构化，管理效率高</li><li>存取路径对用户隐蔽，用户只要指出“干什么”，不必详细说明“怎么干”</li></ul><p>实际上，明显的优点应该在对于事务的支持，有高一致性</p><h2 id="why-NoSQL"><a href="#why-NoSQL" class="headerlink" title="why NoSQL"></a>why NoSQL</h2><p>可以从下面几个方面来说，主要看题目怎么问：</p><h3 id="从数据结构化来说"><a href="#从数据结构化来说" class="headerlink" title="从数据结构化来说"></a>从数据结构化来说</h3><ul><li>随着大数据时代的降临，我们面对的不仅仅是结构化数据的存储，还有各种半结构化，非结构化的数据</li><li>举例来说，前期需求不明确，非严格事务性的产品，可以使用NoSQL（MongoDB），因为传统RDBMS更改表结构的代价较大，结构不灵活；对于明显面向联系的数据产品来说，使用Neo4J很可能是个不错的选择，因为RDBMS对联系的查询代价比较大</li></ul><h3 id="从高并发读写来说（Web-2-0）"><a href="#从高并发读写来说（Web-2-0）" class="headerlink" title="从高并发读写来说（Web 2.0）"></a>从高并发读写来说（Web 2.0）</h3><ul><li>传统RDBMS几乎所有操作都要过磁盘，这是为了保证事务特性带来的巨大开销；但这种开销在新的Web 2.0中可能是不必要的，起码对于博客系统来说，两个用户短时间内看到的内容不完全一致不会带来很大影响，所以NoSQL一个重要的思路就是降低一定的一致性【降低支持的事务等级】，从而获得更高的读写效率，获得更高的可用性和分区容错</li><li>传统RDBMS是不分区的，意味着不支持横向拓展，这会导致硬件上的IO瓶颈；分布式是应对高并发的重要方案，NoSQL往往都对此提供了强大支持，有自动化分区服务等等</li><li>使用内存做缓存可以改善这一情形，内存式KV数据库—Redis</li></ul><h3 id="从海量数据下的查询（读写）来说"><a href="#从海量数据下的查询（读写）来说" class="headerlink" title="从海量数据下的查询（读写）来说"></a>从海量数据下的查询（读写）来说</h3><ul><li><p>传统RDBMS是行式的，在条件查询下会带来更高的成本；不妨尝试列式存储，该类型也常常应用在大规模的数据分析上</p></li><li><p>集合运算在Redis上很轻松【内存式，结构简单，很快】，但传统就不好说了</p></li><li><p>分布式…</p></li></ul><h2 id="几种NoSQL的应用场景"><a href="#几种NoSQL的应用场景" class="headerlink" title="几种NoSQL的应用场景"></a>几种NoSQL的应用场景</h2><p>集合运算—Redis</p><p>社交，推荐系统，数据可视化—Neo4j</p><p>数据分析—列式</p><p>只要不是强事务性的，用Mongo都会带来性能提升</p><p>Redis优点</p><ul><li>支持的数据类型包括string、list、set、zset(有序集合)和hash</li><li>支持push&#x2F;pop、add&#x2F;remove及取交集并集和差集及更丰富的操作，而且操作都是原子性的，支持各种不同方式的排序</li><li>内存式，分布式，轻松应对高并发场景</li><li>对数据结构性要求不高</li><li>可拓展，分布式</li></ul><p>NoSQL比较通用的原因：</p><ul><li>分布式，轻松应对高并发场景，高并发读写性能优异</li><li>分布式，优越的水平拓展性能【图除外】</li><li>海量数据下高效的查询性能</li><li>对数据结构性要求不高，数据结构修改代价小</li></ul><h1 id="第七讲-探索性数据分析"><a href="#第七讲-探索性数据分析" class="headerlink" title="第七讲 探索性数据分析"></a>第七讲 探索性数据分析</h1><h2 id="数据探索性分析【重点】"><a href="#数据探索性分析【重点】" class="headerlink" title="数据探索性分析【重点】"></a>数据探索性分析【重点】</h2><p>指对已有的数据在尽量量少的先验假定情况下进行探索，逐步了解数据的特点</p><p>作用：利用人机交互技术和数据可视化技术，通过不断揭示数据的规律和数据间的关联，引导分析人员发现并认识以前不知道的数据模式或规律。对未知的数据模式和规律的探索是其价值所在。</p><p>探索式数据分析的基本方法</p><ol><li>计算一些汇总统计量，了解数据的典型值，还可以通过确定异常值，了解数据的异常情况</li><li>制图和制表，展示变量的分布情况、时间序列数据的变化趋势以及变量之间的关系。</li></ol><p>总体：在每一个特定的大数据分析问题中，问题有关对象（个体）所构成的集合即为待研究问题的总体</p><p>样本：从总体中抽取的若干个个体，具有随机性和独立性</p><h2 id="数据分布"><a href="#数据分布" class="headerlink" title="数据分布"></a>数据分布</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658eac0355f28.png"></p><table><thead><tr><th>集中趋势</th><th>离散程度</th><th>形状变化</th></tr></thead><tbody><tr><td>平均数，中位数，分位数，众数</td><td>方差和标准差，极差和四分位差，异众比率，变异系数</td><td>峰度，偏度</td></tr></tbody></table><p>异众比率：非众数组的频率占总频数的比率</p><p>变异系数：原始数据标准差和原始数据平均数的比，当系数大于15%的时候，数据可能不正常</p><p>峰度：描述总体中所有取值 分布形态陡峭程度or平坦程度</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658eac69b144b.png"></p><p>偏度：描述的是某总体取值分布的对称性</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658eac69b5733.png"></p><h2 id="参数估计（点估计）"><a href="#参数估计（点估计）" class="headerlink" title="参数估计（点估计）"></a>参数估计（点估计）</h2><p>用样本统计量θ的某个取值直接作为总体参数θ的估计值</p><p>简单来说，就是用样本指标直接估计总体指标</p><p>指标为某个特征值：如数学期望、方差和相关系数等</p><h3 id="矩估计"><a href="#矩估计" class="headerlink" title="矩估计"></a>矩估计</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658eacf80d225.png"></p><p>一阶原点矩：期望（平均数）</p><p>二阶中心矩：方差</p><p>三阶中心矩：偏度</p><p>四阶中心矩：峰度</p><h3 id="最小二乘估计（LSE）"><a href="#最小二乘估计（LSE）" class="headerlink" title="最小二乘估计（LSE）"></a>最小二乘估计（LSE）</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658eaef6bc851.png"></p><p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658eaef70c7c7.png"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658eaef70a787.png"> </p><h3 id="极大似然估计（MLE）"><a href="#极大似然估计（MLE）" class="headerlink" title="极大似然估计（MLE）"></a>极大似然估计（MLE）</h3><p>思想：利用已知的样本结果信息，反推最具有可能（最大概率）导致这些样本结果出现的模型参数值</p><p>目标：概率分布函数或者似然函数最大；用似然函数取到最大值时的参数值作为估计值</p><p>过程：</p><ol><li>取一个模型，参数未定</li><li>代入变量</li><li>取对数</li><li>解一个最好的参数使得式子最大</li></ol><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658eb5878ca37.jpg"></p><h3 id="最大后验概率估计（MAP）"><a href="#最大后验概率估计（MAP）" class="headerlink" title="最大后验概率估计（MAP）"></a>最大后验概率估计（MAP）</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658eb54be4fda.png"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658eb54ba91db.png"></p><p>区别：在极大似然（MLE）下新增了先验知识（假设），考虑了先验概率</p><p>当先验分布均匀时，MAP 估计与MLE 相等</p><p>先验分布的选择是重要的，根据先验分布决定先验概率</p><p>优点：</p><ul><li>引入先验知识</li><li>在小数据量下更稳定</li></ul><p>缺点：</p><ul><li>和MLE一样，只返回参数的单值估计</li><li>当用不同的参数去表示同一分布时，MAP会对超参数很敏感</li></ul><h3 id="点估计的数量型指标"><a href="#点估计的数量型指标" class="headerlink" title="点估计的数量型指标"></a>点估计的数量型指标</h3><ul><li>平均绝对误差（MAE）</li><li>均方误差(MSE)</li><li>均方根误差(RMSE)【最常用】</li></ul><h2 id="假设检验"><a href="#假设检验" class="headerlink" title="假设检验"></a>假设检验</h2><h3 id="假设检验与参数估计"><a href="#假设检验与参数估计" class="headerlink" title="假设检验与参数估计"></a>假设检验与参数估计</h3><p>相同：都利用样本对总体进行推断，采用的技术手段相似；<br>不同：推断的出发点不同，结果也不同</p><ul><li>参数估计：用样本的统计来来估计总体参数的推断方法，待估计的总体参数在估计前是未知的</li><li>假设检验：先对待估计的总体参数提出一个假设，再利用样本去检验该假设是否成立【逻辑上是反证法】</li></ul><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>一般有两个假设：</p><p>原假设H0：想要拒绝的假设</p><p>备择假设H1：想要接收的假设</p><p>H0和H1不一定是事件的全集，而与实际研究目的相关，具有主观性</p><p>两类错误：</p><p>第一类错误，弃真α：H0成立时，拒绝了H0</p><p>第二类错误，取伪β：H0错误时(H1成立)，接收了H0</p><p>α 错误的犯错率为置信度，降低置信度就可以降低α 错误的犯错率<br>β错误则是由很多客观因素造成的，难以明确表示</p><p>首先要降低α 错误</p><p>增大样本量可以使得两类错误同时减小</p><h2 id="抽样方法"><a href="#抽样方法" class="headerlink" title="抽样方法"></a>抽样方法</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li><p>非概率抽样<br>抽取样本时不是依据随机原则，而是根据研究目的对数据的要求，采用某种方式从总体中抽出部分单位对其实施调查</p><p>缺点：抽取样本有主观性，使结果有偏差；不可能计算各个元素的入样概率，无法得到可靠的估计值及抽样误差估计值，不能推断总体</p></li><li><p>等概率抽样<br>每一个单元的入样概率均相等；</p><p>常见的有：简单随机抽样，系统抽样，分层抽样，整群抽样等等</p><p>系统抽样是在总样本数过多时，随机取一部分，再进行简单随机抽样</p><p>根据某个特性进行分层，层间差距大，层内差距小，按比例抽取来满足等概率<br>整群抽样是直接一次性抽取所需样本数，但需要满足群内差异大，群外差异小的特性</p></li><li><p>不等概率抽样<br>如果总体单元相差较大，等概率抽样效果不一定好</p><p>eg.估计合肥市商业零售总额，大型商场、中型超市和小型商店的差别非常明显，平等对待显然不合理</p><p>分层抽样：按规模分层，大型抽样比高、小型抽样比低<br>目录抽样：少数大单元普查而大多数小单元进行抽样</p></li></ul><h3 id="大数据why需要抽样"><a href="#大数据why需要抽样" class="headerlink" title="大数据why需要抽样"></a>大数据why需要抽样</h3><ul><li>节省时间和算力，提高效率；因为样本整体的结果有时候是不可得的，或者获取成本太高</li><li>解决样本不均衡问题；通过对大类数据进行欠抽样，小类数据进行过抽样，从而使得数据比例达到实验预期</li><li>在定性工作上往往还是由人力来完成，抽样减少数据量才有可能由人力进行处理</li></ul><h1 id="第八讲-数据分析—机器学习"><a href="#第八讲-数据分析—机器学习" class="headerlink" title="第八讲 数据分析—机器学习"></a>第八讲 数据分析—机器学习</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658eb6a6d8c3a.jpg"></p><p>机器学习是人工智能的子领域，它研究如何教给计算机自我学习的能力，而不是让机器按照固定的程序运行</p><p>机器学习是使用训练数据对模型进行学习，训练，优化的过程，最终利用模型对其他数据进行预测和判断的方法。</p><h2 id="机器学习的基本流程"><a href="#机器学习的基本流程" class="headerlink" title="机器学习的基本流程"></a>机器学习的基本流程</h2><ol><li>业务场景分析<ul><li>对业务场景进行分析，了解业务痛点问题，分析机器学习是否适用于该问题</li><li>把业务需求抽象成机器学习问题，如分类、聚类、回归、降维等应用场景</li></ul></li><li>数据处理<ul><li>进行数据清洗，数据集成，数据变换等操作来获取数据</li><li>特征工程，获取高质量特征</li></ul></li><li>训练机器学习模型和评价<ul><li>切分数据集为训练集和测试集</li><li>根据选择的算法进行训练，得到模型</li><li>使用测试集对模型进行评估</li></ul></li><li>使用机器学习模型<ul><li>使用模型对新遇到的数据样本进行预测</li></ul></li></ol><h2 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h2><ul><li>实体数字化：比如婚否的取值有是、否两种可能，所以它是类别型数据，我们用1、0表示是和否<br>这里可能因为度量单位不同等，需要进行数据变换</li><li>文本数字化：0&#x2F;1表示法（每个词有则1，无则0），计数法（重要的词具有更高的值而不止是1），TF-IDF<br>相似的问题：语义鸿沟——解决：N—Gram技术【不考】</li><li>图的数字化：数据结构：邻接矩阵，邻接链表，边列表</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658eb9fea701c.png"></p><ul><li>图像数字化：RGB</li></ul><h2 id="统计和机器学习"><a href="#统计和机器学习" class="headerlink" title="统计和机器学习"></a>统计和机器学习</h2><p>统计：</p><ul><li>只能刻画总体，而不能刻画细节规律</li><li>坚实的数学理论基础，有严密的逻辑性，其结果能用公式给出，结果精确，可解释性强</li><li>建模技巧性强，对假设依赖强，有时难以满足现实情况</li></ul><p>机器学习</p><ul><li>能刻画系统局部细节特征</li><li>基于归纳推理，无需苛刻的假设【反过来则难以解释，需要进一步验证规则，同时，难以推广到其他业务领域】</li><li>能从中反应发现新的规律，且具有较高实时性【反过来模型时效性强】</li></ul><h2 id="机器学习常用方法"><a href="#机器学习常用方法" class="headerlink" title="机器学习常用方法"></a>机器学习常用方法</h2><h3 id="回归模型"><a href="#回归模型" class="headerlink" title="回归模型"></a>回归模型</h3><ul><li>一元线性回归</li><li>逻辑斯蒂回归模型（sigmoid）</li></ul><p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658ebb2ad1162.jpg"></p><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>用于刻画预测结果的优异程度</p><ul><li>均方误差（mean squared error, MSE）</li><li>平均绝对误差（mean absolute error, MAE）</li></ul><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>目标是最小化&#x2F;最大化目标函数，方法是优化参数</p><ul><li>梯度下降（根据斜率下降）</li></ul><h3 id="分类问题"><a href="#分类问题" class="headerlink" title="分类问题"></a>分类问题</h3><h4 id="SVM向量机"><a href="#SVM向量机" class="headerlink" title="SVM向量机"></a>SVM向量机</h4><p>找一个线性函数，可以把输入分成预期的两类</p><p>SVM的目标是分类间隔最大化</p><p>但不一定在本维度线性可分【why 核函数】</p><p>核函数：将样本映射到高维空间，使其基本线性可分【what|how 核函数】</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658ebb950afa1.png"></p><h4 id="Pre感知机"><a href="#Pre感知机" class="headerlink" title="Pre感知机"></a>Pre感知机</h4><p>现代神经网络的雏形，但没有激活函数，所以感知机是一种线性分类模型，属于判别模型</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658ebbad2ae4a.png"></p><table><thead><tr><th></th><th>SVM向量机</th><th>Pre感知机</th></tr></thead><tbody><tr><td>目标</td><td>分类间隔最大化</td><td>最大程度正确划分，最小化错误</td></tr><tr><td>过拟合</td><td>一定程度上避免</td><td>很容易造成过拟合</td></tr><tr><td>学习策略</td><td>拉格朗日函数</td><td>梯度下降</td></tr></tbody></table><h4 id="逻辑斯蒂回归（sigmoid）"><a href="#逻辑斯蒂回归（sigmoid）" class="headerlink" title="逻辑斯蒂回归（sigmoid）"></a>逻辑斯蒂回归（sigmoid）</h4><p>该函数把样本特征的线性组合映射到了（0，1）上</p><p>函数的值具有特殊的含义，它表示结果取类别1的概率</p><h4 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h4><p>均匀分布时，熵最大为log2C</p><p>确定分布时，熵最小为0</p><p>条件熵就是根据分类比例加权的算法</p><p>找一个点进行分割，算得的条件熵前后比较即可得出信息增益</p><h5 id="决策树优点"><a href="#决策树优点" class="headerlink" title="决策树优点"></a>决策树优点</h5><ul><li>可以接收类别型特征【重要】</li><li>分类效果与其他算法相当</li><li>训练，测试效率高</li></ul><h5 id="决策树构建"><a href="#决策树构建" class="headerlink" title="决策树构建"></a>决策树构建</h5><p>全局最优是一个NP—Hard问题</p><p>所以需要启发式算法进行训练</p><p>一个方法是用贪心算法</p><ul><li>每次分类都选择信息增益最大的特征，对训练数据进行划分【类别型就直接选特征，数值型选特征后需要确定阈值】</li><li>当训练样本都属于一个类别，或者没有更多样本和特征时停止</li></ul><h5 id="过拟合"><a href="#过拟合" class="headerlink" title="过拟合"></a>过拟合</h5><p>机器学习算法拟合噪声数据，而不是数据中的有意义规律</p><p>现象：在训练数据上得到的精度，远大于在测试数据上得到的精度</p><p>原因：</p><ul><li><p>训练数据量太少【数据单一】</p></li><li><p>模型过于复杂，模型参数过多</p></li><li><p>决策树：太深、节点太多</p></li><li><p>解决方案：</p><p>增加训练数据，降低模型复杂度</p><p>决策树：剪枝，减少节点数量</p></li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658ebc4e6fdb7.png"></p><h1 id="第九讲-数据分析—神经网络"><a href="#第九讲-数据分析—神经网络" class="headerlink" title="第九讲 数据分析—神经网络"></a>第九讲 数据分析—神经网络</h1><p>输入层——N个隐藏层——输出层</p><p>隐藏层内有很多神经元，每个神经元都有激活函数如sigmoid，tanh等</p><p>也可以不使用激活函数，但结果就只能是线性的了</p><h2 id="前向传导"><a href="#前向传导" class="headerlink" title="前向传导"></a>前向传导</h2><p>计算输出值的过程，称为前向传导，也叫前向传播，</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658ebcc6ae6db.png"></p><h2 id="反向传播"><a href="#反向传播" class="headerlink" title="反向传播"></a>反向传播</h2><p>反向传播仅指用于计算梯度的方法</p><p>反向传播是拿来算Loss函数对于每个参数的偏微分的</p><p>然后用结果修正参数表</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658ebd06eac96.jpg"></p><p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658ebd06ec9af.jpg"></p><p>最后修正参数就行了，η是学习率，超参数，越大学习越快，代价是可能难以逼近最低点（梯度下降）</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658ebd06bb260.jpg"></p><h1 id="第十讲-数据可视化"><a href="#第十讲-数据可视化" class="headerlink" title="第十讲 数据可视化"></a>第十讲 数据可视化</h1><h2 id="数据可视化作用"><a href="#数据可视化作用" class="headerlink" title="数据可视化作用"></a>数据可视化作用</h2><ul><li>协助思考</li><li>使用感知代替认知</li><li>作为大量工作记忆的外界辅助</li><li>增强认知能力</li></ul><h2 id="数据可视化方法和技术"><a href="#数据可视化方法和技术" class="headerlink" title="数据可视化方法和技术"></a>数据可视化方法和技术</h2><ul><li><p>图可视化技术</p><ul><li><p>节点链接图</p><p>可以直接反应出网络关系，图的总体结构及其路径</p><p>但对密集图不适用</p></li><li><p>相邻矩阵法</p><p>完全规避边的交叉，非常适用于致密的图，且伸缩性强</p><p>可视化效果比较抽象，难以跟踪路径</p></li></ul></li><li><p>统计图表可视化</p></li><li><p>地理数据可视化</p><ul><li>点数据可视化</li><li>线数据可视化</li><li>区域数据可视化</li></ul></li><li><p>文本可视化</p><p>作用：文本可视化将文本中蕴含的语义特征（词频、逻辑结构、主题聚类、动态演化规律等）直观的展示出来</p></li><li><p>时空数据可视化</p><p>一维二维三维标量场数据可视化</p></li></ul><h2 id="数据可视化工具"><a href="#数据可视化工具" class="headerlink" title="数据可视化工具"></a>数据可视化工具</h2><p>Google Charts，Echarts，D3.js，neo4j bloom，R，Processing 等</p><h1 id="第十一讲-文本处理"><a href="#第十一讲-文本处理" class="headerlink" title="第十一讲 文本处理"></a>第十一讲 文本处理</h1><h2 id="总纲"><a href="#总纲" class="headerlink" title="总纲"></a>总纲</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658ebdc6e4d11.jpg"></p><h2 id="数据获取【网页抓取】"><a href="#数据获取【网页抓取】" class="headerlink" title="数据获取【网页抓取】"></a>数据获取【网页抓取】</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/29/658ebddceae4a.jpg"></p><p>提升性能：异步抓取，DNS预解析</p><p>链接调度：累积式抓取，增量式抓取【搜索引擎的日常抓取】</p><p>重复检测：I-Match算法</p><p>爬虫：robots.txt（友好访问|存放于网站根目录下的ASCII编码的文本文件，它通常告诉网络搜索引擎的漫游器内容是否能被获取）</p><p>恶意爬虫危害：</p><ul><li>增加网站带宽负担</li><li>核心文本被爬取</li><li>注册用户被扫描（一个个验证手机号看是否注册）</li><li>点击欺诈（不知道真实的访问量）</li></ul><h2 id="数据处理【中文分词】"><a href="#数据处理【中文分词】" class="headerlink" title="数据处理【中文分词】"></a>数据处理【中文分词】</h2><p>中文基于单字，中文书面表达方式以汉字作为最小单位的，但词与词之间没有显性的界限标志</p><p>词法分析包含：</p><ol><li>分词</li><li>词性标注（名词，动词，形容词等）</li><li>命名实体识别</li><li>词义消歧</li></ol><p>分词的意义</p><p>正确的机器自动分词是正确的中文信息处理的基础</p><p>分词主要难题</p><ul><li>如何识别未登录词</li><li>如何利用语言学知识</li><li>词语边界歧义处理【分词歧义】</li><li>实时性应用中的效率问题</li></ul><p>分词主要方法</p><table><thead><tr><th></th><th>基于人工规则</th><th>基于统计机器学习</th><th>基于深度学习</th></tr></thead><tbody><tr><td>优点</td><td>简单、可理解、结果可控</td><td>数据驱动，应用广泛</td><td>精度高</td></tr><tr><td>缺点</td><td>规则维护困难，分词精度欠佳</td><td>高质量训练数据获取昂贵，特征工程</td><td>可解释性差，需要海量训练数据</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 大学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据科学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SDU软件学院软件工程考试纲要</title>
      <link href="/2023/12/19/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%80%83%E8%AF%95%E7%BA%B2%E8%A6%81/"/>
      <url>/2023/12/19/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%80%83%E8%AF%95%E7%BA%B2%E8%A6%81/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文档是根据任课老师所给提纲及课件等资料进行整理的，对于名词解释和简答题基本做到了全覆盖。但判断和选择题非常灵活，这份文档就显得不够用了。</p><p>标题后带*号的为次重点</p></blockquote><blockquote><p>复习建议：<br>1.按照老师纲要整理知识点，全文背诵。<br>2.注意对概念的理解，应对选择判断</p></blockquote><h1 id="第一章-软件工程概述"><a href="#第一章-软件工程概述" class="headerlink" title="第一章 软件工程概述"></a>第一章 软件工程概述</h1><h2 id="1-1软件工程（SE）的定义、目的、方法及作用"><a href="#1-1软件工程（SE）的定义、目的、方法及作用" class="headerlink" title="1.1软件工程（SE）的定义、目的、方法及作用"></a>1.1软件工程（SE）的定义、目的、方法及作用</h2><p>定义：在将有关软件开发与应用的概念科学体系化的基础上，研究如何有计划、有效率、 经济地开发和利用能在计算机上正确运行的软件理论和技术工程的方法学，以及一些开发和维护软件的方法、过程、原则等。它是一个系统工程，既有对技术问题的综合分析，也有对开发过程和参与者的管理。</p><p>目的：以计算机科学理论和计算机功能为基础，通过对要解决问题的本质的了解，采用相应的工具和技术，实现设计方案，推出高质量的软件产品。在给定成本、进度的前提下，开发出具有适用性、有效性、可修改性、可靠性、可理解性、可维护性、可重用性、可移植性、可追踪性、可互操作性和满足用户需求的软件产品。追求这些目标有助于提高软件产品的质量和开发效率，减少维护的困难。</p><p>方法：面向对象模式，结构化模式，基于过程的模式等。</p><p>作用：付出较低的开发成本，达到要求的软件功能，取得较好的软件性能，开发的软件易于移植，需要较低的维护费用，能按时完成开发工作，及时交付使用。</p><h2 id="1-2-开发模式"><a href="#1-2-开发模式" class="headerlink" title="1.2*开发模式"></a>1.2*开发模式</h2><p>表示开发软件时特定的方法或哲学。是软件开发的全部过程，活动和任务的结构框架，它能直观的表达的表达软件开发全过程，明确要完成的主要活动，任务和开发策略。</p><h2 id="1-3说明错误、缺陷、失败的含义与联系（并举例）"><a href="#1-3说明错误、缺陷、失败的含义与联系（并举例）" class="headerlink" title="1.3说明错误、缺陷、失败的含义与联系（并举例）"></a>1.3说明错误、缺陷、失败的含义与联系（并举例）</h2><p>错误(error)：是在软件开发过程中人为产生的错误（需求说明中的错误，代码中的错误）。</p><p>缺陷&#x2F;故障(fault)：软件功能实现过程中产生的问题，是错误导致的结果，是软件中一个错误的表现（一个错误可能产生多个故障，静态存在，如代码写错了导致系统无法启动）。</p><p>失效(failure)：相对于系统指定行为的偏离，在运行时系统违背了它应有的行为（在系统交付前或交付后被发现，动态存在，如使用者发现某个计算功能算不出结果）。</p><p>联系：人为原因导致程序错误；该错误编译到系统中导致系统故障；用户使用该系统时，因故障导致失效。故障是系统内部视图，从开发者的角度看待问题；失效是系统外部视图， 从用户角度看到的问题。而且并不是所有的故障会导致失效，只要不执行故障代码，或者不进入某个特定状态，那么故障就不会使代码失效。</p><h2 id="1-4软件质量应从哪几个方面来衡量，论述之"><a href="#1-4软件质量应从哪几个方面来衡量，论述之" class="headerlink" title="1.4软件质量应从哪几个方面来衡量，论述之"></a>1.4软件质量应从哪几个方面来衡量，论述之</h2><p>1.产品(product)的质量</p><p>​用户：从失效的数目和类型等外部特性进行评价，如果软件具有足够的功能，并且易于学习和使用；或者虽然难以学习和使用，但是由于功能值得这些付出，用户就断定软件是高质量的。</p><p>​开发者：从故障的数目和类型等内部特征来作为产品质量的依据。</p><p>2.过程(process)的质量</p><p>​有很多过程都会影响到最终的产品质量，只要有活动出了差错，产品的质量就会受到影响；开发和维护过程的质量与产品的质量是同等重要的。</p><p>3.商业(business)环境背景下的质量</p><p>​（1）技术价值与商业价值的联系与区别：</p><p>​技术价值：技术指标（速度，正确的运行时间，维护成本等）。<br>​商业价值：机构对软件是否与其战略利益相吻合的一种价值评估。<br>​误区：技术质量不会自动转化为商业价值。</p><p>​（2）目标</p><p>​将技术价值和商业价值统一起来，改进过程所带来的商业价值。</p><h2 id="1-5软件系统的系统组成（系统的要素有哪些）"><a href="#1-5软件系统的系统组成（系统的要素有哪些）" class="headerlink" title="1.5软件系统的系统组成（系统的要素有哪些）"></a>1.5软件系统的系统组成（系统的要素有哪些）</h2><p>系统 &#x3D; 对象（实体）+ 活动 + 关系 + 系统边界</p><p>对象：活动中涉及的元素称为对象。</p><p>活动：活动是发生在系统中的某些事情，通常描述为由某个触发器引发的事件，活动通过改变属性把一个事物变成另一个事物。</p><p>关系：是指活动与对象之间的关系。</p><p>系统边界：即系统包含的功能与系统不包含的功能之间的界限。</p><h2 id="1-6现代软件工程大致包含的几个阶段及各个阶段文档"><a href="#1-6现代软件工程大致包含的几个阶段及各个阶段文档" class="headerlink" title="1.6现代软件工程大致包含的几个阶段及各个阶段文档"></a>1.6现代软件工程大致包含的几个阶段及各个阶段文档</h2><ol><li>需求分析：包括问题定义、可行性研究、需求分析【《SRS》即《软件需求规格 说明书》】与复审（所有人）。</li><li>系统设计：包括用户界面的设计【《SAD》即《软件系统结构图》：如何制作软 件】与复审（开发者与客户）。</li><li>程序设计：包括模块功能算法与数据描述设计【相关文档】与复审（开发者）。</li><li>程序实现：包括编程与 debug【源代码和注释】与复审（开发者、码农）。</li><li>单元测试：模块功能测试与性能测试【测试报告】与复审（测试团队）。</li><li>集成测试：按照结构图进行测试【测试报告】与复审（测试团队）。</li><li>系统测试：按《SRS》对系统总体功能进行测试与复审（开发者与客户）。</li><li>系统提交：交付产品【用户手册和操作手册】与复审。</li><li>系统维修：修改软件的过程，为改错或满足新需求【维修报告】与复审（维修团 队）。</li></ol><h2 id="1-7-使现代软件工程实践发生变化的关键因素是什么"><a href="#1-7-使现代软件工程实践发生变化的关键因素是什么" class="headerlink" title="1.7*使现代软件工程实践发生变化的关键因素是什么"></a>1.7*使现代软件工程实践发生变化的关键因素是什么</h2><p>（1）商用产品投入市场时间的紧迫性<br>（2）计算技术在经济中的转变：更低的硬件成本，更高的开发、维护成本<br>（3）功能强大的桌面计算的可用性<br>（4）广泛的局域网和广域网<br>（5）面向对象技术的采用及其有效性<br>（6）使用窗口、图标、菜单和指示器的图形用户界面<br>（7）软件开发瀑布模型的不可预测性</p><h2 id="1-8什么是软件过程？软件过程的重要性是什么？包含几个阶段？"><a href="#1-8什么是软件过程？软件过程的重要性是什么？包含几个阶段？" class="headerlink" title="1.8什么是软件过程？软件过程的重要性是什么？包含几个阶段？"></a>1.8什么是软件过程？软件过程的重要性是什么？包含几个阶段？</h2><p>软件开发活动中的各种组织及规范方法（课件定义）</p><p>软件开发过程描述了软件产品从概念到实现、交付、使用和维护的整个过程，因此，有时把软件开发过程称为软件生命周期。</p><p>（1）它强制活动具有一致性和一定的结构。<br>（2）过程结构允许我们分析、理解、控制和改进组成过程的活动，并以此来指导我们的活动。<br>（3）它使我们获取经验并把经验传授给他人。</p><h2 id="1-9什么是重用、抽象等现代软件工程主要概念？"><a href="#1-9什么是重用、抽象等现代软件工程主要概念？" class="headerlink" title="1.9什么是重用、抽象等现代软件工程主要概念？"></a>1.9什么是重用、抽象等现代软件工程主要概念？</h2><p>抽象(abstraction)：基于某种层次归纳水平的问题描述。它使我们将注意力集中在问题的关键方面而非细节。</p><p>分析、设计方法和符号描述系统：使用标准表示来对程序进行描述。利于交流，利于建模并检查其完整性和一致性，利于 对需求和设计部件进行重用。</p><p>用户界面原型化(prototyping)：建立系统的小型版, 通常具有有限的关键功能,以利于用户评价和选择，证明设计或方法的可行性。</p><p>软件体系结构：定义一组体系结构单元及其相互关系集来描述软件系统。 单元分解的方法</p><p>软件过程：软件开发活动中的各种组织及规范方法。</p><p>重用或复用(reuse)：重复采用以前开发的软件系统中具有共性的部件, 用到新的开发项目中去 (注: 这里的重用绝不仅仅是源代码的重用)。</p><p>测度或度量(measurement)：通用的评价方法和体系，有助于使过程和产品的特定特性更加可见，包括量化描述系统、量化审核系统。</p><p>工具和集成环境：通过框架比较软件工程环境提供的服务，以决定其好坏。工具：由于厂商很少针对整个开发生命周期，因此对于工具的比较集中于小的活动集，例如测试或设计。</p><h1 id="第二章-过程和生命周期的建模"><a href="#第二章-过程和生命周期的建模" class="headerlink" title="第二章 过程和生命周期的建模"></a>第二章 过程和生命周期的建模</h1><h2 id="2-1什么叫过程（生命周期）"><a href="#2-1什么叫过程（生命周期）" class="headerlink" title="2.1什么叫过程（生命周期）"></a>2.1什么叫过程（生命周期）</h2><p>过程是一组有序的任务，它涉及活动、约束和资源使用的一系列步骤，用于产生某种想要的输出。<br>过程不仅仅是步骤，过程是步骤的集合，它将步骤组织起来使人们能够生产满足一系列目标和标准的产品。<br>我们有时也把涉及产品构建的这种过程称为生命周期。软件开发过程描述了软件产品从概念到实现、交付、使用和维护的整个过程，因此，有时把软件开发过程称为软件生命周期。</p><h2 id="2-2什么是软件过程？软件过程的重要性是什么？软件生命周期？"><a href="#2-2什么是软件过程？软件过程的重要性是什么？软件生命周期？" class="headerlink" title="2.2什么是软件过程？软件过程的重要性是什么？软件生命周期？"></a>2.2什么是软件过程？软件过程的重要性是什么？软件生命周期？</h2><p>软件开发活动中产生某种期望结果的一系列有序任务，涉及活动、约束和资源。</p><ol><li><p>通用性，一致性，结构性。一致性和结构性可以使我们知道是否已经做好了工作，还能使别人以同样的方式做工作，因而具有相对通用性。</p></li><li><p>自我指导。总结经验，完善规范，指导新版本</p></li><li><p>过程改进；流程改善 process improvement</p></li></ol><p>软件生命周期：问题定义及规划阶段，需求分析&#x2F;评审阶段，软件设计阶段，软件编码阶段，软件测试阶段，软件运行维护阶段。 1、需求分析2、系统设计3、程序设计4、软件开发5、单元测试6、集成测试7、系统测试8、系统提交9、维护</p><h2 id="2-3瀑布模型及各阶段文档，优缺点"><a href="#2-3瀑布模型及各阶段文档，优缺点" class="headerlink" title="2.3瀑布模型及各阶段文档，优缺点"></a>2.3瀑布模型及各阶段文档，优缺点</h2><p>瀑布模型：瀑布模型线性地安排每一个阶段，将开发阶段描述为从一个开发阶段瀑布般地转换到另外一个阶段，一个开发阶段必须在另一个开发阶段开始之前完成。瀑布模型从一种非常高层的角度描述了开发过程中进行的活动，并且提出了要求开发人员经过的时间序列。</p><p>瀑布模型的各阶段文档：<br>需求分析：《SRS》软件需求规格说明书<br>系统设计：《SAD》系统设计文档<br>程序设计：模块功能算法和数据描述文档<br>编码：源程序和注释<br>单元测试和集成测试：单元测试报告<br>系统测试：系统测试报告<br>验收测试：验收测试报告<br>运行与维护：维护报告</p><p>优点</p><p>（1）它的简单性使得开发人员很容易向不熟悉软件开发的客户作出解释。<br>（2）每一个过程活动都有与其相关联的里程碑和可交付产品，以便于项目经理评估项目 进度。<br>（3）瀑布模型是最基础的模型，很多其他更复杂的模型实际上是在瀑布模型的基础上的润色，如加入反馈循环以及额外的活动。</p><p>缺点</p><p>（1）除了一些理解非常充分的问题之外，实际上软件是通过大量的迭代进行开发的。<br>（2）软件是一个创造的过程, 不是一个制造的过程。软件变动时, 该模型无法处理实际过程中的重复开发问题。<br>（3）文档转换有困难。它说明了每一个活动的产品（例如，需求、设计或代码），但没有揭示一个活动如何把一种制品转化为另外一种制品（例如，从需求文档转化为设计文档）。</p><h2 id="2-4原型的概念与用途"><a href="#2-4原型的概念与用途" class="headerlink" title="2.4原型的概念与用途"></a>2.4原型的概念与用途</h2><p>原型是一种部分开发的产品，用来让用户和开发者共同研究，提出意见，为最终产品定型。原型可以理解为小样，在某一阶段产品定型前先做一些小样，通过对各种样品的评价和分析，并最终为产品定型。</p><p>用途：<br>1.原型化设计可以使开发者更容易地提高软件质量。<br>2.原型化设计可以提供多种解决方案供用户选择。</p><h2 id="2-5论述分阶段（阶段化）开发模型的含义、其基本分类和特点（运行系统和开发系统的概念）"><a href="#2-5论述分阶段（阶段化）开发模型的含义、其基本分类和特点（运行系统和开发系统的概念）" class="headerlink" title="2.5论述分阶段（阶段化）开发模型的含义、其基本分类和特点（运行系统和开发系统的概念）"></a>2.5论述分阶段（阶段化）开发模型的含义、其基本分类和特点（运行系统和开发系统的概念）</h2><p>含义：系统被设计成部分提交, 每次用户只能得到部分功能, 而其他部分处于开发过程中。</p><p>cycle time(循环时间): 软件开发时整理需求文档时间与系统提交时间之差(P55)<br>production system(产品系统): 用户正在使用的版本<br>development system(开发系统): 准备代替现有产品系统的下一个版本</p><p>分类：</p><p>（1）增量开发：系统需求按照功能分成若干子系统，开始建造的版本是规模小的、部分功能的系统，后续版本添加包含新功能的子系统，最后版本是包含全部功能的子系统集。<br>（2）迭代开发：系统开始就提供了整体功能框架，后续版本陆续增强各个子系统，最后版本使各个子系统的功能达到最强。<br>（3）增量式+迭代式结合开发：一个新发布的版本可能包含新功能，并对已有功能做了改进。</p><p>特点：</p><p>（1）即使还缺少某些功能，但在早期的发布中就可以开始培训。<br>（2）可以及早为那些以前从未提供的功能开拓市场。<br>（3）当运行系统出现未预料到的问题时，经常性的发布可以使开发人员能全面、快速地修复这些问题<br>（4）针对不同的发布版本，开发团队将重点放在不同的专业领域技术上。</p><h2 id="2-6螺旋模型的含义、目的、四个象限的任务及四重迭代（四重循环）的含义"><a href="#2-6螺旋模型的含义、目的、四个象限的任务及四重迭代（四重循环）的含义" class="headerlink" title="2.6螺旋模型的含义、目的、四个象限的任务及四重迭代（四重循环）的含义"></a>2.6螺旋模型的含义、目的、四个象限的任务及四重迭代（四重循环）的含义</h2><p>含义：螺旋模型将瀑布模型和快速原型模型结合起来，强调了其他模型所忽视的风险分析，特别适合于大型复杂的系统。</p><p>目的：把开发活动和风险管理结合起来，以将风险减到最小并控制风险。</p><p>螺旋模型每次迭代有四个任务，依次是（四个象限）：计划、目标&#x2F;可选方案、风险评估、开发与测试。</p><p>螺旋模型共有四次迭代，依次是（每个象限的四重循环），依次是操作概念、软件需求、软件设计、开发与测试、系统实现与执行</p><p>每一次迭代都根据需求和约束进行风险分析，以权衡不同选择，并且在确定选择之前，通过原型化验证可行性和期望度。当风险确认之后，项目经理必须决定如何消除或最小化风险。</p><p>&#x2F;&#x2F;在所有的软件开发模型中，你认为哪些过程给予你最大的灵活性以应对需求的变更？<br>阶段开发模型和螺旋模型</p><h2 id="2-7什么是UP，-RUP，进化式迭代等市场流行的过程模型"><a href="#2-7什么是UP，-RUP，进化式迭代等市场流行的过程模型" class="headerlink" title="2.7什么是UP， RUP，进化式迭代等市场流行的过程模型"></a>2.7什么是UP， RUP，进化式迭代等市场流行的过程模型</h2><p>UP模型即统一过程模型，是一种用例驱动的，以基础架构为中心的，迭代式，增量式的软件开发模型。该模型的四个阶段：开始阶段、确立阶段、构建阶段和移交阶段。每个阶段可以进一步划分为多次迭代。该模型的六道核心工序：业务模型工序、需求工序、分析设计工序、实现工序、测试工序和部署工序。</p><p>补充:统一过程（UP）可以用三句话来表达：它是用例驱动的、以基本架构为中心的、迭代式和增量性的软件开发过程框架，它使用对象管理组织（OMG(Object Management Group)）的UML 并与对象管理组织（OMG）的软件过程工程原模型（SPEM（Software Process Engineering Meta-Model ）软件过程工程元模型）等相兼容。</p><p>RUP（Rational Unified Process），是IBM提出的提供支持和包装的UP模型。统一软件开发过程，统一软件过程是一个面向对象且基于网络的程序开发方法论。</p><p>进化式迭代开发（Iterative development）是统一开发过程(RUP)的关键实践。开发被组织成一系列固定的短期小项目。每次迭代都产生经过测试、集成并可执行的局部系统。每次迭代都具有各自的需求分析、设计、实现和测试。随着时间和一次次迭代，系统增量式完善。</p><h1 id="第三章-计划和管理项目"><a href="#第三章-计划和管理项目" class="headerlink" title="第三章 计划和管理项目"></a>第三章 计划和管理项目</h1><h2 id="3-1什么是项目进度？活动？里程碑？项目成本？"><a href="#3-1什么是项目进度？活动？里程碑？项目成本？" class="headerlink" title="3.1什么是项目进度？活动？里程碑？项目成本？"></a>3.1什么是项目进度？活动？里程碑？项目成本？</h2><p>项目进度：名词解释是对特定项目的软件开发周期的刻画。包括对项目阶段、步骤、活动的分解，对各个离散活动的交互关系的描述，以及对各个活动完成时间及整个项目完成时间的初步估算。</p><p>活动：项目的一部分，一般占用项目进度计划中的一段时间</p><p>里程碑（Milestone）指特定的时间点，标志着活动的结束，通常伴随着提交物。（如一般性文档，功能模块的说明，子系统的说明和展示，精确度的说明和展示，可靠性，安全性，性能说明或展示文档）</p><p>项目成本(project costs)：为支持软件开发而购买软件和工具的开支,用于支持需求分析,设计,编码,测试,处理需求变更等等,另外加上工作量开支。</p><h2 id="3-2如何计算软件项目活动图的关键路径？冗余时间？最早和最迟开始时间"><a href="#3-2如何计算软件项目活动图的关键路径？冗余时间？最早和最迟开始时间" class="headerlink" title="3.2如何计算软件项目活动图的关键路径？冗余时间？最早和最迟开始时间"></a>3.2如何计算软件项目活动图的关键路径？冗余时间？最早和最迟开始时间</h2><p>关键路径（Critical Paths）：从起点到终点总花费时间最长的路径，即这个项目的最短完成时间，因为如果这条路径无法完成那么整个项目都不能算完成。所以这条路径上的任务耽误一点都会影响最后项目完 成时间。</p><p>关键路径法（CPM）：时差&#x3D;可用时间-真实时间&#x3D;最晚开始时间-最早开始时间</p><p>冗余时间：在不耽误总体进度的前提下，最早开始工作和最晚开始工作时间的差值。</p><h2 id="3-3-软件团队人员应该具备的能力是什么"><a href="#3-3-软件团队人员应该具备的能力是什么" class="headerlink" title="3.3*软件团队人员应该具备的能力是什么"></a>3.3*软件团队人员应该具备的能力是什么</h2><p>（1）完成工作的能力（2）对工作的兴趣（3）开发类似应用的经验（4）使用类似工具或语言的经验（5）使用类似开发环境的经验（6）使用类似技术的经验（7）培训（8）与其他人交流的能力（9）与其他人共同承担责任的能力（10）管理技能</p><h2 id="3-4软件项目团队组织的基本结构"><a href="#3-4软件项目团队组织的基本结构" class="headerlink" title="3.4软件项目团队组织的基本结构"></a>3.4软件项目团队组织的基本结构</h2><p>主程序员：总体负责系统的设计和开发，其他小组成员向该主程序员汇报，主程序员对每一个决定有最终决策权。主程序员监督所有其他小组成员、设计所有程序、把代码开发分配给其他小组成员。<br>副主程序员（后备程序员）：在必要时替代主程序员。<br>资料员：负责维护所有的项目文档，编译和链接代码，并对提交的所有模块进行初步测试。</p><p>(1) 主程序员负责制（Chief Programmer Team）<br>由一个主程序员负责系统设计和开发，其他的成员向其汇报，主程序员对每一个决定有绝对决策权。<br>优势：使交流最小化迅速做出决定<br>缺点：创造性低；对主程序员要求高，个人主观性强<br>(2) 忘我方法（Egoless Approach）<br>每个成员平等的承担责任，而且过程与个人是分开的；批评是针对产品和结果的，不针 对个人的。<br>一般软件项目的团队组织结构是介于以上两个极端之间的。<br>(3) 项目组织的结构化<br>结构化较强的团队：按时完成任务，单工作比较循规蹈矩，项目普通但是功能完备。适合人员较多，项目稳 定性和一致性高，使用较正规的结构。<br>结构化较弱的团队：不能按时完成任务但是创造性强，涉及大量的不确定性因素时采用较为民主的方法和相关的团队结构</p><h2 id="3-5-专家估算法的大致含义"><a href="#3-5-专家估算法的大致含义" class="headerlink" title="3.5*专家估算法的大致含义"></a>3.5*专家估算法的大致含义</h2><p>很多工作量估算方法依赖于专家的判断。使用专家的知识和经验，对软件项目的工作量进行评估，预测的精确性基于估算者的能力、经验、客观性和洞察力。是对构建整个系统或其子系统所需的工作量做出经验性的猜测。<br>主要有类推法，Delphi技术，Wolwerton模型（该模型受变化和主观性的影响，还受当前数据相关性的影响 ）（x+4y+z）&#x2F;6对个人估算的规范化</p><h2 id="3-6-算式估算法的大致含义"><a href="#3-6-算式估算法的大致含义" class="headerlink" title="3.6*算式估算法的大致含义"></a>3.6*算式估算法的大致含义</h2><p>研究人员已经创建出表示工作量和影响工作量的因素之间关系的模型。这些模型通常用方程式描述，其中工作量是因变量，而其他因素是自变量。大部分模型认为项目规模是方程式中影响最大的因素，表示工作量的方程式是：E &#x3D; (a + bS^c) m(X)<br>其中S是系统规模的估算，而a、b、和c是常量。X是从x1到xn的一个成本因素的向量，m是基于这些因素的一个调整因子。</p><h2 id="3-7试述COCOMO模型的三个阶段基本工作原理或含义"><a href="#3-7试述COCOMO模型的三个阶段基本工作原理或含义" class="headerlink" title="3.7试述COCOMO模型的三个阶段基本工作原理或含义"></a>3.7试述COCOMO模型的三个阶段基本工作原理或含义</h2><p>COCOMO 模型的关键在于针对项目开发的不同阶段来设置工作量的衡量标准，逐步细化， 逐渐准确。E &#x3D; bSc m(X)</p><ul><li>在阶段一，项目通常构建原型以解决包含用户界面、软件和系统交互、性能和技术成熟 性等方面在内的高风险问题。这时，人们对正在创建的最终产品可能的规模知之甚少，因此COCOMOⅡ用应用点来估算规模。</li><li>在阶段二，即早期设计阶段，已经决定将项目开发向前推进，但是设计人员必须研究几种可选的体系结构和操作的概念。同样，仍然没有足够的信息支持准确的工作量和工期估算， 但是远比第一阶段知道的信息要多。在阶段二，COCOMOⅡ使用功能点对规模进行测量。</li><li>在阶段三，即后体系结构阶段，开发已经开始，而且已经知道了更多的信息。在这个阶 段，可以根据功能点或代码行来进行规模估算，而且可以较为轻松地估算很多成本因素。</li></ul><h2 id="3-8什么是软件风险？-了解主要风险管理活动？有几种降低风险的策略？"><a href="#3-8什么是软件风险？-了解主要风险管理活动？有几种降低风险的策略？" class="headerlink" title="3.8什么是软件风险？ 了解主要风险管理活动？有几种降低风险的策略？"></a>3.8什么是软件风险？ 了解主要风险管理活动？有几种降低风险的策略？</h2><p>概念：软件生产过程中不希望看到的，有负面结果的事件。<br>方面：风险损失，风险概率（相乘为风险暴露Risk Exposure)，即数学期望）</p><p>风险管理活动：<br>风险评价：风险识别，风险分析，风险优先级分配<br>风险控制：风险降低，风险管理计划，风险化解。</p><p>降低风险的策略：<br>避免风险（Avoiding the risk）：改变功能和性能需求，使风险没机会发生。比如用 C 语言的程序有内存泄漏的风险改用 Java，避免风险。<br>转移风险（Transferring the risk）：通过把风险分配到其他系统中，或者购买保险以便在风险成为事实时弥补经济上的损失。<br>假设风险（Assuming the risk）：用项目资源，接受并控制风险。比如在开发时主动有意识地进行测试。</p><h2 id="3-9弄懂活动图基本原理，找出关键路径。"><a href="#3-9弄懂活动图基本原理，找出关键路径。" class="headerlink" title="3.9弄懂活动图基本原理，找出关键路径。"></a>3.9弄懂活动图基本原理，找出关键路径。</h2><h1 id="第四章-获取需求"><a href="#第四章-获取需求" class="headerlink" title="第四章 获取需求"></a>第四章 获取需求</h1><h2 id="4-1需求的含义是什么"><a href="#4-1需求的含义是什么" class="headerlink" title="4.1需求的含义是什么"></a>4.1需求的含义是什么</h2><p>需求：对来自用户的关于软件系统的期望行为的综合描述，涉及系统的对象、状态、约束、功能等。</p><h2 id="4-2需求阶段作为一个工程，其确定需求的过程是什么？"><a href="#4-2需求阶段作为一个工程，其确定需求的过程是什么？" class="headerlink" title="4.2需求阶段作为一个工程，其确定需求的过程是什么？"></a>4.2需求阶段作为一个工程，其确定需求的过程是什么？</h2><ol><li>原始需求获取：客户给出的需求</li><li>问题分析：理解需求并通过建模或模型化方式进行描述</li><li>规格说明草稿：利用符号描述系统将定义规范化表示</li><li>需求核准：开发人员与客户进行核准</li><li>软件规格说明（SRS）</li></ol><h2 id="4-3举例说明获取需求时，若有冲突发生时，如何考虑根据优先级进行需求分类"><a href="#4-3举例说明获取需求时，若有冲突发生时，如何考虑根据优先级进行需求分类" class="headerlink" title="4.3举例说明获取需求时，若有冲突发生时，如何考虑根据优先级进行需求分类"></a>4.3举例说明获取需求时，若有冲突发生时，如何考虑根据优先级进行需求分类</h2><p>请求客户对需求进行优先级划分通常是有用的，这可以迫使客户思考提议的服务或特征中哪些是最重要的。<br>一种大致的优先计划分方案可能将需求分为3类：<br>（1）必须要满足的需求<br>（2）非常值得做但是不是必须的需求<br>（3）可选的需求（可做可不做）</p><p>举例：信用卡记账系统必须能够列出最近的费用，将他们加起来并要求在某个日期前支付，这是必须的需求。但是，该记账系统也可能按照购买类型区分费用，以帮助消费者理解购买的模式，这是值得要的需求。最后，记账系统可能要求用黑色来打印贷方账目，用红颜色打印借方账目，这用需求是有用的，但它是可选的需求。</p><p>按照类型对需求进行优先级的分类，能够帮助所有相关人员理解自己到底需要什么。当软件开发项目受到时间或资源的限制时，如果系统的成本太高或者开发的时间太长，就可以去掉可选需求，并对值得要的需求进行分析，考虑是去掉还是延期。还可解决与质量需求之间的矛盾。</p><h2 id="4-4-如何使需求变得可测试"><a href="#4-4-如何使需求变得可测试" class="headerlink" title="4.4*如何使需求变得可测试"></a>4.4*如何使需求变得可测试</h2><p>（1）指定每个副词和形容词的定量描述，这样限定词的含义就清楚、明确了<br>（2）用特定实体的名称替换代名词<br>（3）要确保在需求文档的某个地方，正确地定义每个名词。</p><h2 id="4-5需求文档分为哪两类？"><a href="#4-5需求文档分为哪两类？" class="headerlink" title="4.5需求文档分为哪两类？"></a>4.5需求文档分为哪两类？</h2><p>(1) 需求定义: 完整罗列了客户期望的需求</p><p>(2) 需求规格说明（SRS）: 将需求重述为关于要构建的系统将如何运转的规格说明。</p><h2 id="4-6什么是功能性需求和非功能性需求-质量需求"><a href="#4-6什么是功能性需求和非功能性需求-质量需求" class="headerlink" title="4.6什么是功能性需求和非功能性需求&#x2F;质量需求"></a>4.6什么是功能性需求和非功能性需求&#x2F;质量需求</h2><p>功能需求：描述系统内部功能或系统与外部功能的交互作用，涉及系统输入应对、实体状态变化、输出结果、设计约束、过程约束等。根据要求的活动来描述需求的行为。（功能需求定义问题解决方案空间的边界）</p><p>非功能需求（质量需求）：描述软件方案必须具备的某些质量特征，例如系统性能、安全性、快速的响应时间、易使用性、高可靠性或低维护代价等。</p><h2 id="4-7什么是设计约束和过程约束？如何区分？"><a href="#4-7什么是设计约束和过程约束？如何区分？" class="headerlink" title="4.7什么是设计约束和过程约束？如何区分？"></a>4.7什么是设计约束和过程约束？如何区分？</h2><p>设计约束：已经做出的设计决策或限制问题解决方案集的设计决策。涵盖物理环境、接口、用户等方面。<br>物理环境：对环境或设备的限制等（安装及环境要求等）<br>接口：涉及输入输出的限制或约束条件. (输入格式预定等)<br>用户：使用者的基本情况（限定几种类型的用户）</p><p>过程约束：对用于构建系统的技术和资源的限制，涵盖资源、文档、标准等方面。<br>资源 ：材料、人员技能或其它。<br>文档 ：类型、数量或其它。（涉及其针对性及要求等）<br>标准 ：比如阅读文档时的用户指派标准。<br>其他 ：什么原因会导致从工资单列表中删除某雇员？</p><h2 id="4-8-需求的特征："><a href="#4-8-需求的特征：" class="headerlink" title="4.8*需求的特征："></a>4.8*需求的特征：</h2><p>（1）正确性（2）一致性（3）无二义性（确定性）（4）完备性（5）可行性（6）相关性（7）可测试性（8）可跟踪性</p><h2 id="4-9-在原型化需求方面，什么是抛弃式原型，什么是进化式原型？"><a href="#4-9-在原型化需求方面，什么是抛弃式原型，什么是进化式原型？" class="headerlink" title="4.9*在原型化需求方面，什么是抛弃式原型，什么是进化式原型？"></a>4.9*在原型化需求方面，什么是抛弃式原型，什么是进化式原型？</h2><p>原型化需求的目的：A: 有的需求难以用文字和符号说明,而原型化的过程可帮助我们找到“好的视觉和感觉”B：对非功能性需求，可以评价性能和效率</p><p>抛弃式原型：仅用于了解问题、探索可行性，并不打算用来作为将来实际提交系统的一部分，而是用完扔掉<br>进化式原型：用于了解问题，并作为将来准备提交的系统的一部分<br>这两种技术有时都称为快速原型化，因为它们都是为了回答需求的问题而构建软件。</p><h2 id="4-10了解DFD图-数据流图-的构成及画法。"><a href="#4-10了解DFD图-数据流图-的构成及画法。" class="headerlink" title="4.10了解DFD图 数据流图 的构成及画法。"></a>4.10了解DFD图 数据流图 的构成及画法。</h2><p>数据流图：描述数据进入、转换、离开系统，重点在于数据流，而不是控制流。<br>组成数据流图的四种成分是（源点或终点）、（数据流）、（处理）、（数据存储）<br>描述数据如何流入系统，如何进行转换，以及如何离开系统。<br>加工：○<br>数据流向：→<br>数据集合：&#x3D;<br>外部项：□</p><h1 id="第五章-设计体系结构"><a href="#第五章-设计体系结构" class="headerlink" title="第五章 设计体系结构"></a>第五章 设计体系结构</h1><h2 id="5-1什么是软件体系结构？设计模式？设计公约？设计？"><a href="#5-1什么是软件体系结构？设计模式？设计公约？设计？" class="headerlink" title="5.1什么是软件体系结构？设计模式？设计公约？设计？"></a>5.1什么是软件体系结构？设计模式？设计公约？设计？</h2><p>体系结构 Architecture:一种软件解决方案，用于解释如何将系统分解为单元， 以及单元如何相互关联，还包括这些单元的所有外部特性。</p><p>设计模式 design pattern:一种针对单个软件模块或少量模块而给出的一般性解决方案，它提供较低层次的设计决策。它是一个共同的设计结构的关键方面，包括对象和实例， 角色和协作，责任分配</p><p>设计公约 Design Convention:一系列设计决策和建议的集合，用于提高系统某方面的设计质量。当一种设计公约发展成熟时，将会被封装成设计模式或体系结构风格，最后可 能被内嵌为一种程序语言结构</p><p>设计 Design:将需求中的问题描述转变成软件解决方案的创造性过程。概念设计（告诉客户系统将做什么，软件结构和功能）、技术设计（告诉程序员系统将如何运作，软件功能和接口的实现方法）</p><h2 id="5-2-什么是概念设计？什么是技术设计？"><a href="#5-2-什么是概念设计？什么是技术设计？" class="headerlink" title="5.2*什么是概念设计？什么是技术设计？"></a>5.2*什么是概念设计？什么是技术设计？</h2><p>概念设计：确切地告诉客户系统要做什么<br>技术设计：一旦客户认可概念设计，系统构建人员就将概念设计转换为更为详细的文档，即技术设计，技术设计确切的告诉开发人员系统将如何运转。<br>概念设计强调的是系统功能，而技术设计描述的是系统将要采取的方式。</p><h2 id="5-3软件设计过程模型的几个阶段？"><a href="#5-3软件设计过程模型的几个阶段？" class="headerlink" title="5.3软件设计过程模型的几个阶段？"></a>5.3软件设计过程模型的几个阶段？</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/24/6587e89b393cf.png"></p><p>(1) Modeling 初始建模:尝试可能的分解，根据需求描述的系统的关键特性等确定软件体系结构风格<br>(2) Analysis 分析:分析初步的体系结构，主要关注软件系统的质量属性性能、安全性、可靠性等、各种约束等等。关注系统级别决策<br>(3) Documentation 文档化:确定各个不同的模型视图。<br>(4) Review 复审:检查文档是否满足了所有需求。<br>(5) final output输出文档: SAD:Software Architecture Document 软件体系结构文档， 用来和开发团队中其他人员交流系统级别设计决策的有力工具。</p><h2 id="5-4-三种设计层及其关系"><a href="#5-4-三种设计层及其关系" class="headerlink" title="5.4*三种设计层及其关系"></a>5.4*三种设计层及其关系</h2><p>设计分三层：体系结构、代码设计和可执行设计<br>（1）体系结构将需求格式说明中确定的系统能力与实现这些能力的系统构件关联起来。<br>（2）代码设计包含算法和数据结构<br>（3）可执行设计在比代码设计的层次还要低的静态层次处理代码设计，讨论内存分配、数据格式、位模式等</p><p>关系：自顶向下设计有益的：首先设计体系结构，然后进行代码设计，最后是可执行设计</p><h2 id="5-5-什么是模块化？什么是抽象？"><a href="#5-5-什么是模块化？什么是抽象？" class="headerlink" title="5.5*什么是模块化？什么是抽象？"></a>5.5*什么是模块化？什么是抽象？</h2><p>模块化：在模块化的设计中，构件清晰地定义了输入和输出，设计目标明确，功能独立，可以做独立测试。</p><p>抽象：对细节的隐藏称为抽象，是基于某种归纳水平的问题描述，是我们集中于问题的关系。</p><h2 id="5-6论述设计用户界面应考虑的问题。"><a href="#5-6论述设计用户界面应考虑的问题。" class="headerlink" title="5.6论述设计用户界面应考虑的问题。"></a>5.6论述设计用户界面应考虑的问题。</h2><p>(1)设计界面要注意解决的要素：<br>①隐喻：可识别和学习的基本术语、图像和概念等<br>②思维模型：数据、功能、任务的组织与表示<br>③模型的导航规则：怎样在数据、功能、活动和角色中移动及切换<br>④外观：系统向用户传输信息的外观特征<br>⑤感觉：向用户提供有吸引力的体验的交互技术</p><p>(2) 文化问题：需要考虑使用系统的用户的信仰、价值观、道德规范、传统、风俗和传说。两种解决方法：①使用国际设计&#x2F;无偏见设计，排除特定的文化参考或偏见②采用定制界面，使不同用户看到额界面</p><p>(3) 用户偏爱：为具有不同偏好的人选择备选界面</p><h2 id="5-7—-模块独立性—-耦合与内聚的概念及各个层次划分？"><a href="#5-7—-模块独立性—-耦合与内聚的概念及各个层次划分？" class="headerlink" title="5.7—-模块独立性—-耦合与内聚的概念及各个层次划分？"></a>5.7—-模块独立性—-耦合与内聚的概念及各个层次划分？</h2><p>模块的独立性取决于两个部分：内聚和耦合，我们追求的是高内聚低耦合。<br>内聚是软件内部组成成分的关联程度。<br>耦合指的是两个软件间的关联程度。</p><p><strong>耦合度</strong>是指两个软件之间的相互关联程度，耦合程度取决于模块之间的依赖关系的多少，可以划分为紧密耦合、松散耦合和非耦合。模块之间的依赖关系有：一个模块引用另一个模块、模块间传递数据量、某个模块控制其他模块的数量。为了使模块可以独立设计和修改，应尽可能减少耦合度。模块耦合有六个级别，从高到底依次为：</p><p>(1) 内容耦合 content：一个模块实际上修改了另一个模块，被修改的模块完全依赖于修改他的模块。可能的情况有：一个模块修改另一个模块内部数据项或代码，或分支转移 到另一个模块。如 goto 语句<br>(2) 公共耦合 common：不同模块可以从公共数据存储区来访问和修改数据。<br>(3) 控制耦合 control：一个模块通过传递参数或返回代码来控制另一个模块的活动<br>(4) 标记&#x2F;特征耦合 stamp：使用一个复杂的数据结构进行模块间传递消息，并且传递的是该数据结构本身。比如将一个数组传递给另一个模块，数组仅用于计算而非控制<br>(5) 数据耦合 data：模块间传递的是数据值，这是最受欢迎的一种耦合。如一个数值被当做参数传递给另一个模块，这个数值在另一个模块中只会参与计算而非控制。<br>(6) 非耦合 uncoupled：模块相互之间没有信息传递，如两个毫无关系的方法，但是一般完全没有耦合是不现实的。</p><p><strong>内聚度</strong>是指模块内部各组成成分（如数据、功能、内部模块）的关联程度，内聚度越高， 模块各成分间相互联系越密切，与总目标越相关。内聚分为低内聚和高内聚。</p><p>(1) 偶然内聚 coincidental：模块各部分不相关，只为方便或偶然性原因放入同一模块。比如强行放入一个类中没有任何关系的方法<br>(2) 逻辑内聚 logical：模块中各部分只通过代码的逻辑结构相关联， 会共享程序状态和代码结构，但相对于数据、功能和目标的内聚比较弱。比如因为有相同的某一个计算步骤而放在 一起的两个没有关系的计算。<br>(3) 时间内聚 temporal：部件各部分要求在同一时间完成或被同一任务使用而形成联系。比如初始化模块中需要完成变量赋值、打开某文件等工作。<br>(4) 过程内聚 procedurally：要求必须按照某个确定的顺序执行一系列功能，模块内功能组合在一起只是为了确保这个顺序。其与时间性内聚相比优点在于其功能总是涉及相关 活动和针对相关目标，如写数据-&gt;检查数据-&gt;操作数据这一过程<br>(5) 通讯内聚 communicational：各部分访问和操作同一数据集，如将来自于同一传感器的所有不相干数据取出这一模块<br>(6) 顺序内聚 sequential：各部分有输入输出关系，操作统一数据集，并且操作有顺序<br>(7) 功能内聚 functional：理想情况，各部分组成单一功能，且每个处理元素对功能都是必须的，每个元素执行且只执行设计功能，如一个简单的输出程序<br>(8) 信息内聚 information：功能内聚的基础上调整为数据抽象化和基于对象的设计</p><h2 id="5-8软件过程中复审的概念，设计复审的重要性。"><a href="#5-8软件过程中复审的概念，设计复审的重要性。" class="headerlink" title="5.8软件过程中复审的概念，设计复审的重要性。"></a>5.8软件过程中复审的概念，设计复审的重要性。</h2><p>复审定义：检查文档是否满足所有功能及质量需求。</p><p>两种设计检验的方法：<br>(1) 验证verification：确保设计遵循良好的设计原则，设计文档满足阅读者的需要。验证检查某样东西是否符合之前已定好的标准，就是要用数据证明我们是不是在正确的制造产品。更注重过程正确性，强调做得正确<br>(2)确认validation：确认设计能够满足用户需求。确认检查软件在最终的运行环境上是否达到预期的目标，就是要用数据证明我们是不是制造了正确的产品。更注重结果正确 性，强调做的东西正确。<br>(3)验证更多是从开发商角度来做评审、测试来验证产品需求、架构设计等方面是否和用户要求一致，确认更多是从用户的角度或者可以是模拟用户角度来验证产品是否和自己想 要的一致。</p><p>重要性：<br>(1) 复审中批评和讨论是“忘我”的，能将开发人员更好地团结在一起，提倡并增强了成员之间的交流。<br>(2) 在评审过程中故障的改正还比较容易，成本还不高，在这时候发现故障和问题会使每一个人受益。</p><p>概念设计复审：与客户和用户一起审查概念设计<br>技术设计复审：向开发者介绍技术设计<br>程序设计复审：程序员在实施前获得对其技术设计的反馈<br>重要性：加强和鼓励在项目中使用一种共同的编码风格，发现自动测试发现不了的错误</p><h1 id="第六章-面向对象"><a href="#第六章-面向对象" class="headerlink" title="第六章 面向对象"></a>第六章 面向对象</h1><p>&#x2F;&#x2F;什么是面向对象？<br>面向对象是一种软件开发方法，它将问题和问题的解决方案组织为离散对象的集合，数据结构和行为都包含在对象的表示中。</p><p>&#x2F;&#x2F;面向对象有什么特征？如何使用高级语言实现这些基本&#x2F;&#x2F; 特征？<br>（1）标识（2）抽象（3）分类（4）封装（5）继承（6）多态（7）持久性</p><p>&#x2F;&#x2F; 掌握并使用高级语言的OO基本编程方法和技巧。</p><h2 id="6-1什么是设计模式？"><a href="#6-1什么是设计模式？" class="headerlink" title="6.1什么是设计模式？"></a>6.1什么是设计模式？</h2><p>设计模式是一套被反复使用的（多数人知晓并经过分类编目的）代码设计经验的总结，使用设计模式目的是为了可重用代码、让代码更容易被他人理解并且保证软件质量。<br>（软件开发方法：一种针对软件模块给出的一般性解决方案，提供较低层次的设计决策。）</p><p>面向对象设计模式：简单工厂模式、工厂方法模式、抽象工程模式、观察者模式、单例模式、桥梁模式、责任链模式、适配器模式、代理模式、策略模式</p><h2 id="6-2了解OO设计的基本原则？"><a href="#6-2了解OO设计的基本原则？" class="headerlink" title="6.2了解OO设计的基本原则？"></a>6.2了解OO设计的基本原则？</h2><p>单一职责原则（SRP）、重用原则、开闭原则（OCP）、里氏替换原则（LSP）、依赖倒置原则（DIP）、接口分隔原则（ISP）、迪米特法则</p><h2 id="6-3了解OO开发有何优势？"><a href="#6-3了解OO开发有何优势？" class="headerlink" title="6.3了解OO开发有何优势？"></a>6.3了解OO开发有何优势？</h2><p>（1）语言的一致性。采用相同的语义结构（类、对象、接口、属性、行为）描述问题和解决方案<br>（2）过程的一致性。全开发过程的一致性：从需求分析和定义、高层设计、底层设计到编码和测试等，所有的过程都采用相同的语义结构。</p><h2 id="6-4OO开发过程有几个步骤？"><a href="#6-4OO开发过程有几个步骤？" class="headerlink" title="6.4OO开发过程有几个步骤？"></a>6.4OO开发过程有几个步骤？</h2><p>OO 需求分析和定义+OO 高层设计+OO 底层设计+OOP+OO<br>测试面向对象需求分析、面向对象高层设计、面向对象底层设计、面向对象编程、面向对象测试。</p><h2 id="6-5掌握用例图的组成和画法，用例的几个要素的含义"><a href="#6-5掌握用例图的组成和画法，用例的几个要素的含义" class="headerlink" title="6.5掌握用例图的组成和画法，用例的几个要素的含义"></a>6.5掌握用例图的组成和画法，用例的几个要素的含义</h2><p>用例图：表示一个用户、外部系统或其他实体和在开发系统的关系</p><p>用例：描述系统提供的特定功能，用椭圆表示（画法：○）<br>执行者：和系统交互的实体（用户、设备或其他），用小人表示（画法：小人）<br>包含：对已定义用例的复用，用以提取公共行为，用带箭头的实线表示（画法：→）<br>扩展：对一个用例的扩展使用，以说明一个不同的或更深入的观点（画法：→ 下面加个extends）</p><h2 id="6-6用例图、类图等针对面向对象的项目开发的意义是什么？"><a href="#6-6用例图、类图等针对面向对象的项目开发的意义是什么？" class="headerlink" title="6.6用例图、类图等针对面向对象的项目开发的意义是什么？"></a>6.6用例图、类图等针对面向对象的项目开发的意义是什么？</h2><p>对功能的完整描述；便于用户、设计者、测试者之间的交流；是系统分析中更多正是建模的基础。<br>用例：描述了应该执行或展示的特定功能<br>用例图：通过建立用户、外部项、其他实体的对话模型，而对系统将要完成的功能进行描述或刻画。<br>这些表示法每种都显现了系统的某个方面，因此相应地，这种表达也提供了对于问题或解决方案的详细描述。</p><h2 id="6-7熟悉类图中各个类之间的基本关系分类及其含义。-状态图的含义及用途。"><a href="#6-7熟悉类图中各个类之间的基本关系分类及其含义。-状态图的含义及用途。" class="headerlink" title="6.7熟悉类图中各个类之间的基本关系分类及其含义。 &#x2F;&#x2F;状态图的含义及用途。"></a>6.7熟悉类图中各个类之间的基本关系分类及其含义。 &#x2F;&#x2F;状态图的含义及用途。</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/24/6587ebe080e0f.png"></p><p>泛化：在一个继承关系中，超类泛化子类。<br>关联：两个类一起出现，并且它们之间的关系必须保持一段时间。<br>聚合：一个类是另外一个类的一部分。松散的部分与整体的关系。聚合关系中的成员对象是整体对象的一部分，但是成员对象可以脱离整体对象存在（此时不会影响整体对象的定义，<br>组装：强的部分与整体的关系。组合关系中整体对象可以控制成员对象的生命周期，一旦整体对象不存在，成员对象也将不存在，两者是共生关系。<br>依赖：一个项的定义发生改变，则会引起另外一个项的改变变化。</p><h2 id="6-8熟悉用例图、类图、状态图等的组成和画法"><a href="#6-8熟悉用例图、类图、状态图等的组成和画法" class="headerlink" title="6.8熟悉用例图、类图、状态图等的组成和画法"></a>6.8熟悉用例图、类图、状态图等的组成和画法</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/24/6587ec652511c.png"></p><p>类图的结构<br>类名：定义一个类<br>属性：用名称、类型、初始值来描述它<br>操作：用名称、参数列表、返回类型来描述它</p><p>类图中各个类之间的基本关系以及画法<br>继承：直线 + 空心三角箭头，子类指向超类<br>包含：直线 + 折线箭头，指向被包含的类（可能是双向的甚至指向本身）<br>聚合（成员对象可以脱离整体对象存在）：在包含箭头的尾部加一个空心菱形<br>组合（整体对象不存在时，成员对象也会消失）：在包含箭头的尾部加一个实心菱形<br>依赖（某个类的方法使用另一个类的对象作为参数）：虚线 + 折线箭头<br>接口实现：虚线 + 空心三角，类指向接口</p><h2 id="6-9了解UML其他图示结构的基本用途"><a href="#6-9了解UML其他图示结构的基本用途" class="headerlink" title="6.9了解UML其他图示结构的基本用途"></a>6.9了解UML其他图示结构的基本用途</h2><p>UML 图示结构的基本用途<br>需求过程：<br>工作流程图：建立对象模型——概念类图<br>对象图：解释每一个对象<br>活动图：当一个对象的值发生变化时，显示系统中可能发生的所有活动<br>状态图：显示一个对象可以采取的所有状态<br>顺序图：显示信息如何从一个对象流向另一个对象，使需求中的事件的非正式描述正规化<br>协作图：使用对象和序列信息来显示对象之间的事件流<br>组件图：反映最终的系统模块和相互依存关系<br>状态图：寻找主要的状态、确定状态之间的转换，细化状态内的活动与转换，用复合状态来展开细节。</p><p>用例图：用函数定义类<br>执行者：可能使用这些用例的人或外部程序。<br>用例：对系统提供的功能（或称系统的用途）的一种描述。</p><p>类图：描述了系统中的类及其相互之间的各种关系，其本质反映了系统中包含的各种对 象的类型及对象间的静态关系（关联、子类型等关系）<br>包图：显示类是如何被划分为模型的。包图也存在类图里面的继承、引用等依赖关系，也包含接口，接口与包之间用带 小圆圈的实线相连。<br>序列图：序列图中的对象可以是并发执行的，每一个对象有自己运行的线程控制着。这时，需 要通过激活、异步消息、同步控制和活动对象来表示。序列图有两种，一种是描述特定对象 之间生存期中消息通信的所有情节，称作一般序列图；一种是描述消息通信的个别情节的实 例序列图，如果需要描述所有的情节，则需要多个实例序列图。<br>部署图：部署图描述了系统在运行时的物理结构、配置和关系，涉及处理器、设备、通讯 等硬件单元和软件部件。部署图的描述是基于代表硬件单元的节点之上的。</p><h1 id="第七章-编写程序"><a href="#第七章-编写程序" class="headerlink" title="第七章 编写程序"></a>第七章 编写程序</h1><h2 id="7-1-为什么说编码工作是纷繁复杂甚至令人气馁？"><a href="#7-1-为什么说编码工作是纷繁复杂甚至令人气馁？" class="headerlink" title="7.1*为什么说编码工作是纷繁复杂甚至令人气馁？"></a>7.1*为什么说编码工作是纷繁复杂甚至令人气馁？</h2><p>（1）设计人员可能没有处理平台和编程环境的所有特性。易于用图表描述的结构和关系并不是总能够直截了当的编写成代码<br>（2）我们必须以这样一种方式编写代码：不仅要在再次使用代码进行测试的时候便于自己理解，而且当系统随着时间演化时，也便于他人理解<br>（3）在创建易于复用的代码的同时，还必须利用这些特征：设计的组织结构、数据结构、编程语言的概念。</p><h2 id="7-2一般性的编程原则应该从哪三个方面考虑？"><a href="#7-2一般性的编程原则应该从哪三个方面考虑？" class="headerlink" title="7.2一般性的编程原则应该从哪三个方面考虑？"></a>7.2一般性的编程原则应该从哪三个方面考虑？</h2><p>（1）控制结构（程序如何传递数据）：当设计转变成代码时，我们希望保留组件的控制结构，在隐含调用的面向对象设计中，控制是基于系统状态和变量而变化的。<br>（2）算法（程序如何处理数据）：在编写代码时，程序设计通常会制定一类算法，用于编写组件。<br>（3）数据结构（程序如何储存数据）：编写程序时，应该安排数据的格式并进行存储，这样的数据管理和操作才能简明易懂。</p><h2 id="7-3-论述编码阶段实现某种算法时所涉及的问题。"><a href="#7-3-论述编码阶段实现某种算法时所涉及的问题。" class="headerlink" title="7.3*论述编码阶段实现某种算法时所涉及的问题。"></a>7.3*论述编码阶段实现某种算法时所涉及的问题。</h2><p>（1）编写更快代码的代价。可能会是代码更加复杂，从而要花费更多的时间编写代码<br>（2）测试代码的时间代价。代码的复杂度要求有更多的测试用例或测试数据<br>（3）用户理解代码的时间代价。<br>（4）需要修改代码时，修改代码的时间代价。</p><h2 id="7-4在编写程序内部文档时，除了HCB外，还应添加什么注释信息？注意什么？"><a href="#7-4在编写程序内部文档时，除了HCB外，还应添加什么注释信息？注意什么？" class="headerlink" title="7.4在编写程序内部文档时，除了HCB外，还应添加什么注释信息？注意什么？"></a>7.4在编写程序内部文档时，除了HCB外，还应添加什么注释信息？注意什么？</h2><p>需要添加其他程序注释<br>（1）解释性注释：本段源代码是在做什么的注释。<br>（2）分解性注释：通过注释将代码分解成多个段。<br>（3）版本注释：随着时间进行修改的记录。</p><p>注意的问题：<br>1、分段注释<br>2、注释和代码要一并更改。<br>3、注释要有意义。<br>4、一边写代码一边写注释，不要写完代码回过头来添加注释。</p><p>内部文档：<br>（1）头注释块（header comment block，HCB）<br>将一组注释信息放在每个构件的开始部分，包含构件名，作者，配置在整个系统设计的哪个部分上，何时编写和修改的，为什么要有该构件，构件是如何使用数据结构，算法和控制的。<br>（2）其他程序注释包含：<br>a. 可以对程序正在做什么提供逐行的解释。<br>b. 将代码分解成表示主要活动的段，每个活动再分解成更小的步骤。<br>c. 随着时间进行修改的记录。<br>（3）有意义的变量名和语句标记<br>命名时尽量用有意义的变量名进行命名<br>（4）安排格式以增强理解<br>注意缩进和间隔来反映基本的控制结构。</p><h2 id="7-5敏捷方法的大致思想？"><a href="#7-5敏捷方法的大致思想？" class="headerlink" title="7.5敏捷方法的大致思想？"></a>7.5敏捷方法的大致思想？</h2><p>含义：以人为核心、迭代、循序渐进。在敏捷开发中，软件项目的构建被切分成多个子项目，各个子项目的成果都经过测试，具备集成和可运行的特征。<br>敏捷宣言四条原则：个体和交互的价值胜过过程和工具（个人的卓越创意），可以工作的软件胜过面面俱到的文档（文档非软件），客户合作胜过合同谈判，响应变化胜过遵循计划。<br>上述四条原则反映了敏捷方法的软件过程倾向性<br>特点：（1）规则游戏（2）小的发布（3）隐喻（4）简单设计（5）首先编写测试（6）重构（7）对编程（8）集体所有权（9）持续集成（10）可以忍受的步伐（11）在现场的客户（12）代码标准<br>目标：通过尽可能早地、持续地交付有价值的软件使客户满意。</p><h2 id="7-6什么是极限编程（Extreme-Programming，XP）？"><a href="#7-6什么是极限编程（Extreme-Programming，XP）？" class="headerlink" title="7.6什么是极限编程（Extreme Programming，ＸＰ）？"></a>7.6什么是极限编程（Extreme Programming，ＸＰ）？</h2><p>极限编程是敏捷过程的一种具体形式，提供敏捷方法最一般原则的指导方针。<br>四个变量：成本、时间、质量和范围，通过研究变量之间的相互作用，将项目开发分析的更加透彻，成功讲述一个项目成功的原则<br>XP的支持者强调敏捷方法的4个特性（准则）：交流、简单性、勇气以及反馈。<br>交流是指客户与开发人员之间持续地交换看法；简单性激励开发人员选择最简单的设计或实现来处理客户的需要；勇气体现在今早地和经常交付功能的承诺；在软件开发过程中的各种活动中，都包含反馈循环。例如，程序员一起工作，针对实现设计的最佳方式，相互提供反馈；客户和程序员一起工作时，以完成计划的任务。</p><h2 id="7-7什么是结对编程-Pair-Programming-？"><a href="#7-7什么是结对编程-Pair-Programming-？" class="headerlink" title="7.7什么是结对编程(Pair Programming)？"></a>7.7什么是结对编程(Pair Programming)？</h2><p>结对编程属于主要的敏捷开发方法，开发方式是两个程序员共同开发程序，且角色分工明确：一个负责编写程序，另一个负责复审和测试，两个人定期交换角色。<br>优点：提高生产率和质量，但证据不充分，模棱两可<br>缺点：会抑制问题求解的基本步骤，扰乱对问题的关注</p><h1 id="第八章-测试程序"><a href="#第八章-测试程序" class="headerlink" title="第八章 测试程序"></a>第八章 测试程序</h1><h2 id="8-1了解产生软件缺陷的原因？"><a href="#8-1了解产生软件缺陷的原因？" class="headerlink" title="8.1了解产生软件缺陷的原因？"></a>8.1了解产生软件缺陷的原因？</h2><p>故障：由错误（error）引起的系统内在问题。</p><p>(1)软件本身，系统处理大量的状态，复杂的公式，活动，算法等；<br>(2)客户不清晰的需求；<br>(3)其他原因，如项目的规模，众多的参与者导致的复杂性。</p><h2 id="8-2-将软件缺陷进行分类的理由？"><a href="#8-2-将软件缺陷进行分类的理由？" class="headerlink" title="8.2*将软件缺陷进行分类的理由？"></a>8.2*将软件缺陷进行分类的理由？</h2><p>在编码完程序构件之后，我们通常对代码进行检查，以找出故障并立刻去除它们。当不存在明显的故障时，我们测试程序，通过创造一些条件，是代码不能像计划的那样做出反应，看一看能否发现更多的故障。因此，知道我们正在查找什么类型的故障是很重要的。</p><h2 id="8-3几种主要的缺陷类型"><a href="#8-3几种主要的缺陷类型" class="headerlink" title="8.3几种主要的缺陷类型"></a>8.3几种主要的缺陷类型</h2><p>(1)算法故障(algorithmic fault)：由于处理步骤中的某些错误，使得对于给定的输入，构件的算法或逻辑没有产生适当的输出。<br>(2)计算故障(computation fault)或精度故障(precision fault)：一个公式的实现是错误的，或者计算结果没有达到要求的精度。<br>(3)文档故障(documentation fault)：文档与程序实际做的事情不一致。<br>(4)压力故障(stress fault)或过载故障(overload fault)：对队列长度、缓冲区大小、表的维度等的使用超出了规定的能力。<br>(5)能力故障(capacity fault)或边界故障(boundary fault)：系统活动到达指定的极限时，系统性能会变得不可接受。<br>(6)时序性故障(timing fault)或协调故障(coordination fault)：几个同时执行或仔细定义顺序执行的进程之间细条不适当。<br>(7)吞吐量故障(throughput fault)或性能故障(performance fault)：系统不能以需求规定的速度执行。<br>(8)恢复性故障(recovery fault)：当系统失效时，不能表现得像设计人员希望的或客户要求的那样。<br>(9)硬件和系统软件故障(hardware and system software fault)：当提供的硬件或者系统软件实际上并没有按照文档中的操作条件或步骤运作时。<br>(10)标准和过程故障(standards and procesure fault)：代码没有遵循组织机构的标准和过程。</p><h2 id="8-4什么是正交缺陷分类？"><a href="#8-4什么是正交缺陷分类？" class="headerlink" title="8.4什么是正交缺陷分类？"></a>8.4什么是正交缺陷分类？</h2><p>定义：被分类的任何一项故障都只属于一个类别，则分类方案是正交的。如果一个故障属于不止一个类，则失去了度量的意义。</p><h2 id="8-5测试的各个阶段及其任务？"><a href="#8-5测试的各个阶段及其任务？" class="headerlink" title="8.5测试的各个阶段及其任务？"></a>8.5测试的各个阶段及其任务？</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/24/6587eded31754.png"></p><p>(1)模块测试(module testing)、构件测试(component testing)或单元测试(unit testing)：将每个程序构件与系统中的其他构件隔离，对其本身进行测试。<br>(2)集成测试(integration testing)：验证系统构件是否能够按照系统和程序设计规格说明中描述的那样共同工作的过程。<br>(3)功能测试(function test)：对系统进行评估，以确定集成的系统是否确实执行了需求规格说明中描述的功能，其结果是一个可运转的系统。<br>(4)性能测试(performance test)：测试系统的软硬件性能是否符合需求规格说明文档。其结果是一个确认的系统。<br>(5)验收测试(acceptance test)：确定系统是按照用户的期望运转的。<br>(6)安装测试(installation test)：确保系统在实际环境中按照应有的方式运转。<br>(7)系统测试(system test)：功能测试、性能测试、验收测试和安装测试统称为系统测试。</p><h2 id="8-6-测试的态度问题？（为什么要独立设置测试团队？）"><a href="#8-6-测试的态度问题？（为什么要独立设置测试团队？）" class="headerlink" title="8.6*测试的态度问题？（为什么要独立设置测试团队？）"></a>8.6*测试的态度问题？（为什么要独立设置测试团队？）</h2><p>新程序员不习惯将测试看做是一个发现的过程，可能仅仅将程序视作问题的解决方案，为没有考虑问题本身。但是客户对系统的在某些条件下能够运行并不感兴趣，相反，他们感兴趣的是确保系统在所有条件下都能适当运行。所以，作为一个开发人员，无论故障出现在系统的何处，也无论是谁引起这些故障，你的目标应该是尽可能多地去除故障。<br>为了从测试过程中排除个人情感，通常是用一个独立的测试小组来测试系统，这样就避免了故障的个人责任与可能多地发现故障的需要之间的冲突。</p><h2 id="8-7掌握测试的方法—-黑盒、白盒的概念？"><a href="#8-7掌握测试的方法—-黑盒、白盒的概念？" class="headerlink" title="8.7掌握测试的方法—-黑盒、白盒的概念？"></a>8.7掌握测试的方法—-黑盒、白盒的概念？</h2><p><strong>黑盒</strong>将测试的对象看作是一个不了解其内容的闭盒，我们的测试就是向闭盒提供输入的数据，并记录产生的输出。测试的目标是确保针对每一种输入，观察到的输出与预期的输出相匹配。<br>定义：测试人员在完全不了解程序内部的逻辑结构和内部特性的情况下，只依据程序的需求规格及设计说明，检查程序的功能是否符合它的功能说明。(备注：1、测试时应该考虑让被测模块完成一切应做的事情, 拒绝一切不应做的事情。2、黑盒测试的参考文档是系统需求、主要文档是系统设计和程序设计阶段文档。若是可重用部件，则是类似系统)<br>优点：黑盒测试免于受强加给测试对象内部结构和逻辑的约束。更偏向于功能性的测试。<br>缺点：黑盒法以 SRS 为依据，有一定的盲目性和不确定性，不可能揭示所有的错误。<br>没办法总是使用这种方式进行完备的测试。不容易找到具有代表性的测试用例证明所有情况 下功能都正确。</p><p><strong>白盒</strong>将测试对象看作一个白盒，然后根据测试对象的结构用不同的方式进行测试。例如，可以设计执行构件内所有语句或所有控制路径的测试用例。<br>定义：以测试对象的内部结构为基本依据，手工或自动的展开各种测试。<br>优点：可以测试一个模块的细节。<br>缺点：该法以模块内部逻辑为依据，当内部逻辑过于复杂时，则不能给出好的或合适的 测试用例。有时候，对于大量递归、循环和分支的构件，想要测试完所有的分支也是不现实的。<br>实际测试中，没有必要把黑盒测试和白盒测试严格的区分开来。具体的测试方法的选择收到很多因素的影响。</p><h2 id="8-8什么是单元测试？"><a href="#8-8什么是单元测试？" class="headerlink" title="8.8什么是单元测试？"></a>8.8什么是单元测试？</h2><p>将每个程序构件与系统中的其他构件隔离，对其本身进行测试。<br>首先，通过通读程序对代码进行检查，试着找出算法、数据以及语法中的故障。甚至可以将代码与规格说明进行比较，与设计进行比较，以确保已经考虑了所有相关情况。接着，编译代码，排除任何剩余的语法故障。最后，开发测试用例，以证明是否将输入适当地转换为所期望的输出。</p><h2 id="8-9-什么是走查和检查？"><a href="#8-9-什么是走查和检查？" class="headerlink" title="8.9*什么是走查和检查？"></a>8.9*什么是走查和检查？</h2><p>走查：不正式的的代码评审。<br>检查：正式的代码评审，事先准备问题清单，依据清单比对代码和文档的一致性。</p><h2 id="8-10黑盒白盒方法各自的分类？测试用例的设计和给出方法。"><a href="#8-10黑盒白盒方法各自的分类？测试用例的设计和给出方法。" class="headerlink" title="8.10黑盒白盒方法各自的分类？测试用例的设计和给出方法。"></a>8.10黑盒白盒方法各自的分类？测试用例的设计和给出方法。</h2><p>黑盒测试方法：<br>1、等价分类法：将输入域划分为若干等价类。每一个测试用例都代表了一类与它等价 的其他例子。如果测试用例没有发现错误，那么对应的等价例子也不会发生错误。有效等价 类的测试用例尽量公用，以此来减少测试次数，无效等价类必须每类一个用例，以防止漏掉 可能发现的错误。<br>2、边界值分析法：在等价分类法中，代表一个类的测试数据可以在这个类的允许范围 内任意选择。但如果把测试值选在等价类的边界上，往住有更好的效果，这就是边界值分析 法的主要思想。<br>3、错误猜测法：猜测程序中哪些地方容易出错，并据此设计测试用例。更多的依赖于 测试人员的直觉和经验。<br>4、因果图法：适用于被测试程序有很多输入条件，程序的输出又依赖输入条件的各种 组合的情况。</p><p>白盒测试方法：<br>逻辑覆盖法<br>1、语句覆盖：程序的每条语句都要执行一次。<br>2、判定(分支)覆盖：程序的每个分支都要执行一次。<br>3、条件覆盖：要求判定中的每个条件均按照“真”、“假”两种结果至少执行一次。<br>4、条件组合覆盖：要求所有条件结果的组合都至少出现一次。(比如 A&amp;&amp;B，两个条件，那么就有四种条件的组合)<br>路径测试法</p><h2 id="8-11如何面对一个命题，设计和给出测试用例的问题。"><a href="#8-11如何面对一个命题，设计和给出测试用例的问题。" class="headerlink" title="8.11如何面对一个命题，设计和给出测试用例的问题。"></a>8.11如何面对一个命题，设计和给出测试用例的问题。</h2><p>1.在集成测试及其后的测试阶段，除去很小的程序，都采用黑盒方法。其策略包括: (1)用边值分析法和(或)等价分类法提出基本的测试用例; (2)用猜错法补充新的测试用例; (3)如果在程序的功能说明中含有输入条件的组合，宜在一开始就用因果图法，然后再按以上(1)、(2)两步进行。</p><p>2.单元测试的设计策略稍有不同。因为在为模块设计测试用例时，可以直接参考模块的源程序。所以单元测试的策略，总是把白盒法与黑盒法结合运用。具体的作法又有 两种:<br>(1)先仿照上述步骤用黑盒法提出一组基本的测试用例，然后用白盒法作验证。 如果发现用黑盒法产生的测试用例未能满足所需的覆盖标准，就用白盒法增补新的测 试用例来满足它们覆盖的标准应根据模块的具体情况确定。对可靠性要求较高的模块， 通常应满足条件组合覆盖或路径覆盖标准。<br>(2)先用白盒法分析模块的逻辑结构，提出一批测试用例，然后根据模块的功能 说明用黑盒法进行补充。<br>在一般情况下，小型单元测试应该大多以白盒方法为主。</p><h2 id="8-12集成测试及其主要方法的分类？（驱动模块、桩模块的概念）"><a href="#8-12集成测试及其主要方法的分类？（驱动模块、桩模块的概念）" class="headerlink" title="8.12集成测试及其主要方法的分类？（驱动模块、桩模块的概念）"></a>8.12集成测试及其主要方法的分类？（驱动模块、桩模块的概念）</h2><p>构件驱动程序：在测试最底层的构件时，因为没有现成的已测试的构件调用底层的待测试构件，所以我们需要编写特定的代码来辅助集成。构件驱动程序就是调用特定构件并向其传递测试用例的程序，即代替上级模块传递测试用例的程序。</p><p>桩(stub)：一种专用程序，用于模拟测试时缺少构件时的活动。桩应答调用序列，并传回输出数据，使测试能够正常的进行下去，即代替下级模块的仿真程序。</p><p>分类：<br>1、自底向上集成<br>含义：使用这种测试方法的时候，每一个处于系统层次中最底层的构件先被单独测试，接着测试的是那些调用了前面已测试构件的构件。反复采用这种方法，直到所有的构件测试完毕。<br>先测试系统最底层的模块，接着测试调用这些底层模块的模块，直到测试完毕。<br>2、自顶向下集成<br>含义：顶层构件通常是一个控制构件，是独立进行测试的。然后将被测构件调用的所有构件组合起来，作为一个更大的单元进行测试。重复这样的操作直到所有的构件都被测试。<br>先测试系统最上层的模块，接着测试顶层模块调用的下层模块，直到测试完毕。<br>3、一次性集成<br>先测试每一个模块，之后将所有模块一并集成。<br>先测试每一个构件，然后将所有的构件一次性的集成。只适用于小型系统。<br>4、三明治集成<br>将系统分成三层，目标层处于中间、目标层上有一层，目标层下有一层。在顶层采用自顶向下的方式集成，在较低层采用自底向上的方式集成，测试集中于目标层。</p><h2 id="8-13传统测试和OO测试有何不同？OO测试有何困难？"><a href="#8-13传统测试和OO测试有何不同？OO测试有何困难？" class="headerlink" title="8.13传统测试和OO测试有何不同？OO测试有何困难？"></a>8.13传统测试和OO测试有何不同？OO测试有何困难？</h2><p>(1)测试用例的充分性：对过程语言而言，当系统改变时，我们可以针对改变测试是否正确，并使用原有的测试用例来验证剩余的功能是否同原来一致。但是面向对象的测试中，我们可能需要编写不同的测试用例。<br>(2)面向对象趋向于小粒度，并且平常存在于构件内的复杂性常常转移到构件之间的接口上。这意味着，其单元测试较为容易，但是集成测试涉及面变得更加广泛。<br>(3)传统测试和面向对象的测试主要集中在：需求分析和验证、测试用例生成、源码分析和覆盖。</p><p>困难：<br>A: 需求验证缺乏工具支持。（很多时候依赖人工）<br>B: 测试工具生成的测试用例，处理OO模型中的对象和方法时，其针对性不强。（某些OO关系是测试工具本身搞不清楚其内在逻辑关系的）<br>C: 传统的测试方法（如环路复杂度等）在评价OO系统的规模和复杂性时，还不是很有效。<br>D: 对象的交互是OO系统复杂性的根源，传统的测试方法和根据作用有限。</p><h2 id="8-14-测试计划涉及的几个步骤？"><a href="#8-14-测试计划涉及的几个步骤？" class="headerlink" title="8.14*测试计划涉及的几个步骤？"></a>8.14*测试计划涉及的几个步骤？</h2><p>(1)制定测试目标<br>(2)设计测试计划<br>(3)编写测试用例(4)测试测试用例<br>(5)执行测试<br>(6)评估测试结果</p><h1 id="第九章-测试系统"><a href="#第九章-测试系统" class="headerlink" title="第九章 测试系统"></a>第九章 测试系统</h1><h2 id="9-1系统测试的主要步骤及各自含义？"><a href="#9-1系统测试的主要步骤及各自含义？" class="headerlink" title="9.1系统测试的主要步骤及各自含义？"></a>9.1系统测试的主要步骤及各自含义？</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/24/6587efcc2ea0c.png"></p><p>(1)功能测试——系统功能需求。根据SRS测试系统功能。<br>(2)性能测试——其他软件需求。根据SRS测试系统性能。<br>(3)验收测试——客户需求规格说明书。根据客户的需求定义，由客户和用户一起测试。<br>(4)安装测试——用户环境。在用户环境下进行测试。</p><h2 id="9-2-什么是系统配置？软件配置管理？基线？"><a href="#9-2-什么是系统配置？软件配置管理？基线？" class="headerlink" title="9.2*什么是系统配置？软件配置管理？基线？"></a>9.2*什么是系统配置？软件配置管理？基线？</h2><p>系统配置：向特定客户交付的一组系统构件</p><p>软件配置管理：开发和测试不同的配置需要配置管理。配置管理控制不同系统配置之间的差别，将风险和错误减少到最低程度。</p><p>基线：是指软件文档和其他资料的集合，它们代表了产品在某一时间点的情况(以及其他参考点)。</p><h2 id="9-3什么是回归测试？"><a href="#9-3什么是回归测试？" class="headerlink" title="9.3什么是回归测试？"></a>9.3什么是回归测试？</h2><p>回归测试是用于新的版本或者改进版本的一种测试，以验证与旧版本相比，软件是否仍然以同样的方式执行同样的功能。</p><h2 id="9-4功能测试的含义极其作用？"><a href="#9-4功能测试的含义极其作用？" class="headerlink" title="9.4功能测试的含义极其作用？"></a>9.4功能测试的含义极其作用？</h2><p>含义：测试需求设计（SRS）中提出的功能性需求。<br>作用：有很高的故障检测概率（因为一项功能测试只面向一小组组件）。</p><h2 id="9-5功能测试的基本指导原则？"><a href="#9-5功能测试的基本指导原则？" class="headerlink" title="9.5功能测试的基本指导原则？"></a>9.5功能测试的基本指导原则？</h2><p>(1)高故障检测概率；<br>(2)使用独立于设计人员和程序员的测试小组；<br>(3)了解期望的动作和输出；<br>(4)既要测试合法输入，也要测试不合法输入；<br>(5)制定停止测试的标准；<br>(6)不能修改系统。</p><h2 id="9-6性能测试的含义与作用？"><a href="#9-6性能测试的含义与作用？" class="headerlink" title="9.6性能测试的含义与作用？"></a>9.6性能测试的含义与作用？</h2><p>性能测试与需求的质量有密切的关系，需求文档需要足够完备才能确保性能测试的成功进行。因此需求的质量通常可以反映在性能测试的容易度上。</p><p>含义：测试非功能性需求。</p><p>作用：确保系统的可靠性、可用性和可维护性。</p><p>性能测试由测试小组进行设计和执行并将结果提供给客户。</p><h2 id="9-7性能测试的主要分类？"><a href="#9-7性能测试的主要分类？" class="headerlink" title="9.7性能测试的主要分类？"></a>9.7性能测试的主要分类？</h2><p>压力测试&#x2F;强度测试(短时间内加载极限负荷，验证系统能力)<br>容量测试&#x2F;巨量数据测试(验证系统处理巨量数据的能力)<br>配置测试(构建测试用例对系统软硬件的各种配置(最小到最大)进行测试)<br>兼容性测试(测试接口等。如果它与其他系统交互时)<br>回归测试(如果这个系统要替代一个现有系统时需要进行此测试)<br>安全性测试：确保安全性需求得到满足。<br>计时测试：评估涉及对用户的响应时间和一个功能的执行时间的相关需求。<br>环境测试：考察系统在安装场所的执行能力。<br>质量测试：评估系统的可靠性、可维护性和可用性。<br>恢复测试：强调的是系统对出现故障或丢失数据、电源、设备或服务时的反应。<br>维护测试：为了帮助人们发现问题的根源提供诊断工具和过程的需要。<br>文档测试：确保已经编写了必需的文档。<br>人为因素测试：检查设计系统用户界面的需求。</p><h2 id="9-8-什么是可靠性、可用性和可维护性？"><a href="#9-8-什么是可靠性、可用性和可维护性？" class="headerlink" title="9.8*什么是可靠性、可用性和可维护性？"></a>9.8*什么是可靠性、可用性和可维护性？</h2><p>可靠性：指一个系统对于给定的时间间隔内、在给定的条件下无失效运作的概率。<br>可用性：指在给定的时间点上，一个系统能够按照规格说明正确运作的概率。<br>可维护性：在给定的使用条件下，在规定的时间间隔内，使用规定的过程和资源完成维护活动的概率。</p><h2 id="9-9确认测试概念，确认测试分类？（基准测试和引导测试）"><a href="#9-9确认测试概念，确认测试分类？（基准测试和引导测试）" class="headerlink" title="9.9确认测试概念，确认测试分类？（基准测试和引导测试）"></a>9.9确认测试概念，确认测试分类？（基准测试和引导测试）</h2><p>由用户检查软件系统是否满足了他们的需求的测试。</p><p>(1)基准测试<br>由用户准备典型测试用例，在实际安装后的系统运作并由用户对系统执行情况进行评估。<br>(2)引导测试(课件译)&#x2F;试验性测试(课本译)<br>在假设系统已经永久安装的前提下执行系统。它依赖系统的日常工作进行测试，相对基准测试不是非常的正式与结构化。</p><h2 id="9-10什么是alpha测试？β测试？"><a href="#9-10什么是alpha测试？β测试？" class="headerlink" title="9.10什么是alpha测试？β测试？"></a>9.10什么是alpha测试？β测试？</h2><p>α测试：在向客户发布一个系统之前，先让来自自己组织机构或公司的用户来测试这个系统。在客户进行实际的试验性测试前，先自己组织团队（或者委托其他团队）测试这个系统。</p><p>β测试：客户实际进行测试。</p><h2 id="9-11什么是安装测试？"><a href="#9-11什么是安装测试？" class="headerlink" title="9.11什么是安装测试？"></a>9.11什么是安装测试？</h2><p>在用户环境中配置系统，以测试可能因为开发环境与用户环境的不同而导致的问题。</p>]]></content>
      
      
      <categories>
          
          <category> 大学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网传输层</title>
      <link href="/2023/12/15/%E8%AE%A1%E7%BD%91%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
      <url>/2023/12/15/%E8%AE%A1%E7%BD%91%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<blockquote><p>经过前面对物理层、数据链路层、网络层的学习，我们明白了如何实现点到点的可靠的传输，明白了网络中的一系列路由算法，走进传输层，我们首先要明白这一层实现的是端到端的可靠的传输，是基于不可靠的网络层之上的。</p><p>为什么之前为确保可靠而使用的超时重传和确认机制在这里会导致不可靠呢？这是因为与简单的主线（Bus）相比，我们这里所处于的是网络之中，网络里的节点是具备缓存能力的，由此可能导致分组的滞留，而简单的超时重传等机制产生的重复分组会在网络通信中引发很大的问题。基于这个现状，我们聪慧的前辈们想出利用选号和三次握手机制建立和拆除TCP 连接的方法克服了网络中重复分组引发的问题，在不可靠的IP 层之上实现的可靠的数据传输协议TCP。</p><p>本章还涉及了UDP 协议的相关内容，与TCP 面向连接、可靠的特点相比较，UDP 是一个无连接的、不可靠的传输层协议。</p></blockquote><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/15/657bfab2207bc.png"></p><p>上图为本章考试重点，非原书结构，仅供参考。</p><h1 id="传输协议的要素"><a href="#传输协议的要素" class="headerlink" title="传输协议的要素"></a>传输协议的要素</h1><h2 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/15/657bfb749f304.png"></p><p>图6-1 是正常的三次握手建立连接的过程。（此图中的ack 值为下一次想要接收的第一个字节编号减一所得，下图亦然）。</p><p>图6-2 这种情况是老的CR（Connection Request）重复分组出现了，它虽然引起了主机2 发送相应的分组，但是主机1 根据主机2 发送分组的ack 值可以发现这是异常情况，所以拒绝（REJECT）。</p><p>图6-3 这种情况是老的CR（Connection Request）重复分组和和老的数据重复分组出现的情况。虽然老的CR 重复分组引起了主机2 发送相应的分组，但是主机1 根据主机2发送分组的ack 值可以发现这是异常情况，产生拒绝（REJECT）；对于数据重复分组。主机2 根据分组的ack 值可以发现这是异常情况。</p><h2 id="断开连接"><a href="#断开连接" class="headerlink" title="断开连接"></a>断开连接</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/15/657bfba6b25e0.png"></p><p>图6-4 是正常的三次握手断开连接的过程。</p><p>图6-5 这种情况是最后主机1 发出的ack 丢失的情况，这时候，当主机2 的计时器时后，主机2 就会释放连接。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/15/657bfc3058fde.png"></p><p>图6-6 这种情况是主机2 给主机1 的DR（Disconnection Request）的应答丢失了，这种情况下，当主机1 的计时器超时后，主机1 会重新发送DR。</p><p>图6-7 这种情况是主机2 给主机1 的DR（Disconnection Request）的应答和主机1后续的DR 都丢失了，这种情况下，主机1 经过N 次重传之后，就会放弃，并且释放连接；而主机2 在计时器超时之后也会释放连接。</p><h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><h2 id="UDP-简介"><a href="#UDP-简介" class="headerlink" title="UDP 简介"></a>UDP 简介</h2><p>UDP（User Datagram Protocol），用户数据报协议。它的协议号是17。</p><h2 id="UDP-的一些特点"><a href="#UDP-的一些特点" class="headerlink" title="UDP 的一些特点"></a>UDP 的一些特点</h2><p>第一，UDP 是无连接的，不可靠的。<br>第二，分组头部开销小。TCP 有20 字节的头部开销，UDP 只有8 字节。UDP 头的布局结构如下所示：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/01/06/6598dbb61486f.jpg"></p><p>第三，UDP 尤其适用的一个领域是在客户-服务器的情形下。<br>第四，UDP 的一个应用是DNS（Domain Name System）&lt;程序与DNS 服务器之间&gt;。<br>第五，UDP 不考虑流控制、错误控制，在收到一个坏的数据段之后它也不重传。所有这些工作都留给用户进程。<br>其他UDP 的相关知识大家请见6.4 节。</p><h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><h2 id="TCP-数据段的头"><a href="#TCP-数据段的头" class="headerlink" title="TCP 数据段的头"></a>TCP 数据段的头</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/01/06/6598dbb62a899.jpg"></p><p>上图显示了TCP 数据段的布局结构，每一行为32 位，即4 个字节。<br>第一行是源端口（Source port）和目标端口（Destination port）信息。<br>第二行是序列号（Sequence number），表示此次发送数据的第一个字节的编号<br>第三行是确认号（Acknowledge number），表示下次想要接收数据的第一个字节的编号。<br>第四行由几个部分组成，第一部分是TCP 头长度（TCP header length），它占4 位，单位是“4 字节”，所以我们可以简单计算一下：24*4B&#x3D;64B（其中有20B 是TCP 数据段的头的固定长度，另外44B 是可选项Options）；第二部分是未使用的4 位域；第三部分是8 个1 位标志：CWR 和ECE 用作拥塞控制的信号、URG 置1 表示使用了紧急指针、ACK 置1 表示确认号字段是有效的、PSH 位表示这是带有PUSH 标志的数据、RST 位被用于重置一个已经混乱的连接(一般而言，如果得到的数据段被设置了RST 位，那说明你这一端有了问题)、SYN 被用于建立连接的过程、FIN 被用于释放一个连接；第四部分是窗口大小（Window size），它表示这个TCP 数据段发送方当前可用的缓冲区大小，表示的是这一方的接收能力。<br>第五行由两部分组成：第一部分是校验和（Checksum），它校验的范围包括TCP数据段的头部、数据以及伪TCP 头，下面我们来看看什么是伪TCP</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/01/06/6598dce5c7ec3.png"></p><p>伪TCP 头的第一行是源地址，第二行是目标地址，第三行由三部分组成：8 位0，TCP的协议号（6）以及TCP 数据段（包括TCP 头）的字节计数。第五行的第二部分是紧急指针（Urgent pointer），它指向一段程序，调用后清除内存里的相关内容。<br>第六行可选项（Options）是可选的，前面我们计算过了，它的长度是0B~44B。</p><h2 id="TCP-连接建立（三次握手）"><a href="#TCP-连接建立（三次握手）" class="headerlink" title="TCP 连接建立（三次握手）"></a>TCP 连接建立（三次握手）</h2><p>TCP 是面向连接的，所以有三个重要阶段：建立连接、使用连接和拆除连接，这一部分我们讨论三次握手法建立TCP 连接。</p><p>由于网络中节点的缓存能力的影响，使得分组可能滞留在网络之中，由于超时重传机制等原因产生的重复分组可能会引起严重的问题，于是<br>我们利用选号和三次握手来保证可靠的传输。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/01/06/6598dce5d72ce.png"></p><p>上图是三次握手建立连接的示意图，通常在第三次发送消息的时候，TCP 数据段里已经携带了数据，故将SYN 位置为了0。在这里我仅是列出了最为重要的SYN、ACK标志位的值</p><h2 id="TCP-连接断开（三次握手）"><a href="#TCP-连接断开（三次握手）" class="headerlink" title="TCP 连接断开（三次握手）"></a>TCP 连接断开（三次握手）</h2><p>下面我们来看一看是如何用三次握手法断开TCP 连接的。抽象图示如下：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/01/06/6598dce5c51a1.png"></p><p>在这里我仅是列出了最为重要的FIN 标志位的值。</p><h2 id="拥塞控制与慢启动算法"><a href="#拥塞控制与慢启动算法" class="headerlink" title="拥塞控制与慢启动算法"></a>拥塞控制与慢启动算法</h2><p>网络的拥塞里存在两个方面的问题，对应着每个发送方维护的两个窗口：网络容量（对应拥塞窗口）和接收方的容量（对应接收方准许的窗口）。拥塞控制的本质是降低发送方的发送速率，所以发送方的速率应该取以上两者里的小值。</p><p>拥塞控制实际上是由网络层（RED）和传输层（TCP 慢启动）共同完成的。接下来让我们一起看看什么是TCP 慢启动。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2024/01/06/6598dbb63038a.jpg"></p><p>以上图示即展示了TCP 慢启动的过程，一开始通过成倍增加（指数级）拥塞窗口的大小不断试探网络连接情况，当到达阈值的时候，开始线性地增长拥塞窗口的大小。当一次超时发生的时候，将阈值设置成为当前拥塞窗口的一半，而拥塞窗口被重置为初始的值。</p><p>拥塞窗口一直增长，直至发生超时或达到接收方准许的窗口大小。<br>让我们再来看看网络层和传输层是如何合作完成拥塞控制，降低发送方的发送速率的。</p><p>当网络中路由器的被使用缓冲区的大小到达路由器的阈值的时候，路由器开始执行RED协议，随意丢弃某些分组，被丢弃的分组的发送方因此会超时，这时通过TCP 慢启动会降低发送方速率。</p>]]></content>
      
      
      <categories>
          
          <category> 大学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程过程和生命周期建模</title>
      <link href="/2023/12/06/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BF%87%E7%A8%8B%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%BB%BA%E6%A8%A1/"/>
      <url>/2023/12/06/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E8%BF%87%E7%A8%8B%E5%92%8C%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%BB%BA%E6%A8%A1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这一章我们要详细分析软件工程中的各种步骤的组织方式，以便我们协调各种活动。面对的主要问题有如何理解过程模型，如何应对软件开发过程中的种种状况，为此我们首先要解释过程模型的意义，然后为大家介绍各种模型的思想，为了响应变化和规避风险，会涉及到原型化和迭代开发的思想。关键在于思想的理解，模型是固化的，思想运用是灵活的。本章重点在过程与生命周期和过程模型。</p></blockquote><p>章节框架：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/06/6570568b46f1c.jpeg"></p><h1 id="过程与生命周期"><a href="#过程与生命周期" class="headerlink" title="过程与生命周期"></a>过程与生命周期</h1><h2 id="过程的定义"><a href="#过程的定义" class="headerlink" title="过程的定义"></a>过程的定义</h2><p>一组有序的任务，它涉及活动、约束和资源使用的一系列步骤，用于产生某种想要的输出。</p><p>过程不仅仅是步骤，过程是步骤的集合，它将步骤组织起来使人们能够生产满足一系列目标和标准的产品。</p><h2 id="软件生命周期"><a href="#软件生命周期" class="headerlink" title="软件生命周期"></a>软件生命周期</h2><p>软件开发过程描述了软件产品从概念到实现、交付、使用和维护的整个过程，因此，有时把软件开发过程称为软件生命周期。</p><h2 id="过程的重要意义"><a href="#过程的重要意义" class="headerlink" title="过程的重要意义"></a>过程的重要意义</h2><ol><li><p>它强制活动具有一致性和一定的结构。</p></li><li><p>过程结构允许我们分析、理解、控制和改进组成过程的活动，并以此来指导我们的活动。</p></li><li><p>它使我们获取经验并把经验传授给他人。</p></li></ol><h1 id="过程模型"><a href="#过程模型" class="headerlink" title="过程模型"></a>过程模型</h1><h2 id="为何需要为过程建立模型"><a href="#为何需要为过程建立模型" class="headerlink" title="为何需要为过程建立模型:"></a>为何需要为过程建立模型:</h2><ol><li><p>达成共识：开发团队在记录开发过程的描述时，自然的对软件所涉及到的活动,资源,约束等达成共识，这共识就是”模型”。</p></li><li><p>发现缺陷：发现过程层面的缺陷(过程实施时的不一致性、多余部分、缺省部分、不完善部分)，从而让过程更有效。</p></li><li><p>评价与优化：模型应该反映开发的诸多目标，并评价侯选活动的有效性和正确性,以构建高质量软件。</p></li></ol><h2 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h2><p>线性的安排每一个阶段，将开发阶段描述为从一个阶段瀑布般地转换到另一个阶段。一个开发阶段必须在另一个开发阶段开始之前完成。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/06/6570568b700fa.jpeg"></p><h3 id="瀑布模型的优点"><a href="#瀑布模型的优点" class="headerlink" title="瀑布模型的优点"></a>瀑布模型的优点</h3><ol><li><p>它的简单性使得开发人员很容易向不熟悉软件开发的客户作出解释。</p></li><li><p>每一个过程活动都有与其相关联的里程碑和可交付产品，以便于项目经理评估项目进度。</p></li><li><p>瀑布模型是最基础的模型，很多其他更复杂的模型实际上是在瀑布模型的基础上的润色，如加入反馈循环以及额外的活动。</p></li></ol><h3 id="瀑布模型的缺点"><a href="#瀑布模型的缺点" class="headerlink" title="瀑布模型的缺点"></a>瀑布模型的缺点</h3><ol><li><p>除了一些理解非常充分的问题之外，实际上软件是通过大量的迭代进行开发的。软件是一个创造的过程,<br>不是一个制造的过程。软件变动时,<br>该模型无法处理实际过程中的重复开发问题。</p></li><li><p>文档转换有困难。它说明了每一个活动的产品（例如，需求、设计或代码），但没有揭示一个活动如何把一种制品转化为另外一种制品（例如，从需求文档转化为设计文档）。</p></li></ol><h3 id="瀑布模型的优化——原型化的瀑布模型"><a href="#瀑布模型的优化——原型化的瀑布模型" class="headerlink" title="瀑布模型的优化——原型化的瀑布模型"></a>瀑布模型的优化——原型化的瀑布模型</h3><p>我们注意到瀑布模型将过程抽象为线性发展的，这种抽象给它带来了简单、明确和直观的优点，但同时也招致了许多问题。可是实际的开发中每个步骤并不是理想中的线性发展的的状态，比如在设计阶段了解到客户更新了需求，或者在设计阶段的疏漏直到测试时才被发现，以上的情况都需要返回之前的步骤进行修正才能解决。我们需要对瀑布模型进行优化，引入原型化以有助于控制活动之间的往返。</p><h4 id="原型的概念"><a href="#原型的概念" class="headerlink" title="原型的概念"></a>原型的概念</h4><p>一种部分开发的产品，用来让用户和开发者共同研究，提出意见，为最终产品定型。</p><p>原型可以理解为小样，在某一阶段产品定型前先做一些小样，通过对各种样品的评价和分析，并最终为产品定型。</p><p>原型化的瀑布模型如下图所示，在实现代码前的需求和设计阶段引进原型化的概念，在需求分析阶段，通过设计和分析原型以确保需求是一致、可行和符合实际的，避免在测试阶段付出巨大的代价进行修正；在设计阶段，原型化有助于开发人员评价可选的设计策略以及决定哪一种策略是最适合的。为了确保产品符合需要，在测试阶段要进行确认&#x2F;核准（validate）和验证（verify）。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/06/6570568b61fa2.jpeg"></p><h4 id="区分确认和验证"><a href="#区分确认和验证" class="headerlink" title="区分确认和验证"></a>区分确认和验证</h4><p>确认：确保系统实现了所有需求。 </p><p>验证：确保每一项功能都是正确的。</p><p>确认保证开发人员构造的是正确的产品，而验证检查实现的质量。</p><h2 id="V-模型"><a href="#V-模型" class="headerlink" title="V 模型"></a>V 模型</h2><p>V 模型是瀑布模型的变种，它说明测试活动是如何与分析和设计相联系的。</p><p>如下图所示，编码位于 V型的顶点，分析和设计在左边，测试和维护在右边。测试的每个步骤都与分析和设计相对应，如果在验证和确认期间发现了问题，可以重新执行响应的步骤加以修正。验收测试对应需求分析，系统测试对应系统设计，单元测试和集成测试对应程序设计。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/06/6570568b3e495.jpeg"></p><p>V 模型与瀑布模型的区别：</p><ol><li><p>V 模型使得隐藏在瀑布模型中的迭代和重做活动更加明确。</p></li><li><p>瀑布模型关注文档和制品，V 模型关注活动和正确性。</p></li></ol><h2 id="原型化模型——“在工作中学会工作”"><a href="#原型化模型——“在工作中学会工作”" class="headerlink" title="原型化模型——“在工作中学会工作”"></a>原型化模型——“在工作中学会工作”</h2><p>之前在瀑布模型的优化中介绍了原型化的思想，原型化并不依附于瀑布模型，原型化模型本身是有效的过程模型的基础。因为它允许用户以独立的工程模型的方式,<br>每一阶段都基于原型的建立, 以快速构造系统, 逐步完成各阶段任务。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/06/6570568b6f187.jpeg"></p><p>如上图所示，原型化模型并不依赖于明确的需求或设计，在情况不明朗的情况下使用原型化模型，先根据简单的需求和设计构造系统的简单样品以理解或澄清问题，以确保开发人员、用户和客户对产品达成共识。也就是说，要根据对每一阶段样品的反响明确需求和设计的具体内容。原型化设计有助于开发人员和客户达成共识，减少了开发中的风险和不确定性。但是为达成共识可能会需要反复进行原型设计。</p><h2 id="阶段化开发模型"><a href="#阶段化开发模型" class="headerlink" title="阶段化开发模型"></a>阶段化开发模型</h2><p>系统被设计成部分提交, 每次用户只能得到部分功能,而其他部分处于开发过程中。</p><p>循环周期：从软件开发时整理需求文档到系统交付经过的时间。</p><p>理解为何要阶段化开发，我们需要了解现在的商业环境不允许产品长时间拖延，所以我们要缩短循环周期，使用阶段化开发模型使系统能一部分一部分的交付，从而在系统其余部分正在开发的同时，用户已经获得了一部分功能。</p><h3 id="产品系统和开发系统"><a href="#产品系统和开发系统" class="headerlink" title="产品系统和开发系统"></a>产品系统和开发系统</h3><p>因为一边开发一边交付，所以有两个系统在并行运行。</p><p>运行系统&#x2F;产品系统：当前正在被客户和用户使用的系统。</p><p>开发系统：准备代替现行产品系统的下一个版本。</p><p>两者关系如下图所示，开发人员总是在开发 n+1，而与此同时 n 正在运行。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/06/6570568b60e04.jpeg"></p><h3 id="增量开发和迭代开发"><a href="#增量开发和迭代开发" class="headerlink" title="增量开发和迭代开发"></a>增量开发和迭代开发</h3><p>因为有不断发布的开发系统和已经运行的产品系统，我们需要有一种组织两者的方式。增量开发和迭代开发是两种最常用的方式。</p><p>增量开发：系统需求按照功能分成若干子系统，开始建造的版本是规模小的、部分功能的系统，后续版本添加包含新功能的子系统，最后版本是包含全部功能的子系统集。</p><p>迭代开发：系统开始就提供了整体功能框架，后续版本陆续增强各个子系统，最后版本使各个子系统的功能达到最强。</p><h3 id="将增量开发和迭代开发相结合"><a href="#将增量开发和迭代开发相结合" class="headerlink" title="将增量开发和迭代开发相结合"></a>将增量开发和迭代开发相结合</h3><p>一个新发布的版本可能包含新功能，并对已有功能做了改进。</p><p>两种开发方式结合的原因：</p><ol><li>观察用户反馈。</li><li>为新功能开拓市场。</li><li>及时修复问题。</li><li>针对不同版本设置不同专业领域技术的优化。</li></ol><h3 id="进化式迭代开发"><a href="#进化式迭代开发" class="headerlink" title="进化式迭代开发"></a>进化式迭代开发</h3><p>统一过程（UP&#x2F;RUP）：用例驱动的、以基本架构为中心的、迭代式和增量性的软件开发过程框架。它使用对象管理组织（OMG）的 UML并与对象管理组织（OMG）的软件过程工程原模型（SPEM）等相兼容。</p><h4 id="统一过程的特点"><a href="#统一过程的特点" class="headerlink" title="统一过程的特点"></a>统一过程的特点</h4><ul><li>统一过程”将重复一系列生命期，这些生命期构成了一个系统的寿命。每个生命期都以向客户推出一个产品版本而结束。</li><li>每个周期包括四个阶段：开始阶段、确立阶段、构建阶段和移交阶段。每个阶段可以进一步划分为多次迭代。</li></ul><h4 id="三个支持工序和六个核心工序"><a href="#三个支持工序和六个核心工序" class="headerlink" title="三个支持工序和六个核心工序"></a>三个支持工序和六个核心工序</h4><p>支持工序：</p><ol><li>配置变更管理工序，用来管理系统和需求变更的配置。</li><li>项目管理工序，用来管理项目。</li><li>环境配置工序，用来配置项目的环境，包括所涉及到的过程和工具。</li></ol><p>核心工序：</p><ol><li>业务模型工序，通过业务模型获取相关知识以理解需要系统自动完成的业务。</li><li>需求工序，通过用例模型获取相关知识以理解自动完成业务的系统需求。</li><li>分析设计工序，通过分析&#x2F;设计模型以分析需求，设计系统结构。</li><li>实现工序，基于实现模型实现系统。</li><li>测试工序，通过测试模型进行针对需求的系统测试。</li><li>部署工序，通过部署模型部署系统。</li></ol><p>下图展示了统一过程的四个阶段和六个核心工序之间的关系，上面一行表示四个阶段，左边一列表示六个核心工序，二者都包含在软件项目的生命期中。每个阶段都包含六个工序，但是重点不同。开始阶段最关注业务模型，几乎不涉及测试和部署；确立阶段最关心需求和分析；构建阶段最关心实现；移交阶段最关心测试和部署，几乎不涉及业务模型和需求。图中箭头表示六个工序执行顺序，菱形覆盖的面积表示关注程度。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/06/6570568b6c479.jpeg"></p><h3 id="什么是进化式迭代开发"><a href="#什么是进化式迭代开发" class="headerlink" title="什么是进化式迭代开发"></a>什么是进化式迭代开发</h3><ol><li>进化式迭代开发是统一开发过程的关键实践。</li><li>开发被组织成一系列固定的短期小项目。</li><li>每次迭代都产生经过测试、集成并可执行的局部系统。</li><li>每次迭代都具有各自的需求分析、设计、实现和测试。</li><li>随着时间和一次次迭代，系统增量式完善。结合下图理解进化式迭代开发。</li></ol><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/06/6570568b7a4e3.jpeg"></p><h2 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h2><p>此法将开发活动与风险管理结合起来,以降低和控制风险。有些类似于迭代开发模型，结合了迭代的思想，同时也结合了原型化的思想。该模型的适用范围于较大型软件工程项目。</p><p>如下图所示，螺旋模型每次迭代有四个任务，依次是计划、目标&#x2F;可选方案、风险评估、开发与测试。螺旋模型共有四次迭代，依次是操作概念、软件需求、软件设计、开发与测试。]每一次迭代都根据需求和约束进行风险分析，以权衡不同选择，并且在确定选择之前，通过原型化验证可行性和期望度。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/06/6570568b7c85c.jpeg"></p><h2 id="敏捷方法"><a href="#敏捷方法" class="headerlink" title="敏捷方法"></a>敏捷方法</h2><p>之前介绍的几种模型逐渐引入了原型化和迭代开发的思想，使得过程模型变得庞大，而敏捷方法打破了这种局面。</p><p>敏捷方法强调灵活性在快速有效的软件生产中所发挥的作用，是重量级方法的叛逆者。</p><h3 id="敏捷方法的四条原则"><a href="#敏捷方法的四条原则" class="headerlink" title="敏捷方法的四条原则"></a>敏捷方法的四条原则</h3><ol><li>个体和交互的价值胜过过程和工具。</li><li>可以工作的软件胜过面面俱到的文档。</li><li>客户合作胜过合同谈判。</li><li>响应变化胜过遵循计划。</li></ol><p>这四条原则反映了敏捷方法的软件过程倾向性。它强调人与人之间的交互是复杂的，并且其效果从来都是难以预期的，但却是工作中最重要的方面。</p><p>敏捷开发的总体目标：尽可能早的，持续的对有价值的软件的交付活动，以客户满意。</p><h3 id="敏捷开发过程的几种方法"><a href="#敏捷开发过程的几种方法" class="headerlink" title="敏捷开发过程的几种方法"></a>敏捷开发过程的几种方法</h3><ol><li>极限编程(XP)：激发人员创造性，使管理负担最小的一组技术，是敏捷方法中最主要的流派。（稍后有详细介绍）</li><li>Crystal（水晶法）：每一个不同的项目都需要一套不同的策略、约定和方法论。</li><li>SCRUM（并列争球法）：使用迭代的方法，其中把每 30天一次的迭代称为一个”冲刺”，并按需求的优先级别来实现产品。</li><li>Adaptive Software Development(ASD) (自适应软件开发)</li><li>Feature Driven Development(FDD) (特征驱动软件开发)</li></ol><h3 id="极限编程"><a href="#极限编程" class="headerlink" title="极限编程"></a>极限编程</h3><h4 id="四个变量"><a href="#四个变量" class="headerlink" title="四个变量"></a>四个变量</h4><p>成本、时间、质量和范围，通过研究变量之间的相互作用，将项目开发分析的更加透彻，成功讲述一个项目成功的原则。</p><p>不同的任务对这四个变量有不同的要求，分析哪一个变量是项目进展的制约，集中精力解决关键问题。</p><h4 id="四个准则"><a href="#四个准则" class="headerlink" title="四个准则"></a>四个准则</h4><ol><li>沟通: 客户与开发者之间持续的交流意见。</li><li>简单性: 鼓励开发者选择最简单的设计或实现来应对客户的需求。</li><li>反馈: 指在软件开发过程中的各个活动中,包含各种反馈循环工作。</li><li>勇气: 指尽早的和经常性的交付软件功能的承诺。</li></ol><h4 id="十二条原则"><a href="#十二条原则" class="headerlink" title="十二条原则"></a>十二条原则</h4><p>计划游戏、小版本、隐喻、简单设计、测试、重构、结队编程、代码集体所有、持续集成、每周工作40 小时、现场客户、编码标准</p><ul><li><p>小版本：系统设计要支持尽可能早的交付。（测试要简单有效。）</p></li><li><p>简单设计：只处理当前需求，使设计保持简单。（因为假设需求是变化的）</p></li><li><p>编码标准：编码支持其他实践，例如测试和重构等。</p><p>其余每条的介绍详见课本。</p></li></ul><p>例题</p><p>关于小版本(小型发布)的说明：敏捷开发方法中，对计划的发布版本应该（ B）。</p><p>A：按产品特性交付：需要交付的特性都必须交付，必要时要推迟发布时间</p><p>B：按日期交付：按照预定发布时间进行发布，必要时候裁剪部分功能特性。</p><p>C：临时决定：我们会平衡一下，临时根据市场要求和开发进展来确定，可能会同时调整交付时间和特性。</p><p>D：在迭代模式下，没有必要计划版本。每个迭代都应该完成可发布的版本，按照市场需要发布迭代版本即可。</p><p>解析：敏捷方法强调灵活性，”尽可能早的，持续的对有价值的软件的交付活动”是其总体目标。</p><h1 id="过程建模工具和技术"><a href="#过程建模工具和技术" class="headerlink" title="过程建模工具和技术"></a>过程建模工具和技术</h1><p>建模工具与技术是在过程模型之内的具体运用。</p><h2 id="两种主要种类的模型"><a href="#两种主要种类的模型" class="headerlink" title="两种主要种类的模型"></a>两种主要种类的模型</h2><h3 id="静态建模——Lai-表示法"><a href="#静态建模——Lai-表示法" class="headerlink" title="静态建模——Lai 表示法"></a>静态建模——Lai 表示法</h3><p>描述一个过程如何由输入转换为输出。</p><p>综合的过程符号描述系统, 允许人们在任何详细的层次上对任何过程建模,该模型范式中可由人员完成角色,由资源完成活动,最后导致软件工件&#x2F;制品的产生。过程模型可以用角色、活动、加工项(工件)来显示彼此之间的关系，用状态表显示每个加工项(工件)在特定时间的完成情况。</p><p>过程的元素：</p><ol><li>活动：过程中要发生的事件。各种前后关系、触发条件、规则、团队成员等等。也可以理解为子过程。</li><li>序列：活动顺序等等。</li><li>过程模型：小型工程可以认为是开发方式等描述。</li><li>资源：活动所需的各种资源标注。</li><li>控制：针对活动的外部影响等。</li><li>策略：各种指导原则，包括约束等。</li><li>组织：各种层次化结构等描述。包括物理的和软件逻辑的结构。</li></ol><h3 id="动态建模"><a href="#动态建模" class="headerlink" title="动态建模"></a>动态建模</h3><p>推演一个过程，用户和开发人员可以看到中间产品和最终产品如何随着时间的推移进行转换。</p><p>系统动力学：展示资源流(非一般性输入)如何通过活动成为输出。</p><h3 id="在所有的软件开发过程模型中，你认为哪些过程给予你最大的灵活性以应对需求的变更？"><a href="#在所有的软件开发过程模型中，你认为哪些过程给予你最大的灵活性以应对需求的变更？" class="headerlink" title="在所有的软件开发过程模型中，你认为哪些过程给予你最大的灵活性以应对需求的变更？"></a>在所有的软件开发过程模型中，你认为哪些过程给予你最大的灵活性以应对需求的变更？</h3><ol><li>设计对于分析模型应该是可跟踪的：软件的模块可能被映射到多个需求上。</li><li>设计结构应当尽可能的模拟实际问题。</li><li>设计应当表现出一致性。</li><li>不要把设计当成编写代码。</li><li>在创建设计时就应该能够评估质量。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 大学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件工程概述</title>
      <link href="/2023/12/06/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/12/06/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<blockquote><p>当我学到这个跟我专业名字一模一样的课程时，我的心情真是很复杂：<br>一方面不知不觉已经学到了我专业的本命课程，这个大一时看课程计划觉得无比重要的课，倍感岁月不饶人；<br>另一方面，当我们学完这学期再审视这门课，又觉得它像Apple的一句广告：“说简单，也高深”。<br>说它简单，觉得它在一开始复习时恍惚有种背政治的感觉，比起烧脑的程序设计和巧妙计算来说真的很轻松；<br>说它高深，是因为如果让所有就业的软件工程毕业生投票自己最后悔没好好学的课，它一定是champion。</p><p>当你抱着一颗佛系的心看这些知识时，你会觉得它那么教条；但当你真的准备干点大事，带着挚友们开发个软件时，你会觉得它说的是那么针针见血：<br>如果你是负责人，你如何知道你需要什么招什么样的人来组成一个开发团队？你就是有了合适的团队你靠什么告诉客户你会花多长时间多少钱去完成这个项目才让他们放心把项目交给你？你就是拿到了项目你怎么让客户客观理性准确无误地告诉你他们的需求是什么？你就是得到了明确无疑的需求你怎么确定为了实现这个你该怎么设计这些功能？你就是得到了一份巧夺天工的设计你怎么保证你的程序员们能高效合作地把这些设计准确实现出来？你就是有了一批勤恳踏实的程序员写完了这些代码你怎么保证它们功能上没有错误？你就是所有功能都完美实现了你怎么保证它们合在一起还能干活？你就是把功能们合在一起天衣无缝你怎么交付给客户使用这个系统？你就是让客户心甘情愿地收下了这个系统你怎么保证用户用起来出了意外怎么维护？你就是维护好了这个系统你怎么迭代增量开发下一个系统让团队不会沦为临时工？……</p><p>总之，软件工程是整个专业的脉络，它的重要性随着你越来越接触到软件开发的核心而愈发凸显。</p></blockquote><h1 id="软件工程概述"><a href="#软件工程概述" class="headerlink" title="软件工程概述"></a>软件工程概述</h1><p>这一章介绍软件工程的发展历程，其所使用的技术及工具；如何分析问题以及寻求解决方案；软件开发人员们取得的进展以及需要努力的方向；软件开发的涉及人员及Wasserman规范将实践融为一体的八个概念。</p><p>章节框架：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/06/65705366604c6.png"></p><h2 id="什么是软件工程"><a href="#什么是软件工程" class="headerlink" title="什么是软件工程"></a>什么是软件工程</h2><p>软件工程涉及的就是”软件开发的规范”，在规范里面体现出内在的思想与软件工程之规律。</p><h3 id="问题求解"><a href="#问题求解" class="headerlink" title="问题求解"></a>问题求解</h3><ul><li>分析(analysis)：将问题分解成可以理解并能够处理的若干小部分，确定问题的本质含义。</li><li>合成(synthesis)：将每个小问题的解决方案组合成一个大的结构，合成解决方案。工具(tool)：用更好的方式完成某事情的设备或自动化系统。</li><li>过程(produce)：把工具和技术结合起来，共同生产特定产品。</li><li>范型(paradigm)：构造软件的特定方法、途径或哲学（如面向对象开发的模式、结构化开发的模式、基于过程开发的模式、某种订制开发的模式）。</li></ul><h3 id="软件工程师的角色是什么"><a href="#软件工程师的角色是什么" class="headerlink" title="软件工程师的角色是什么"></a>软件工程师的角色是什么</h3><p>以计算机科学理论和计算机功能为基础，通过对要解决问题的本质的了解，采用相应的工具和技术，实现设计方案，推出高质量的软件产品。（将计算机作为问题求解的工具）</p><h3 id="软件工程（SE）的定义、方法、作用"><a href="#软件工程（SE）的定义、方法、作用" class="headerlink" title="软件工程（SE）的定义、方法、作用"></a>软件工程（SE）的定义、方法、作用</h3><ul><li>SE：在将有关软件开发与应用的概念科学体系化的基础上，研究如何有计划、有效率、经济地开发和利用能在计算机上正确运行的软件理论和技术工程的方法学，以及一些开发和维护软件的方法、过程、原则等。它是一个系统工程，既有对技术问题的综合分析，也有对开发过程和参与者的管理。</li><li>SE 的方法：面向对象模式，结构化模式，基于过程的模式等。</li><li>SE的作用：付出较低的开发成本，达到要求的软件功能，取得较好的软件性能，开发的软件易于移植，需要较低的维护费用，能按时完成开发工作，及时交付使用。</li></ul><h3 id="开发模式"><a href="#开发模式" class="headerlink" title="开发模式"></a>开发模式</h3><p>软件开发的全部过程，活动和任务的结构框架，它能直观的表达软件开发全过程，明确要完成的主要活动，任务和开发策略。</p><h2 id="软件工程取得了哪些进展"><a href="#软件工程取得了哪些进展" class="headerlink" title="软件工程取得了哪些进展"></a>软件工程取得了哪些进展</h2><h3 id="故障，错误和失效各自的含义（含举例）及它们之间的联系"><a href="#故障，错误和失效各自的含义（含举例）及它们之间的联系" class="headerlink" title="故障，错误和失效各自的含义（含举例）及它们之间的联系"></a>故障，错误和失效各自的含义（含举例）及它们之间的联系</h3><ul><li>错误(error)：是在软件开发过程中人为产生的错误（需求说明中的错误，代码中的错误）。</li><li>故障(fault)：软件功能实现过程中产生的问题，是错误导致的结果，是软件中一个错误的表现（一个错误可能产生多个故障，静态存在）。</li><li>失效(failure)：系统违背了它应有的行为（在系统交付前或交付后被发现，动态存在）。</li><li>联系：人为原因导致程序[错误]；该[错误]编译到系统中导致系统[故障]；用户使用该系统时，因[故障]导致[失效]。故障是系统内部视图，从开发者的角度看待问题；失效是系统外部视图，从用户角度看到的问题。而且并不是所有的故障会导致失效，只要不执行故障代码，或者不进入某个特定状态，那么故障就不会使代码失效。</li></ul><h3 id="零缺陷软件"><a href="#零缺陷软件" class="headerlink" title="零缺陷软件"></a>零缺陷软件</h3><p>由于市场压力促使软件开发人员快速交付产品，零故障无法实现。</p><h3 id="关于-bug"><a href="#关于-bug" class="headerlink" title="关于 bug"></a>关于 bug</h3><p>改正(fixing)有时比重写(rewriting)整个系统要困难。</p><p>错误修正的越晚，付出的代价越大。</p><p>复审(review)十分重要，是正式团队的行为规范；自己检查能只能找出开发阶段故障的1&#x2F;5，同行评审能够揭示其余 4&#x2F;5 的故障。</p><h2 id="什么是好的软件"><a href="#什么是好的软件" class="headerlink" title="什么是好的软件"></a>什么是好的软件</h2><p>从三个方面考虑软件的质量：产品的质量、生产该产品的过程的质量以及在产品将使用的商业环境背景下的质量。</p><h3 id="产品-product-的质量"><a href="#产品-product-的质量" class="headerlink" title="产品(product)的质量"></a>产品(product)的质量</h3><p>用户：从失效的数目和类型等外部特性进行评价，如果软件具有足够的功能，并且易于学习和使用；或者虽然难以学习和使用，但是由于功能值得这些付出，用户就断定软件是高质量的。</p><p>开发者：从故障的数目和类型等内部特征来作为产品质量的依据。</p><h3 id="过程-process-的质量"><a href="#过程-process-的质量" class="headerlink" title="过程(process)的质量"></a>过程(process)的质量</h3><p>有很多过程都会影响到最终的产品质量，只要有活动出了差错，产品的质量就会受到影响；开发和维护过程的质量与产品的质量是同等重要的。</p><p>几个量化模型：CMM、ISO 9000、SPICE（了解）</p><h3 id="商业-business-环境背景下的质量"><a href="#商业-business-环境背景下的质量" class="headerlink" title="商业(business)环境背景下的质量"></a>商业(business)环境背景下的质量</h3><ul><li><p>技术价值与商业价值的联系与区别：</p><p>技术价值：技术指标（速度，正确的运行时间，维护成本等）。</p><p>商业价值：机构对软件是否与其战略利益相吻合的一种价值评估。误区：技术质量不会自动转化为商业价值。</p></li><li><p>目标：</p><p>将技术价值和商业价值统一起来，改进过程所带来的商业价值。</p></li></ul><h2 id="软件工程涉及的人员"><a href="#软件工程涉及的人员" class="headerlink" title="软件工程涉及的人员"></a>软件工程涉及的人员</h2><ul><li><p>客户(customer)：为将要开发的软件系统支付费用的公司、组织或个人。</p></li><li><p>开发者(developer)：为客户构建软件系统的公司、组织或个人。</p></li><li><p>用户(user)：实际使用系统的人。</p><p>有时，他们可能是同一个人或同一组人。</p></li></ul><h2 id="系统的开发方法"><a href="#系统的开发方法" class="headerlink" title="系统的开发方法"></a>系统的开发方法</h2><p>要开发一个项目，必须知道系统包含哪些对象或活动。</p><p>系统(system)：实体、活动、关系、系统边界的集合。</p><h3 id="软件系统的系统要素（组成）（对象（实体）-活动-关系-系统边界）"><a href="#软件系统的系统要素（组成）（对象（实体）-活动-关系-系统边界）" class="headerlink" title="软件系统的系统要素（组成）（对象（实体）+ 活动 +关系 + 系统边界）"></a>软件系统的系统要素（组成）<em>（对象（实体）+ 活动 +关系 + 系统边界）</em></h3><h4 id="活动和对象"><a href="#活动和对象" class="headerlink" title="活动和对象"></a>活动和对象</h4><p>活动(activity)：活动是发生在系统中的某些事情，通常描述为由某个触发器引发的事件，活动通过改变某一特性把一个事物转变成另一个事物。</p><p>对象(object)或实体(entity)：活动中涉及的元素称为对象或实体（如记录数据的对象）。</p><h4 id="关系和系统边界"><a href="#关系和系统边界" class="headerlink" title="关系和系统边界"></a>关系和系统边界</h4><p>关系(relationship)：对实体和活动间数据项及动作相互关系的描述。</p><p>系统边界(system boundary)：用于描述系统中包含什么，不包含什么。</p><h3 id="相互联系的系统"><a href="#相互联系的系统" class="headerlink" title="相互联系的系统"></a>相互联系的系统</h3><p>内容概述：几乎不存在与其他系统没有关联的系统，因此刻画系统边界十分重要，很容易了解什么在系统内部、什么不在以及什么超出了边界。系统可能存在于另一个系统中。边界定义的详细正确，那么根据较小的部分构建较大的系统是相对容易的。开发可以由内而外,但设计最好得由大到小,这就带来了难度。</p><p>增量式开发方法：包含一系列阶段，其中每一个阶段都使前面的系统不受当前系统约束的限制。系统逐渐地从旧的软件和硬件中脱离开，直到它体现出新系统的设计。</p><h2 id="工程化的方法"><a href="#工程化的方法" class="headerlink" title="工程化的方法"></a>工程化的方法</h2><p>大型软件开发过程中的工程化途径与方法</p><h3 id="构建系统"><a href="#构建系统" class="headerlink" title="构建系统"></a>构建系统</h3><p>现代软件工程大致包含的几个阶段及各个阶段文档：</p><ol><li>需求分析：包括问题定义、可行性研究、需求分析【《SRS》即《软件需求规格说明书》】与复审（所有人）。</li><li>系统设计：包括用户界面的设计【《SAD》即《软件系统结构图》：如何制作软件】与复审（开发者与客户）。</li><li>程序设计：包括模块功能算法与数据描述设计【相关文档】与复审（开发者）。</li><li>程序实现：包括编程与 debug【源代码和注释】与复审（开发者、码农）。</li><li>单元测试：模块功能测试与性能测试【测试报告】与复审（测试团队）。</li><li>集成测试：按照结构图进行测试【测试报告】与复审（测试团队）。</li><li>系统测试：按《SRS》对系统总体功能进行测试与复审（开发者与客户）。</li><li>系统提交：交付产品【用户手册和操作手册】与复审。</li><li>系统维修：修改软件的过程，为改错或满足新需求【维修报告】与复审（维修团队）。</li></ol><blockquote><p>注：圆括号中的为测试人员，方括号为生成的文档。</p></blockquote><p>额外说明（了解）：以上阶段只是大致的划分，软件团队实际执行时比这要复杂，还有若干辅助性过程和阶段，而有些阶段实际是相互重叠、相互影响的。</p><h2 id="开发团队的成员"><a href="#开发团队的成员" class="headerlink" title="开发团队的成员"></a>开发团队的成员</h2><p>需求分析人员、设计人员、程序员、测试人员、培训人员、维护人员、资料管理人员、配置管理人员。</p><p>软件工程各阶段各自的工作：（了解）</p><ul><li>需求设计（分析员、客户）：将客户想要的分解为离散需求。</li><li>系统设计（分析员、设计员）：生成系统层描述（系统要做什么）。程序设计（设计员、程序员）：实现指定需求的代码。</li><li>程序实现（程序员）：编代码。</li><li>单元测试（程序员、测试员）：发现各种错误。集成测试（测试团队）：检查系统功能。</li><li>系统测试（测试员、客户、培训员）：根据《SRS》检查要求。系统交付（培训员）：培训用户。</li><li>系统维修（维修团队）：寻找故障，根据客户需求变化，对系统作出修改。</li><li>资料管理（资料管理员）：维持一个软件的不同版本之间各种文档的对应关系，包括需求规格说明、设计描述、程序文档、培训手册、测试数据进度等。</li><li>配置管理（配置管理员）：维护需求、设计、实现和测试之间的对应关系。</li><li>软件架构师：属于高级程序员，侧重开发过程和模式的选择和论证（在国内和分析员差不多,其工作重点与分析员有所不同，但就开发来说，其工作似乎更重要些，而分析员的工作更偏重于市场与用户需求）。</li></ul><h2 id="软件工程发生了多大的变化"><a href="#软件工程发生了多大的变化" class="headerlink" title="软件工程发生了多大的变化"></a>软件工程发生了多大的变化</h2><h3 id="变化的本质"><a href="#变化的本质" class="headerlink" title="变化的本质"></a>变化的本质</h3><p>早期程序：线性输入，输出为字母数字，系统设计方式分为两种：转换(transformation)：将输入转换为输出；事务(transaction)：由输入决定哪个功能将被执行。因此瀑布模型开发方式可行。</p><p>当今程序：多系统运行，跨平台运行，基础功能：网络控制，安全性，用户界面表示和处理，以及数据或对象管理等。相较于早期变化巨大，瀑布模型不适用。</p><p><strong>使现代软件工程实践发生变化的七个关键因素</strong></p><ol><li><p>商用产品投入市场时间的紧迫性</p></li><li><p>计算技术在经济中的转变：更低的硬件成本，更高的开发、维护成本</p></li><li><p>功能强大的桌面计算的可用性</p></li><li><p>广泛的局域网和广域网</p></li><li><p>面向对象技术的采用及其有效性</p></li><li><p>使用窗口、图标、菜单和指示器的图形用户界面</p></li><li><p>软件开发瀑布模型的不可预测性</p></li></ol><p>说明（了解）：瀑布模型沿袭了传统系统工程的大规模批发制造的理念，假定生产活动为线性，这与现代软件的生产方式相矛盾。不再是有足够的灵活性和适应性来满足并行开发或并行运行这样的商业软件需求，因此不可预测。</p><p>结论（了解）：对一个系统进行划分，以便并行地开发其子系统，需要一个与瀑布模型有很大不同的开发模型。</p><h3 id="软件工程的-Wasserman-规范（或基本概念）"><a href="#软件工程的-Wasserman-规范（或基本概念）" class="headerlink" title="软件工程的 Wasserman 规范（或基本概念）"></a>软件工程的 Wasserman 规范（或基本概念）</h3><ol><li><p>抽象：基于某种层次归纳水平的问题描述。它使我们将注意力集中在问题的关键方面而非细节。</p></li><li><p>分析、设计方法和符号描述系统：</p><p>使用标准表示来对程序进行描述。利于交流，利于建模并检查其完整性和一致性，利于对需求和设计部件进行重用。</p></li><li><p>用户界面原型化(prototyping)：</p><p>建立系统的小型版,<br>通常具有有限的关键功能,以利于用户评价和选择，证明设计或方法的可行性。</p></li><li><p>软件体系结构：</p><p>定义一组体系结构单元及其相互关系集来描述软件系统。单元分解的方法</p><p>（以下了解）</p><ul><li>基于功能的模块化分解: 基于指派到模块的功能。</li><li>基于数据的分解: 基于外部数据结构。</li><li>面向事件的分解：基于系统必须处理的事件。</li><li>由外到内的分解：基于系统用户的输入。</li><li>面向对象的设计：基于标识的对象的类以及它们之间的相互关系。</li></ul></li><li><p>软件过程：软件开发活动中的各种组织及规范方法。</p><p>（以下了解）</p><p>因应用类型和组织文化之间的巨大差异,故难以对软件过程本身进行预先指定,也就是说:使过程本身规范化是不可能的.软件过程不可能以抽象和模块化的方式作为软件工程的基础。</p></li><li><p>重用或复用(reuse)：重复采用以前开发的软件系统中具有共性的部件,用到新的开发项目中去 (注: 这里的重用绝不仅仅是源代码的重用)。</p></li><li><p>测度或度量(measurement)：通用的评价方法和体系，有助于使过程和产品的特定特性更加可见，包括量化描述系统、量化审核系统。</p></li><li><p>工具和集成环境：通过框架比较软件工程环境提供的服务，以决定其好坏。工具：由于厂商很少针对整个开发生命周期，因此对于工具的比较集中于小的活动集，例如测试或设计。</p><p>（以下了解）</p><p>工具集成中必须处理的五个问题：(by Wasserman)</p><p>平台集成、表示继承、过程集成、数据集成、控制集成。</p></li></ol><p>总结：以上八个概念将软件工程作为一门科学学科，也是本书的八个线索。</p><h2 id="章末案例思考"><a href="#章末案例思考" class="headerlink" title="章末案例思考"></a>章末案例思考</h2><p>什么是软件危机？它有哪些典型表现？为什么会出现软件危机？</p><p>​软件危机：落后的软件生产方式无法满足迅速增长的计算机软件需求，从而导致软件开发与维护过程中出现一系列严重问题的现象。</p><p>​典型表现：</p><ol><li><p>对软件开发成本和进度的估计常常很不准确。</p></li><li><p>用户对”已完成”软件系统不满意的现象经常发生。</p></li><li><p>软件产品的质量往往靠不住。</p></li><li><p>软件常常是不可维护的。</p></li><li><p>软件通常没有适当的文档资料。</p></li><li><p>软件成本在计算机系统总成本中所占的比例逐年上升。</p></li><li><p>软件开发生产率提高的速度，远跟不上计算机应用迅速普及深入的趋势。</p></li></ol><p>出现的原因：一方面与软件本身的特点有关，另一方面也和软件开发与维护的方法不正确有关。</p><ol><li>软件缺乏”可见性”，管理和控制软件开发过程相当困难。</li><li>软件规模庞大，而且程序复杂性将随着程序规模的增加而呈指数上升。</li><li>开发时期引入错误，导致软件维护通常意味着改正或修改原来的设计，客观上使得软件较难维护。</li><li>软件专业人员对软件开发和维护中或多或少地采用了错误的方法和技术。</li></ol><h2 id="典型例题"><a href="#典型例题" class="headerlink" title="典型例题"></a>典型例题</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/06/6570536627349.jpeg"></p><p>答案：A</p>]]></content>
      
      
      <categories>
          
          <category> 大学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网网络层</title>
      <link href="/2023/12/05/%E8%AE%A1%E7%BD%91%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
      <url>/2023/12/05/%E8%AE%A1%E7%BD%91%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<blockquote><p>数据链路层保证了数据在相邻节点的可靠传输，网络层关注的是如何将源端数据包经过网络上的节点一路送到接收方。为了实现这个目标，网络层必须知道网络拓补结构，并从中选出适当的路径。本章包含到路由算法、拥塞控制、服务质量、网络互连和IP 协议。</p></blockquote><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/05/656f2b03d055b.png"></p><p>上图为本章考试重点，非原书结构，仅供参考。</p><h1 id="网络层两类服务"><a href="#网络层两类服务" class="headerlink" title="网络层两类服务"></a>网络层两类服务</h1><ul><li><p>无连接服务——数据报网络</p><p>特点：所有的数据包都被独立地注入到网络中，并且每个<strong>数据包独立路由</strong>，不需要提前建立任何设置。在这样的上下文中，数据包通常称为数据报，对应的网络称为数据报网络。</p></li><li><p>面向连接服务——虚电路网络</p><p>特点：发送数据报前，<strong>首先建立一条从源到目标的路径</strong>，每条报文都沿这条路径传送。这个连接称为虛电路，对应的网络称为虚电路网络。</p></li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/05/656f2c4948901.png"></p><h1 id="路由算法——基于最优路径的路由算法"><a href="#路由算法——基于最优路径的路由算法" class="headerlink" title="路由算法——基于最优路径的路由算法"></a>路由算法——基于最优路径的路由算法</h1><h2 id="最优化原则"><a href="#最优化原则" class="headerlink" title="最优化原则"></a>最优化原则</h2><p>遵循最优化原则以破除环路，方便设计路由算法。</p><p>最优化原则：如果J 在从I 到K 的最优路径上，那么从J 到K 的最优路径也必定遵循<br>相同的路由。即最优路径的子路径还是最优路径。</p><p>汇集树：依照最优化原则，从所有的源到一个指定目标的最优路径的集合构成一颗以目<br>标节点为根的树。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/05/656f2e2d8b9cc.png"></p><h2 id="泛洪算法"><a href="#泛洪算法" class="headerlink" title="泛洪算法"></a>泛洪算法</h2><p>泛洪路由的基本想法是源节点将消息以分组的形式发给其相邻的节点，相邻的节点再转发给它们的相邻节点，继续下去，直至分组到达网络中所有的节点。很显然，泛洪法会产生大量的重复数据包，除非采取某些措施来抑制泛洪过程，否则将会产生无限多的数据包。</p><h2 id="距离矢量路由算法DV（RIP-协议）"><a href="#距离矢量路由算法DV（RIP-协议）" class="headerlink" title="距离矢量路由算法DV（RIP 协议）"></a>距离矢量路由算法DV（RIP 协议）</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/06/6570360f20480.png"></p><p>每个路由器维护一张表，表中列出了当前已知的到每个目标的最短距离，以及所使用的线路的下一跳，通过在邻居之间相互交换信息，路由器不断地更新它们的内部表，最终每个路由器都了解到达目的地的最佳链路。届时就可以根据路由表和目的地址，在任意路由上确定下一跳进行跳转。</p><p>路由表的具体维护方式：当前点与所有邻居节点交换的路由表，然后根据这些表计算该点去所有其他点的最优下一跳<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/06/657036bc98270.png"></p><p>如上面的例子所示，当求点J 到点C 的最短距离和下一跳时，分别求出Ji+iC 的最小值，即min{8+25,10+18,12+19,6+36}&#x3D;28，最短路径是经过I，时长28。</p><p>无穷计数问题：“坏消息”传播的很慢，可以从下面的例子进行理解</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/06/65703680457ed.png"></p><p>如图所示，ABC 各自维持自己的路由表，但如果AB 之间的线路突然断开，那么B 和C 在计算各自与A 的距离的时候，就会互为参考，每次路由表更新的时候计算出的与C 的距离只会加1 直到数值趋近于无穷，所以AB 之间的断开很慢被发现。</p><h2 id="链路状态路由算法LSP（OSPF、IS-IS-协议）"><a href="#链路状态路由算法LSP（OSPF、IS-IS-协议）" class="headerlink" title="链路状态路由算法LSP（OSPF、IS_IS 协议）"></a>链路状态路由算法LSP（OSPF、IS_IS 协议）</h2><p>每个节点都将自己的邻居信息表传给所有节点，每个节点都保存所有节点的邻居信息表，并使用Dijkstra 计算出本节点到其他所有节点的最短路。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/06/657038d6bcc43.png"></p><p>上面可以看到，邻居信息表中都包含两个字段：Seq 和Age。</p><p>Seq:由于邻居信息表需要泛洪给所有节点，为了控制泛洪的规模，所以使用Seq 序号。新的链路状态数据包到达一个节点的时候，路由器检查这个新来的数据包的序号和源路由器是否已经出现在自己的列表中。重复则丢弃，源路由器相同而序号过时则拒绝接受。</p><p>Age:在数据包发出时设定初值，然后每一秒都会减一，变为0 则会被丢弃，①可以在泛洪时防止数据包无限生存②及时清理路由器中链路状态数据库中旧的或无效的信息，以防以下问题的影响，如：路由器崩溃后重启序号从0 开始的话会被当做过时信息丢弃；传递过程中序号出现差错如4 变65540，那么只有seq 字段就会导致后面的5-65539 全被拒绝。</p><p>算法步骤：</p><ol><li>发现邻居节点，并知道其网络地址</li><li>测量到各邻居节点的延迟或开销</li><li>构造一个分组，分组中包含所有它刚知道的信息</li><li>将这个分组发送给所有其他的路由器</li><li>计算出到每一个其他路由器的最短路径</li></ol><p><strong>务必重点掌握距离矢量算法和链路状态算法</strong>，详见中文课本P285—P291</p><p>因为距离矢量算法每个节点只与邻居节点交换信息，在面临路由器失效时会出现无穷计数问题。链路状态算法用泛洪的方式分发链路状态包，所以每个节点都知道完整的网络加权0拓补图，重点在链路状态包的构造和分发方法以及健壮性。</p><h2 id="层次路由"><a href="#层次路由" class="headerlink" title="层次路由"></a>层次路由</h2><p>随着网络规模的增长，路由器的路由表也成比例增长，结果是路由器效率下降，成为网络服务的瓶颈。解决之道是将网络分层，采用分层路由之后，路由器被划分成区域，每个路由器知道如何将数据包路由到自己所在区域内的目标地址，但是对于其他区域的内部结构毫不知情。</p><p>可以认为每个区域是一个村，普通村民知道如何与本区域所有其他人联系，而村长除此之外还知道如何与别的村的村长联系，村民与外村人联络时会先将信交给村长由村长转发，他负责本区域与其他区域的联络。后面IP 协议的子网划分中的分类寻址就是层次化的设计。</p><h1 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h1><p>主要掌握RED 协议，完整的流量控制应该是网络层（RED 协议）和传输层（TCP 慢启动）配合的任务。</p><p>拥塞：网络中存在太多数据包导致数据包被延迟和丢失，从而降低了传输性能。当拥塞出现后，有可能遭遇拥塞崩溃。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/11/29/6566f58bf0add.png"></p><p>随机早期检测（RED）（P310）<br>当某条链路上的平均队列长度超过某个阈值时，该链路就被认为即将拥塞，因此路由器随机丢弃一小部分数据包。</p><p>当拥塞时，若路由器向发送方发抑制包，那么大量的抑制包反而会加重拥塞。所以网络层解决拥塞的思路就是防患于未然，在局面变得毫无希望前让路由器舍弃负担。后面配合传输层可以降低用户发送速率，从根本上解决拥塞。</p><h1 id="流量整形——平滑的流量更好管理"><a href="#流量整形——平滑的流量更好管理" class="headerlink" title="流量整形——平滑的流量更好管理"></a>流量整形——平滑的流量更好管理</h1><p>流量整形（traffic shaping）是指调节进入网络的数据流的平均速率和突发性所采用的技术，包括漏桶和令牌桶。</p><ul><li>漏桶算法：无论注入桶内的速率是大是小，出桶的速率总是恒定的。</li><li>令牌桶算法：桶内存放发送数据的令牌，每单位时间获得一定量的令牌，发送数据时取出令牌，流量大小受限于积累的令牌数量。一般令牌桶下面会有一个漏桶用于平滑发送速率。</li></ul><h1 id="IPv4-协议"><a href="#IPv4-协议" class="headerlink" title="IPv4 协议"></a>IPv4 协议</h1><p>层与层之间数据的传递：上层整段消息内容是对下一层透明的数据</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/06/65703a13452c5.png"></p><h2 id="IP-头"><a href="#IP-头" class="headerlink" title="IP 头"></a>IP 头</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/06/65703ef2d7be6.png"></p><p>IP 协议Internet Protocol 提供尽最大努力的数据传输，不保证可靠</p><p>IP 数据报由头和正文组成，正文是有效净荷，携带数据；头由20 字节定长及一个可选变长组成，携带此数据报的解释信息。下面是IP 头的相关介绍。</p><ol><li>版本：记录数据报属于什么版本，Ipv4 Ipv6</li><li>IHL：IP 头长，单位为4 字节，因为头部至少20 字节定长，所以值域5~15。</li><li>区分服务：前6 位标识数据报服务类型，后2 位携带显示拥塞信息，了解。</li><li>总长度：数字报总长度，单位是1 字节（8bit），包括头和数据，最大长度216 字节</li><li>生存期TTL：计数单位为跳数，每经过一跳减一，递减到0 的时候数据包被丢弃并由路由器给源地址发送一个报警包。设定目的主要解决环路问题，避免数据包被永远都留在网路中。不同协议的技术单位不同，有的还设定为秒，这是为了控制拥塞，但是秒不好实现。</li><li>协议：记录IP 分组携带数据的协议类型，即传输层协议的编号，如TCP、UDP 等</li><li>头校验和：对IP 头信息进行校验，检测数据包穿过网络时是否发生错误。但是由于只校验了头，所以IP 数据报整体依旧不可靠</li><li>源地址和目的地址：源地址可以用于丢包时给源地址发消息；目的地址用于寻找路径时查路由表</li><li>选项：给出对寻址过程中要求必须经过的路由器，如今，几乎已经不再使用IP 选项</li><li>IP 头第二行都是关于分段的处理，其用途就是：不同网络的最大帧长的要求可能不同，从而大数据进入小网络需要对大的数据进行分段。标识表示这段分段属于哪个数据报：DF 表示是否允许分段，DF&#x3D;1 表示该数据报不允许分段，到达需要分段的地方就丢包返回消息；MF 表示所属于的数据报是否还有更多的段。MF&#x3D;0 表示当前分段是该数据报的最后一段；分段偏移量表示该分段在整个数据包中的位置，以8 字节为单位。具体计算此处不再详细介绍，这一行了解即可。</li></ol><h2 id="分类寻址Classful-Addresing"><a href="#分类寻址Classful-Addresing" class="headerlink" title="分类寻址Classful Addresing"></a>分类寻址Classful Addresing</h2><p>IP 地址被分为五类。如A 类允许27 个网络，每个网络中允许有224 台主机，由于每类网络中允许的主机数量是固定的，所以造成了IP 地址极大的浪费，这才引入了后面的CIDR</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/06/65703fde4d64b.png"></p><h2 id="子网Subnet-与前缀prefix"><a href="#子网Subnet-与前缀prefix" class="headerlink" title="子网Subnet 与前缀prefix"></a>子网Subnet 与前缀prefix</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/06/65704054be34e.png"></p><ol><li>IP 地址长32 位，由高位的可变长网络号和低位的主机号组成，同一网络上所有主机的网络号相同，一个网络对应一块连续的IP 地址空间，这块地址空间就被称为地址的前缀</li><li>写法：点分十进制，如18.0.31.0&#x2F;24，24 表示网络号位数。子网掩码是网络号长度个1 和主机号长度个0 组成，子网掩码和IP 按位与可以得到网络号</li><li>子网划分subnetting：在内部将一个网络块分成几个部分供多个内部网络使用，但对外部世界仍然像是单个网络一样。而第一章的子网subnet 是分割一个大型网络得到的一系列结果网络，是指网络中所有路由器和通信线路的集合。</li><li>转发过程：数据报到达后，路由器检查该数据包的目的地址，将该目的地址与路由表中每个子网目标的子网掩码按位与看是否匹配</li></ol><h2 id="无类域间路由CIDR"><a href="#无类域间路由CIDR" class="headerlink" title="无类域间路由CIDR"></a>无类域间路由CIDR</h2><p>Classless Inter-Domain Routing，是为解决IP 路由表爆炸、IP 地址耗尽而提出的一种措施。在变长子网掩码的基础上提出的一种消除ABCDE 类网络划分，并且可以在软件的支持下实现构造超网的一种IP 地址的划分方法。</p><p>子网划分与聚合的一个实例：以下页图为例用一块从194.24.0.0 开始的大小为213 的地址分配三个大学的地址。计算过程如下。其中每个地点的两行分别代表该地的起始和终止IP 地址。竖虚线为网络号和主机号划分。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/06/657040ea02b46.png"></p><p>分配的原则是：一个网路只能有一个网络号，进行IP 地址分配时尽可能连续分配。以牛津大学为例，尽管前面余下210 个空白，但是依旧选择向后。</p><p>路由聚合rounte aggregation：为了减小路由表长度，将多个小前缀地址块合并为一个大前缀地址块，如上面的三个地址就可以聚合成一个地址，方法是将三者网络号最大公共部分聚合为新网络号<br>194.21.0.0&#x2F;21<br>194.24.8.0&#x2F;22 → 194.24.0.0&#x2F;19<br>194.24.16.0&#x2F;20</p><p>如此，就可以将三个路由表项合成一个，其下一跳是伦敦。但由此带来一个问题：如果上面空白的那部分被分配给非洲某学校，那么空白部分就会被错误的聚合。因此要在路由表中新增一项单独指明空白部分的下一跳。</p><p>所以，在没有聚合时，查路由只需要找到匹配的一项就可以跳到下一跳，但是有聚合以后，需要寻找路由表项中的最长匹配</p><p>路由器的转发过程完善如下：当新的消息进入路由器时，首先进入等待队列，通过一定的调度策略进行调度。调度到这个消息时，获取其目的地址，将目的地址分别与路由表中的每一项网络号的子网掩码进行比对，选取最长匹配的网络表项进行转发。当然，没有查询到匹配的时候，转发到缺省表项，也就是给上一层路由，继续寻找。</p><h2 id="NAT-网络地址转换"><a href="#NAT-网络地址转换" class="headerlink" title="NAT 网络地址转换"></a>NAT 网络地址转换</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/06/6570419dd9c6a.png"></p><ol><li>IP 地址短缺问题解决策略：①动态分配IP ②迁移到IPv6 ③多台共用一个IP</li><li>NAT(Network Address Translation)，它的思想是设定两套IP 地址,内网相对于外网来说共用一个public 地址，而在内网中，每台机器对应一个private 地址</li><li>内网之间的通信使用private 地址，当想要向外网发送消息时，只需将源地址替换为内网共用的public 地址</li><li>当外网向内网发送消息时，因无法区分内网的主机，所以引入了port。将私有IP与端口号影射成新的port，当与这个端口号交互时，根据影射算法可以知道私有IP</li><li>缺点：①违反了最基本的协议分层原则，传输层的数据不再对网络层透明②私有IP 与port 对公有port 的映射关系不是一一对应的③违反IP 唯一性原则等。</li></ol><h2 id="隧道技术"><a href="#隧道技术" class="headerlink" title="隧道技术"></a>隧道技术</h2><p>隧道技术（tunneling）：是一种通过使用互联网络的基础设施在不同网络之间传递数据的方式。使用隧道传递的数据（或负载）可以是不同协议的数据帧或包。隧道协议将其它协议的数据帧或包重新封装然后通过隧道发送，到达对方以后再将被包裹的数据提取出来进行传递。新的帧头提供路由信息，以便通过互联网传递被封装的负载数据。</p><p>简言之，就是处理不同网络相连接的情形，隧道技术对于两头网络相同中间不同的特例有效。它的方法就是在经过中间网络的时候加一个新的IP 头，度过以后再拆掉。</p><h1 id="Internet-控制协议"><a href="#Internet-控制协议" class="headerlink" title="Internet 控制协议"></a>Internet 控制协议</h1><h2 id="ICMP-控制消息协议"><a href="#ICMP-控制消息协议" class="headerlink" title="ICMP 控制消息协议"></a>ICMP 控制消息协议</h2><p>为了提高IP 数据报交付成功的机会，在网络层使用了网络控制报文协议来允许主机或者路由器来报告差错和异常情况。了解即可，详见P358。ICMP 是通过向数据包的源地址报告有关事件使网络运行正常。</p><h2 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h2><p>Address Resolution Protocol，地址解析协议是一个连接二三层的协议，可以说是IP 分组-帧连接协议。</p><p>某一层的地址只在本层有效，网络层负责寻找路径，而真正实现消息传递的是链路层，所以要实现两层地址之间的映射。</p><h3 id="路由器之间消息的传递"><a href="#路由器之间消息的传递" class="headerlink" title="路由器之间消息的传递"></a>路由器之间消息的传递</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/06/657042462a6ed.png"></p><p>现在的关键在于已知源IP、源MAC 和目的IP 的情况下怎样获取目的MAC</p><h3 id="交换机原理"><a href="#交换机原理" class="headerlink" title="交换机原理"></a>交换机原理</h3><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/06/6570426ac07e8.jpg"></p><p>在上图中的交换机中存储着一张MAC 和port 的对应表，交换机的一个端口和一台主机一一对应。只有发送过消息的端口的对应关系才会被交换机所知道，而一个广播能同时将一个子网的全部对应关系都传送给交换机。</p><h3 id="同一子网中消息的传递"><a href="#同一子网中消息的传递" class="headerlink" title="同一子网中消息的传递"></a>同一子网中消息的传递</h3><p>如上，主机1 欲给主机2 发消息，应首先经过如下两个过程：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/06/657042a021d67.png"></p><h3 id="不同子网消息的传递"><a href="#不同子网消息的传递" class="headerlink" title="不同子网消息的传递"></a>不同子网消息的传递</h3><p>E3 作为通往外网的代理分析广播的接收方是否在这个子网中。若目的IP 与E3 所在网络号相同那么E3 就当做一个普通主机，否则提交到路由器的网络层，而E3 则作为这条消息的代理与网外交互。</p><p>而在路由表中找到对方所属的子网以后，在该子网中通过ARP 广播找到该IP</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/06/657042c6734dc.png"></p>]]></content>
      
      
      <categories>
          
          <category> 大学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网介质访问控制子层</title>
      <link href="/2023/12/04/%E8%AE%A1%E7%BD%91%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/"/>
      <url>/2023/12/04/%E8%AE%A1%E7%BD%91%E4%BB%8B%E8%B4%A8%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E5%AD%90%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<blockquote><p>该层是用来确定多路访问信道下一个使用者的协议属于数据链路层的一个子层，称为介质访问控制（Medium Access Control) 子层，也叫MAC 子层。注意这章的标题是“子层”，也就是说这一章的内容还是属于数据链路层，是它的一个子层，虽然出现的章节比第三章要晚，但实际上却是整个数据链路层的底层。</p><p>因为在同一介质中相同频率波段的传输信号会相互干扰，导致无法得到有效的信号，而采用频率，时间区别不同信号又无法最大限度地利用资源，这时候就希<br>望有种协议可以协商三个以上的机器如何可以在没有统一调度的前提下“遵守秩序”“不打断别人”地发言，让介质顺利被利用不产生冲突。数据链路层的两点之间可靠传输有个前提，首先要确定到底是哪个点可以获得信道开始传输。所以说这一章内容是数据链路层的底层。</p></blockquote><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/05/656eabaf2b413.png"></p><p>上图为本章考试重点，非原书结构，仅供参考。</p><h1 id="多路访问协议"><a href="#多路访问协议" class="headerlink" title="多路访问协议"></a>多路访问协议</h1><h2 id="ALOHA-系统"><a href="#ALOHA-系统" class="headerlink" title="ALOHA 系统"></a>ALOHA 系统</h2><h3 id="纯ALOHA"><a href="#纯ALOHA" class="headerlink" title="纯ALOHA"></a>纯ALOHA</h3><p>用户有数据就发送，不考虑信道是否空闲，只管发。用户如果发现有冲突，则随机等待一段时间后再发。它的意义在于提出了非协调用户竞争使用单个共享信道的系统的问题，现实中已不使用，详见P203。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/05/656f0f4384ba4.png"></p><h3 id="分槽ALOHA"><a href="#分槽ALOHA" class="headerlink" title="分槽ALOHA"></a>分槽ALOHA</h3><p>为了提高发送的容量，将时间分成了离散的间隔，称为时间槽，用户只能在槽边界发数据，减少了冲突期，将吞吐量提升了一倍。详见P204，P205</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/05/656f0fdc59e61.png"></p><h2 id="CSMA"><a href="#CSMA" class="headerlink" title="CSMA"></a>CSMA</h2><p>载波检测多路访问（Carrier Sense Multiple Access）指每个站监听线路上是否有载波（传输），并据此采取相应的动作的方式。相比ALOHA的先发后听，这是先听后说，大大地提高了利用率。</p><h3 id="1-坚持，0-坚持，p-坚持的CSMA"><a href="#1-坚持，0-坚持，p-坚持的CSMA" class="headerlink" title="1 坚持，0 坚持，p 坚持的CSMA"></a>1 坚持，0 坚持，p 坚持的CSMA</h3><ul><li>1 坚持：当一个站有数据要发送时，它首先侦听信道，确定当时是否有其他站正在传输数据；如果信道空闲，就发送数据，如果信道忙，该站持续坚持监听信道，直到空闲，一旦监听到空闲，则站立即发送一帧。如果发生冲突，该站等待一段随机的时间，然后从头开始上述过程。这样的协议之所以称为1坚持，是因为当站发现信道空闲时，它传输数据的概率为1。</li><li>非坚持：如1 坚持一样监听信道如果空闲则发，然而如果信道当前正在使用中，则该站并不持续对信道进行监听。相反，它会等待一段随机时间，然后重复上述算法。因此，该算法将会导致更好的信道利用率，但是比起1-坚持也带来了更大的延迟。</li><li>P 坚持：以概率P 发送数据，以概率q&#x3D;1-P 将此次发送推迟到下一个时间槽发送。如果下一个时间槽也是空闲的，则它还是以概率P 发送数据，或以概率q 再次推迟发送。该过程一直重复，直到帧被发送出去，或者另一个站开始发送数据。属于两种方式的改良，直觉上保证了“有礼貌”地在信道上不打断其他站的传输且只在空闲的时候传输就可以解决多路访问的冲突问题。</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/05/656f11e4a816c.png"></p><p>但是这三个协议都没有解决在多个站同时监听到空闲后都发送时会导致的信号混杂从而冲突的情形，如果有协议保证站可以迅速监听到冲突后立即停止，则可以最大程度上节省了注定失败的传输所占用信道的时间和带宽，这种协议就是下面的带冲突检测的CSMA，也是现在以太网实际采用的协议。</p><h3 id="CSMA-CD"><a href="#CSMA-CD" class="headerlink" title="CSMA&#x2F;CD"></a>CSMA&#x2F;CD</h3><p>带冲突检测的CSMA（CSMA with Collision Detection）P207，P208</p><p>不止在发前监听信道，在信号发送过程中发送方也要持续监听信道，如果发现线路上的信号与自己发送的信号不一致（即产生了冲突），则立刻停止传输信息，发送一段48bit的阻塞信号告诉与自己发生冲突的站不要漏检这次冲突，之后它等待一段时间再发送。</p><p>如何确保发送方意识到冲突是这个协议着重解决的问题，也就是发送时间需要足够长，保证即使是另一端的产生冲突的信号传过来自己也还在发，不至于发完了不再监听信道后不知道自己这次的传输已经失败了。也就是说需要至少发满信号跑一个</p><h2 id="无线局域网协议"><a href="#无线局域网协议" class="headerlink" title="无线局域网协议"></a>无线局域网协议</h2><h3 id="无线局域网与有线局域网的不同"><a href="#无线局域网与有线局域网的不同" class="headerlink" title="无线局域网与有线局域网的不同"></a>无线局域网与有线局域网的不同</h3><ol><li>两者的传输介质有着本质区别，也正是这种区别，导致WLAN 存在新的问题：隐藏终端问题和暴露终端问题。</li><li>两者传输范围有区别：WLAN 中，无线电传输范围有限，一个站不能给所有其他站发送帧，也无法接收来自所有其他站的帧；在有线局域网中一个站发出一帧，所有其他站都能接收到。</li><li>信道检测方式不同：WLAN 采用能量检测、载波检测和能量载波混合检测三种检测信道空闲的方式；以太网通过电缆中电压的变化来检测。</li><li>在WLAN 中，对某个节点来说，其刚刚发出的信号强度要远高于来自其他节点的信号强度，也就是说它自己的信号会把其他的信号给覆盖掉，但在本节点处有冲突并不意味着在接收节点处就有冲突。</li></ol><p>详见p214</p><h3 id="MACA-冲突避免多路访问"><a href="#MACA-冲突避免多路访问" class="headerlink" title="MACA 冲突避免多路访问"></a>MACA 冲突避免多路访问</h3><p>（Multiple Access with Collision Avoidance）</p><h4 id="隐藏终端问题"><a href="#隐藏终端问题" class="headerlink" title="隐藏终端问题"></a>隐藏终端问题</h4><p>A 给B 发，但C 的信号接收覆盖范围没法覆盖到A，导致不知道A 在给B 发，误以为B空闲，一旦发送，则信号会冲突干扰，导致失效。可以看到，问题的关键在于C 无法知道B的接收情况，因为之前的监听是在发送方C 自己这里进行的。这个问题是致命的。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/05/656f13a2f02a3.png"></p><h4 id="暴露终端问题"><a href="#暴露终端问题" class="headerlink" title="暴露终端问题"></a>暴露终端问题</h4><p>B 给A 发，此时C 想要发送信号给D，但C 监听到介质上有信号传输，则会等待B 传输结束再进行给D 的传输，但实际上这种等待是不必要的因为C 即使发给D 也不会干扰A 的接收信号，因为干扰只在接收方端产生，所以这种问题带来了效率的降低，根源还是在于C不知道接收方A 的情况，只知道自己附近发送方B 的情况。但注意并不是致命的，因为还是没有破坏传输。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/05/656f13c97563a.png"></p><h4 id="RTS（Request-To-Send）和CTS-Clear-To-Send"><a href="#RTS（Request-To-Send）和CTS-Clear-To-Send" class="headerlink" title="RTS（Request To Send）和CTS (Clear To Send)"></a>RTS（Request To Send）和CTS (Clear To Send)</h4><p>为了解决上面两个问题，即之前的CSMA 只能监听到发送方附近而不是接收方附近介质情况根本问题，希望能通过协议让接收方也“发言”，即通过这次信号让接收方附近的站点也能感受到接收方的存在，从而避免后续的继续发送造成该接收方的冲突。<br>解决的方案就是发送方先发RTS，之后接收方回CTS 信号，并从这个信号中包含这次传输的持续时长信息保证让此时长内接收方附近站点主动静默，从而不会使其受到干扰。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/05/656f159406a73.png"></p><p>即一个点如果只听到RTS，没有听到CTS，说明它在发送方的发送范围内，却不在接收方的发送范围内，则它只要不干扰发送方收CTS，即可随便发送。解决了暴露终端问题。<br>一个点如果只要听到CTS 说明它就在接收方发送范围内，此时它要保持静默到持续时长，直到此次传输结束它再进行发送，否则会干扰接收方接收。解决了隐藏终端问题。</p><h3 id="CSMA-CA"><a href="#CSMA-CA" class="headerlink" title="CSMA&#x2F;CA"></a>CSMA&#x2F;CA</h3><p>带有冲突避免的CSMA（CSMA with Collision Avoidance）P234—P236。它是802.11 MAC 子层协议的核心协议，与之前的MACA 相比，它引入了短确认确保每<br>一帧的发送成功，即数据发送后站启动确认计时器，如果计时器时间到但没有收到接收方回复的收到的确认，则试图重新发送。但在RTS 和CTS 方面并没有考虑暴露终端问题。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/05/656f16037a609.png"></p><ol><li><p>RTS 和CTS</p><p>与MACA 类似，但是将规则改成了听到RTS 后也停止传输一切东西，直到此次数据传输结束后再进行传输。这样其实是无法解决暴露终端问题的，但由于考虑到暴露终端问题是效率问题而不是致命问题，且处理这个不经常发生的问题需要耗费操作时间，所以就进行了舍弃。</p></li><li><p>NAV 网络分配向量（Network Allocation Vector）P236</p><p>每个站保留的信道何时要用的逻辑记录，每个帧携带一个NAV 字段，说明这个帧所属的一系列数据将传输多长时间。所有听到数据帧的站将在发送确认期间推迟发送，不管能否真正听到确认的发送。</p></li><li><p>二进制指数后退的CSMA&#x2F;CA P220，P234</p><p>侦听很短的一段时间后发现没有信号，则随机选择0-15 个时间槽进行倒计时倒数，当听到有帧发送时暂停倒计时，空闲时计数，到0 时就发送，如果发送成功则目标站会发送一个短确认，如果没收到确认，则发送方加倍自己选择的时间槽数，重新试图发送。如此反复，直到成功发送帧或达到最大重传次数。</p></li></ol><h1 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h1><h2 id="经典以太网"><a href="#经典以太网" class="headerlink" title="经典以太网"></a>经典以太网</h2><p>经典以太网MAC 子层的帧格式</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/05/656f17977f22e.png"></p><p>具体字段内容解释见课本P218——P220，注意由于冲突检测要求有效数据必须大于64个字节，所以不算前导码的8 位，用户Data 段为0 时，此时帧的最短长度只有18 个字节，所以存在最长为46 字节的填充位（18+46 &#x3D; 64）.</p><h2 id="交换式以太网"><a href="#交换式以太网" class="headerlink" title="交换式以太网"></a>交换式以太网</h2><p>以交换机为核心设备而建立起来的一种高速网络。可在高速与低速网络间转换，实现不同网络的协同。交换机分割了连接的不同网络成为不同的冲突域，不同冲突域之间信号不会彼此干扰，所以不用考虑不同自治域间的冲突问题。</p><h1 id="交换机（网桥）"><a href="#交换机（网桥）" class="headerlink" title="交换机（网桥）"></a>交换机（网桥）</h1><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>网桥工作在数据链路层，将多个LAN 连接起来，通过检查数据链路层地址来转发帧。</p><ul><li>当一帧到达时，网桥必须决定是将该帧转发还是丢弃</li><li>如果决定转发，还必须要决定在哪个端口传输帧</li><li>网桥通过在其内部配备一个大的(哈希)表来查询一帧的目的地址，该表中列出了每一个可能的目的地址以及它隶属的输出端口</li><li>当网桥第一次被接入网络时，所有的哈希表都是空的，网桥使用洪泛算法完善哈希表。</li><li>其具体转发过程为：<ol><li>目的地址的端口与源端口相同，则丢弃该帧</li><li>目的地址的端口与源端口不同，则转发该帧到目的端口</li><li>目标地址端口未知，则使用洪泛算法，将帧发送到所有的端口，除了他入境的那个。</li></ol></li></ul><h2 id="目的地-端口哈希表（转发表）的获得"><a href="#目的地-端口哈希表（转发表）的获得" class="headerlink" title="目的地-端口哈希表（转发表）的获得"></a>目的地-端口哈希表（转发表）的获得</h2><p>泛洪算法：不需要知道网络的拓扑结构和相关的路由计算，仅要求接收到信息的节点以广播的形式转发数据包。</p><p>对于每个发向未知目的地址的入境帧，网桥将他输送到所有的端口，除了它到来的那个端口，慢慢的网桥学习到目标地址在哪里)和向后学习法(通过检查每个窗口上发送的所有帧的源地址，网桥就可获知通过那个窗口能访问到哪些机器。</p><h2 id="中继器-集线器-网桥-交换机-路由器-网关的对比"><a href="#中继器-集线器-网桥-交换机-路由器-网关的对比" class="headerlink" title="中继器&#x2F;集线器&#x2F;网桥&#x2F;交换机&#x2F;路由器&#x2F;网关的对比"></a>中继器&#x2F;集线器&#x2F;网桥&#x2F;交换机&#x2F;路由器&#x2F;网关的对比</h2><p>中继器：物理层，模拟设备，用于连接两根电缆段，放大信号。</p><p>集线器：物理层，有许多输入线路，它将这些输入线路连接起来，在任何一条线路上到达的帧都被发送到其他线路上。</p><p>交换机：数据链路层，多端口的网桥。根据帧的目的地址转发，常被用来连接独立计算机。</p><p>路由器：网络层，当一个分组进入到一个路由器中的时候，帧头和帧尾被剥掉，位于帧的IP 分组被传递给路由软件，路由软件利用分组的头信息来选择一条输出线路。</p><p>网关：传输层，应用层。应用网关是将一个网络与另一个网络进行相互连通，提供特定应用的网际间设备，应用网关必须能实现相应的应用协议。应用网关可设在应用层或传输层。设在应用层的叫应用层网关，也称代理服务器。设在传输层的叫传输层网关。</p>]]></content>
      
      
      <categories>
          
          <category> 大学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网数据链路层</title>
      <link href="/2023/12/03/%E8%AE%A1%E7%BD%91%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
      <url>/2023/12/03/%E8%AE%A1%E7%BD%91%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<blockquote><p>数据链路层是基于物理层不可靠的传输向上层提供可靠的传输，它提供的是相邻两个节点之间可靠的数据传输。本章将学习网络模型中的第二层（即数据链路层）的设计原则。学习内容涉及两台相邻（指两台机器通过一条通信信道连接起来）机器实现可靠有效的完整信息块（称为帧）通信的一些算法，而不像物理层那样只关注单个比特传输。解决通信线路中出错的情况、关于有限的数据传输率、发送时间和接受时间存在的非零延迟等问题。</p></blockquote><blockquote><p>本章内容结构：</p><ol><li>首先介绍数据链路层的关键设计问题，并学习如何考察错误的本质以及如何检测和纠正这些错误。</li><li>然后，我们将学习一系列复杂性逐步递增的协议，每个协议解决了本层中越来越多的问题。</li><li>最后会给出一些数据链路层协议的例子。</li></ol></blockquote><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/03/656c6a52e2155.png"></p><p>上图为本章考试重点，非原书结构，仅供参考。</p><h1 id="数据链路层的设计问题"><a href="#数据链路层的设计问题" class="headerlink" title="数据链路层的设计问题"></a>数据链路层的设计问题</h1><p>数据链路层使用物理层提供的服务在通信信道上发送和接受比特。完成一些功能：</p><ol><li>向网络层提供一个定义良好的服务接口。</li><li>处理传输错误。</li><li>调节数据流，保证慢速的接收方不会被快速的发送方淹没。</li></ol><p>为实现这些目标：，数据链路层从网络层获得数据包，并将之包装成包含：帧头+ 有效载荷（存放数据包）+ 帧尾的帧（frame）。</p><p><strong>数据链路层的工作核心就是帧的管理。</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/03/656c6c040e83e.png"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/03/656c6c55a859d.png"></p><p>帧的通用结构中前三项称为帧头。</p><h2 id="提供给网络层的服务"><a href="#提供给网络层的服务" class="headerlink" title="提供给网络层的服务"></a>提供给网络层的服务</h2><p>最主要的服务是将数据从源机器的网络层传输到目标机器的网络层。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/03/656c6cdd1bc89.png"></p><p>一般情况下，提供以下三种可能的服务：</p><ol><li><p>无确认的无连接服务。</p><p>源机器向目标机器发送独立的帧，目标机器不对这些帧进行确认。不需建立逻辑连接。适用于错误率低或者实时通信（语音传输）的情况。</p></li><li><p>有确认的无连接服务。</p><p>源机器向目标机器发送独立的帧，目标机器会对这些帧进行确认。不需建立逻辑连接。适用于不可靠的信道（无线系统，WiFi）。</p></li><li><p>有确认的有连接服务。</p><p>源机器和目标机器在传输任何一个数据之前要建立一个连接，保证目标机器按照正确的顺序接受每一个帧。适用于长距离且不可靠的链路（卫星信道，长途电话）。</p></li></ol><h2 id="成帧"><a href="#成帧" class="headerlink" title="成帧"></a>成帧</h2><p>为检测错误和纠正错误，数据链路层将比特流拆分成多个离散的帧，为每个帧计算一个称为校验和的短令牌，并将该校验和放在帧中一起传输。为拆分比特流需要解决两个问题：</p><ol><li>帧的边界问题：如何识别帧的边界</li><li>帧的透明传输（填充）问题：如果帧的数据中出现和边界一样的flag 该如何防止被识别为边界</li></ol><p>下面介绍四种成帧方法</p><ol><li><p>Character count（字节计数法）</p><p>用头部的一个字段来标识该帧中的字符数。<br>问题：因为一个传输错误，就会全弄混。很少被使用。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/03/656c7171f13a3.png"></p></li><li><p>Flag Bytes with byte stuffing（字节填充的标志字节法）</p><p>发送方使用标志字节（FLAG）作为开始和结束；使用转义字节（ESC）表示其后的字节为数据字节而不是标志字节或转义字节。接收方将收到的数据中的转义字节删除后再传递给网络层。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/03/656c71aef37a7.png"></p></li><li><p>Starting and ending flags,with bit stuffing（比特填充的标志比特法）</p><p>使用“01111110”表示帧的开始和结束（帧的边界问题解决），并且在数据中，若遇到5 个连续的比特1，就在其后填入一个比特0（帧的填充问题解决）。接收方除了将首尾的“01111110”删除外，还要将数据中所有5 个连续比特1 其后的比特0 删除。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/03/656c71e52f522.png"></p></li><li><p>Physical layer coding violation（物理层编码违禁法）</p><p>使用“不会出现在常规数据中”的冗余比特作为边界。好处是除了开始和结束的填充外，不再需要填充额外的数据。</p></li></ol><h2 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h2><p>为确保所有帧按照正确顺序传递给目标机器的网络层：</p><ul><li>发送方发送反馈信息来确保传递可靠。</li><li>引入计时器来防止硬件故障或通信信道出错等原因丢失某一帧使发送方持续等待确认。</li><li>通过序号保证每一帧按照顺序且不会被接收方重复接收。</li></ul><p>具体的确认方式在后面通过协议的形式来讲。</p><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><p>发送方发送帧的速度超过了接收方能够接收这些帧的速度，而导致丢帧。<br>解决方法：</p><ul><li>基于反馈的流量控制（链路层）。</li><li>基于速率的流量控制（网络层）。</li></ul><h1 id="差错检测和纠正"><a href="#差错检测和纠正" class="headerlink" title="差错检测和纠正"></a>差错检测和纠正</h1><h2 id="纠错码"><a href="#纠错码" class="headerlink" title="纠错码"></a>纠错码</h2><p>推断出被发送的数据是什么。适用于错误发生很频繁的信道，因为再次传输仍可能出错。</p><p>海明码（参考原书p159 ）：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/03/656c73b564262.png"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/03/656c73b511120.png"></p><h2 id="检错码"><a href="#检错码" class="headerlink" title="检错码"></a>检错码</h2><p>循环冗余校验码（CRC，Cyclic Redundancy Check，也称作多项式编码)，推断是否发生错误。适用于高度可靠的信道，错误偶尔发生时，只需重传整个数据块即可。注意有一定的误判率。<br>步骤：（以下面算式为例讲解，具体原理参见课本P165）</p><ol><li>收发双方商定一个比帧短且头尾都是1 的01 串叫做生成多项式，如下的10011</li><li>帧的后面附上生成多项式长度减一个0 后，作为被除数对生成多项式模2 除，得到<br>商和余数，如10011 长度为5，所以附上了4 个0</li><li>若帧与余数合并以后在接收方被生成多项式整除，那么认为传递的过程没有出错</li></ol><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/03/656c7680023ac.png"></p><p>模2除原则：列竖式的方式同除法，但是模2 除法中加法无进位，减法无借位，即加减皆等同于异或，而商0 还是1 由被除数首位决定，首位是1 商1，否则商0。</p><h1 id="基本数据链路层协议"><a href="#基本数据链路层协议" class="headerlink" title="基本数据链路层协议"></a>基本数据链路层协议</h1><p>组成帧的四个字段：kind、seq、ack 和info。前三个包含控制信息，称为帧头，最后一个可能包含了要被传输的实际数据。</p><h2 id="一个乌托邦式的单工协议（协议1）"><a href="#一个乌托邦式的单工协议（协议1）" class="headerlink" title="一个乌托邦式的单工协议（协议1）"></a>一个乌托邦式的单工协议（协议1）</h2><ul><li>不需考虑任何错误情况：数据单向传输，双方总是就绪，数据处理时间不计，缓存空间无限大，通信信道永不丢帧。</li><li>这是一个完全不现实（理想化）的协议，所以称为“乌托邦” 协议。</li><li>发送过程是一个无限的while 循环，它尽可能快速地把数据放到线路上。无差错控制或者流量控制方面的限制。接受过程一直等待一个未损坏的帧到达。（发送速率和接收速率必须一样快）</li></ul><h2 id="无错信道上的单工停-等式协议（协议2）"><a href="#无错信道上的单工停-等式协议（协议2）" class="headerlink" title="无错信道上的单工停-等式协议（协议2）"></a>无错信道上的单工停-等式协议（协议2）</h2><p>单向数据传输，发送方网络层一直有无限的数据要发送， 信道不会出错，从不损坏或丢失帧，发送方需等待接收方确认帧返回后才发送下一帧。如果接收方不反馈应答信号，则发送方必须一直等待，然后就陷入等待接收方确认信息的过程中，因而传输效率低。</p><h2 id="有错信道上的单工停-等式协议（协议3）"><a href="#有错信道上的单工停-等式协议（协议3）" class="headerlink" title="有错信道上的单工停-等式协议（协议3）"></a>有错信道上的单工停-等式协议（协议3）</h2><p>信道存在噪音。需要计时器与序号配合，需要超时重传机制。</p><h1 id="滑动窗口协议"><a href="#滑动窗口协议" class="headerlink" title="滑动窗口协议"></a>滑动窗口协议</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>滑动窗口（sliding window）：为了便于理解，可以认为数据是一条传送带，而滑动窗口中的数据是当前准备处理的数据。一旦窗口的第一条数据被确认处理结束，窗口就会继续向后滑动以处理后面的数据。下面是发送方的发送窗口形象化的表示：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/03/656c785d76a99.png"></p><ul><li>捎带确认（piggybacking）：暂时延缓确认以便将确认信息搭载在下一个出境数据帧上的技术。捎带确认通常与累计确认一同使用，更好的利用了信道的可用带宽。</li><li>期望确认：收到数据帧以后向发送方发送期望对方发送的下一帧的序号。</li><li>累计确认（cumulative acknowledgement）：当n 号帧的确认到达，n-1 号帧、n-2号帧等都会自动被确认。</li><li>否定确认（NAK）：接收方检测到错误时发送的否定确认，实际是一个重传请求，在NAK中指定了要重传的帧。</li><li>发送窗口（sending window）：发送方总维持着一组序号，分别对应于允许它发送的帧，我们称这些帧落在发送窗口。</li><li>接收窗口(receiving window):接收方维持着的一个窗口对应于一组允许它接受的帧。</li></ul><h2 id="1-位滑动窗口协议（协议4）"><a href="#1-位滑动窗口协议（协议4）" class="headerlink" title="1 位滑动窗口协议（协议4）"></a>1 位滑动窗口协议（协议4）</h2><p>（发送窗口大小&#x3D;1，接收窗口大小&#x3D;1）</p><p>当接收窗口大小为1 时，可保证帧的有序接收，但效率较低。</p><p>源站发送单个帧后必须等待确认，在目的站的确认到达源站之前，源站不能发送其他数据帧。这是因为发送窗口大小仅为1，必须用来保存当前未确认的帧以超时重传。</p><p>发送方必须在内存中保存所有的帧，因此如果最大窗口的尺寸为n，则发送方需要n 个缓冲区才存放未被确认的帧。</p><h2 id="回退N-协议（协议5）"><a href="#回退N-协议（协议5）" class="headerlink" title="回退N 协议（协议5）"></a>回退N 协议（协议5）</h2><p>（发送窗口大小&gt;1，接收窗口大小&#x3D;1）</p><p>发送方按照顺序向对方发送帧，在收到对方的确认以后窗口向后滑动，若当前窗口中的第一个帧出现超时，那么回退到这个帧重新发送所有的帧。</p><p>而因为接收窗口大小为1，除了数据链路层必须要递交给网络层的下一帧外，接收方拒绝接受任何帧。如果在计时器超时以前，发送方的窗口已被填满，则管道将变为空闲，最终，发送方将超时，并且按照顺序重传所有未被确认的帧，从那个受损或者丢失的帧开始。</p><p>一般使用累计确认。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/03/656c79b03033b.png"></p><h2 id="选择重传协议（协议6）"><a href="#选择重传协议（协议6）" class="headerlink" title="选择重传协议（协议6）"></a>选择重传协议（协议6）</h2><p>（发送窗口大小&gt;1，接收窗口大小&gt;1）</p><p>发送方按照窗口的顺序依次发送帧给接收方，而接收方检查该帧是否可以落在接收窗口内，即以前没有接收过且该序号在窗口可接收的范围内，如果可以那么不管这一帧是否为网络层所期望的下一个数据包都接收该帧并暂存于缓冲区内。该帧会一直保存在数据链路层中直到所有序号比它小的帧已经按顺序递交给网络层，它才能被传递给网络层。</p><p>辅助计时器：在发送方的计时器超时之前，没有出现需要发送的反向流量，则发送一个单独的确认帧，而发送的时间间隔由辅助计时器决定，因此辅助计时器的超时间隔应该明显短于数据帧关联的计时器的间隔。</p><p>除ACK，选择重传还有否定确认，当接收方发现坏帧丢弃时，立刻发送一个NAC 给发送方告知该帧未收到让它重传，以防超时。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/03/656c79b052d99.png"></p><p>选择重传和回退N 实际是带宽使用效率与数据链路层缓存空间之间的权衡。</p><h1 id="数据链路协议实例"><a href="#数据链路协议实例" class="headerlink" title="数据链路协议实例"></a>数据链路协议实例</h1><p>这里要考察的是那些出现在Internet 两种常见情形下的数据链路协议，这些协议主要用在点到点的线路上。第一种情形是通过广域网中的SONET 光纤链路发送数据包。例如，这些链路被广泛用于连接一个ISP 网络中位于不同位置的路由器。</p><p>第二种情形是运行在Internet 边缘的电话网络本地回路上的ADSL 链路。这些链接把成千上百万的个人和企业连接到Internet 上。</p><p>针对上述这些使用场景Internet 需要点到点链路，还会用到拨号调制解调器、租用线路和线缆调制解调器等。所谓点到点协议（Point-to-Point Protocol) 的标准协议就是使用这些链路来发送数据包。PPP 由RFC1661 定义，并在RFC1662 中得到进一步的阐述(Simpson, 1994a， 1994b)。 SONET 和ADSL 链路都釆用了PPP, 但在使用方式上有所不同。</p><p>详见原书。</p>]]></content>
      
      
      <categories>
          
          <category> 大学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网物理层（二）</title>
      <link href="/2023/12/01/%E8%AE%A1%E7%BD%91%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2023/12/01/%E8%AE%A1%E7%BD%91%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>物理层是网络协议模型的最底层，该层定义了比特作为信号在信道上发送时相关的电气、时序和其他接口，是构建网络的基础。物理信道的不同特性决定了其传输性能的不同（比如，吞吐量、延迟和误码率），所以物理层是我们展开网络之旅的最好始发地。</p></blockquote><blockquote><p>本章内容结构：</p><ol><li>首先从数据传输的理论分析出发，探讨决定信道传输的自然局限。</li><li>接着给出三类传输介质：有线（铜线和光纤)、无线（陆地无线电）和卫星。每种技术都有其自身独特的性质，而这将影响到采用这些传输技术的网络设计和性能。这部分内容为我们理解现代网络的关键传输技术提供了背景知识。</li><li>然后讨论数字调制解调技术，主要解决如何把模拟信号转换成数字比特以及将数字比特还原成模拟信号。在此基础上，引入多路复用方案，探讨如何在同一个传输介质上同时进行多个会话而彼此不会干扰。</li><li>最后将关注三个被广泛应用于计算机广域网的通信系统实例：（固定）电话系统、移动电话系统和有线电视系统。</li></ol><p><strong>该篇博客将讨论后两部分。</strong></p></blockquote><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/11/30/65685de1320c5.jpg"></p><p>上图为本章考试重点，非原书结构，仅供参考。</p><h1 id="数字调制"><a href="#数字调制" class="headerlink" title="数字调制"></a>数字调制</h1><p>有线和无线信道运载模拟信号，模拟信号可表示成诸如连续变化的电压、光照强度或声音强度。为了发送数字信息，我们必须设法用模拟信号来表示比特。比特与代表它们的信号之间的转换过程称为<strong>数字调制</strong>（digital modulation）。</p><p>我们首先学习如何把数据比特直接转换成信号的一些方案。这些方案导致了所谓的<strong>基带传输</strong>（baseband transmission）,这是有线介质普遍使用的一种调制方法。然后我们将考虑通过调节载波信号的幅值、相位或频率来运载比特的调制模式。这些转换方案导致了<strong>通带传输</strong>（passband transmission）, 即信号占据了以载波信号频率为中心的一段频带。这是无线和光纤信道最常使用的调制方法，因为在这样的传输介质中只能在给定的频带中传输信号。</p><h2 id="基带传输（数字信号）"><a href="#基带传输（数字信号）" class="headerlink" title="基带传输（数字信号）"></a>基带传输（数字信号）</h2><ul><li><p>相关概念</p><p>带宽效率：带宽通常是一种有限资源，即使对有线信道也一样。信号频率越高衰减越大，其可用性就越小，而且高频信号还需要更快的电子设备。信号改变的速率称为符号率，以示区别于比特率。比特率是符号率与每个符号的比特数的乘积。</p><p>时钟恢复问题：存在一长串0 或1 时，经过较长时间会导致接收方无法准确判定信号的每个比特，比如15 个0 很像16 个0.</p></li><li><p>数字信号的表示方法<br><strong>下面所有例子的0 和1 表达方式可以交换，即0高1低可换成0低1高，无影响</strong></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/03/656c32a04a0b4.png"></p><ol><li><p>不归零（NRZ，non-return-to-zero）：简单的将低电平表示为0，高电平表示为1。<br>问题：带宽效率低；较多连续的0 或1 导致接收方无法分辨每个比特。</p></li><li><p>不归零逆转（NRZI，non-return-to-zero）：0 时信号不发生变化，1 时信号跳变。<br>问题：可以对连续的1 进行区分，但是不能对连续的0 区分。</p></li><li><p>曼彻斯特编码（Manchester）：将数据信号与时钟信号通过异或方式混合在一起。<br>问题：带宽效率低（需要的带宽是NRZ 的两倍）。</p></li><li><p>差分曼特斯特编码：相对调相的编码，与时钟的表达很相近，但不同点是：若1 则在起始位置进行跳变，若为0 则不进行跳变。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/03/656c30fcd015c.png"></p><p><strong>注意</strong>：两种曼彻斯特编码的1、0 位的定义没有严格的要求，可以与上图表示的相反，只要在过程中完全一致即可</p></li><li><p>N 级编码：采用N 个信号级别，如用单个符号可以一次携带2 个比特，只要接收方可以辨识信号的四个级别即可。如二级编码。</p></li></ol></li></ul><h2 id="通带传输（模拟信号）"><a href="#通带传输（模拟信号）" class="headerlink" title="通带传输（模拟信号）"></a>通带传输（模拟信号）</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/03/656c371f32856.png"></p><p>y&#x3D;Asin(fx+φ)，下面的分别表示是改变A、f 和φ三个参数来区分不同信号</p><ol><li><p>幅移键控（ASK，amplitude shift keying）：不同的振幅表示0，1.</p></li><li><p>频移键控（FSK，frequency shift keying）：不同的频率表示不同的信号，如采用两个不同的频率分别表示0,1</p></li><li><p>相移键控（PSK，phase shift keying）：不同的相位表示不同的信号。在每个符号的周期中，把载波波形偏移0°或180°。更有效利用信道带宽的方法是<br>使用四个偏移（例如45°，90°，135°，180°），这样每个符号可以表示两个比特信息，这种方式被称为正交相移键控（QPSK,quadrature phase shift keying）。</p><p>上述1.2.3方法均为绝对调相（相连两位之间互不影响）。</p></li><li><p>相对调相（relative phase modulation）：相邻两位之间存在相互影响。若为1则跳变，若为0 则无变化，需要给出初始波形，和差分曼彻斯特类似。具体相位变化表示如下图</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/03/656c378fe591e.png"></p><p>例子如下所示（给出初始波形）：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/03/656c37b20eae7.png"></p></li></ol><h1 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h1><p>多路复用简单来说就是使多个信号可以共享同一传输路线。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/03/656c3a9ee40a8.png"></p><h2 id="频分复用"><a href="#频分复用" class="headerlink" title="频分复用"></a>频分复用</h2><p>频分复用（FDM，Frequency Division Multiplexing) 利用通带传输的优势使多个用户共享一个信道。它将频谱分成几个频段，每个用户完全拥有其中的一个频段来发送自己的信号。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/03/656c3a9ef314a.png"></p><h2 id="时分复用"><a href="#时分复用" class="headerlink" title="时分复用"></a>时分复用</h2><p>时分（TDM，time division multiplexing）指一条物理信道按时间分成若干个时间片轮流地分配给多个信号使用。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/03/656c3a9ecf1a3.png"></p><p>例如：下图中，ABCD分别为四个用户，每个用户只在对应的时隙里传输自己的数据。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/03/656c3a9f23044.png"></p><h2 id="波分复用"><a href="#波分复用" class="headerlink" title="波分复用"></a>波分复用</h2><p>波分（WDM，wavelength division multiplexing）是频分多路复用的一种，利用光纤信道的巨大带宽，同一光纤可以同时传输一组不同波长的光信号，并且不会互相影响。简单来说就是光的频分多路复用。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/03/656c3a9f3d575.png"></p><h2 id="码分复用"><a href="#码分复用" class="headerlink" title="码分复用"></a>码分复用</h2><p>码分复用（CDM，Code Division Multiplexing)是扩展频谱通信的一种形式，完全不同于FDM 和CDM，它把一个窄带信号扩展到一个很宽的频带上。广泛应用于无线链路共享。</p><h1 id="公共电话交换网络"><a href="#公共电话交换网络" class="headerlink" title="公共电话交换网络"></a>公共电话交换网络</h1><p>（PSTN，public switched telephone network）</p><ul><li>PSTN 是一种常用的旧式电话系统，提供的是一个模拟的专用通道，通道之间经由若干电环交换机连接而成，当两台主机或路由器需通过PSTN 连接时，必须在网络接入侧使用调制解调器实现信号的模数&#x2F;数模转换。</li><li>电话系统的组成：本地回路、中继线（多路复用）和交换局（交换机、交换技术如虚电路交换和分组交换等）</li></ul><h2 id="本地回路"><a href="#本地回路" class="headerlink" title="本地回路"></a>本地回路</h2><p>本地回路常常称为“最后一英里”，将涉及电话调制解调器、ADSL（非对称数字用户线） 以及光纤到户三部分。</p><ul><li>执行数字比特流和模拟信号流之间转换的设备称为调制解调器, 调制解调器是调制器和解调器的缩写。</li><li>己部署的铜质本地回路限制了ADSL 和电话调制解调器的性能。为了让它们运行得更快，电话公司逐步升级本地回路，把光纤一路拉到家庭住宅和办公楼，这种改进结果就是所谓的光纤到户。</li></ul><h2 id="中继线和多路复用"><a href="#中继线和多路复用" class="headerlink" title="中继线和多路复用"></a>中继线和多路复用</h2><p>电话网络中的中继线不仅比本地回路快得多，而且在其他两个方面与本地回路也有所不同。首先，电话网络核心传送的是数字信息而不是模拟信息，即传的是比特而不是声音。为了在长途中继线上传输数字形式，需要在端局对信号进行一次转换。其次，中继线上同时正进行着数以千计，甚至上百万的电话呼叫。这种多个电话共享一根中继线的方式对于实现规模经济非常重要，因为在两个电话端局之间安装和维护高带宽中继线所需要的基本开销和安装并维护一个低带宽中继线所需的费用差不多。高带宽中继线的共享可通过<strong>TDM</strong>和<strong>FDM</strong> 多路复用方法实现。</p><h2 id="交换"><a href="#交换" class="headerlink" title="交换"></a>交换</h2><p>站在普通电话工程师的角度，电话系统分为两个基本部分：局外部分（本地回路和中继线，因为从物理位置来看，看它们都位于交换局外部）和局内部分（交换机，它们在交换局内部）。</p><p>当前，电话系统中用到了两种不同的交换技术：电路交换和数据包交换。传统的电话系统基于电路交换技术，但随着IP 技术之上的语音通信兴起，数据包交换已经取得了长足的进步。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/12/03/656c40bda4d63.png"></p><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><ul><li>（面向连接）电路交换是以电路连接为目的的交换方式，通信之前要在通信双方之间建立一条被双方独占的物理通道。一旦一个呼叫被建立起来，在两端之间的专用路径被建立就会持续到该次呼叫结束为止。</li><li>电路交换的三个阶段：建立连接、通信、释放连接</li></ul><h3 id="包交换"><a href="#包交换" class="headerlink" title="包交换"></a>包交换</h3><ul><li>（非连接）路由器采用存储-转发技术，把经过它的每个数据包（根据网络线路、包的目的地址等条件）发送到通往该包目的地的路径上，没有固定的路径每个包都可以都不同的路径，所以它们到达的顺序可能出现混乱。</li><li>出现的问题：排队延迟（queuing delay）：数据包可能会因为存在很多包要被转发而需要等待一段时间才能到它被转发，还可能引起拥塞。</li></ul><h1 id="移动电话系统"><a href="#移动电话系统" class="headerlink" title="移动电话系统"></a>移动电话系统</h1><p>移动电话系统可用于广域范围的语音通信和数据通信。移动电话有时称为蜂窝电话。它的发展已经历了三代，俗称1G、2G 和3G 每一代有不同<br>的技术：</p><ol><li>模拟语音</li><li>数字语音</li><li>数字语音和数据</li></ol><h1 id="有线电视"><a href="#有线电视" class="headerlink" title="有线电视"></a>有线电视</h1><p>前面学习了固定电话系统和无线电话系统。很明显，在将来的网络中，它们都将继续扮演着重要的角色。然而，在过去10 年间还出现了另一种可用于Internet 接<br>入的方法：即有线电视网络。</p><p>具体有关有线电视系统的信息，请参见原书。</p>]]></content>
      
      
      <categories>
          
          <category> 大学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网物理层（一）</title>
      <link href="/2023/11/30/%E8%AE%A1%E7%BD%91%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2023/11/30/%E8%AE%A1%E7%BD%91%E7%89%A9%E7%90%86%E5%B1%82%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<blockquote><p>物理层是网络协议模型的最底层，该层定义了比特作为信号在信道上发送时相关的电气、时序和其他接口，是构建网络的基础。物理信道的不同特性决定了其传输性能的不同（比如，吞吐量、延迟和误码率），所以物理层是我们展开网络之旅的最好始发地。</p></blockquote><blockquote><p>本章内容结构：</p><ol><li>首先从数据传输的理论分析出发，探讨决定信道传输的自然局限。</li><li>接着给出三类传输介质：有线（铜线和光纤)、无线（陆地无线电）和卫星。每种技术都有其自身独特的性质，而这将影响到采用这些传输技术的网络设计和性能。这部分内容为我们理解现代网络的关键传输技术提供了背景知识。</li><li>然后讨论数字调制解调技术，主要解决如何把模拟信号转换成数字比特以及将数字比特还原成模拟信号。在此基础上，引入多路复用方案，探讨如何在同一个传输介质上同时进行多个会话而彼此不会干扰。</li><li>最后将关注三个被广泛应用于计算机广域网的通信系统实例：（固定）电话系统、移动电话系统和有线电视系统。</li></ol><p><strong>该篇博客将讨论前两部分。</strong></p></blockquote><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/11/30/65685de1320c5.jpg"></p><p>上图为本章考试重点，非原书结构，仅供参考。</p><h1 id="数据通信的理论基础"><a href="#数据通信的理论基础" class="headerlink" title="数据通信的理论基础"></a>数据通信的理论基础</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ol><li><p>带宽（bandwidth）：在传输中不会明显减弱的频率的宽度，通常引用的带宽是指从0 到使得接收能量保留一半的那个频率位置，是传输介质的一种物理属性。通常取决于介质的构成、厚度、电线或者光纤的长度。</p></li><li><p>信噪比（SNR）：信号功率S 与噪声功率N 的比值，即为信噪比S&#x2F;N。</p></li><li><p>分贝（dB）：通常把信噪比表示成对数的形式10log10S&#x2F;N，对数的取值单位称为分贝。信噪比为100 可表示为20dB。</p></li></ol><h2 id="计算信道的最大数据传输速率"><a href="#计算信道的最大数据传输速率" class="headerlink" title="计算信道的最大数据传输速率"></a>计算信道的最大数据传输速率</h2><ol><li><p>尼奎斯特定理Nyquist<br>用来表示一个有限带宽的无噪声信道的最大数据传输率。<br>表达式：(每秒2B 次采样)最大数据速率&#x3D;2Blog2V（比特&#x2F;秒）<br>B:带宽     V:离散级数，即可识别的信号个数</p></li><li><p>香农定理Shannon<br>用来表示一条带宽为B Hz，信噪比是S&#x2F;N 的有噪声信道的最大数据传输率或容量。<br>表达式：最大数据传输率&#x3D;Blog2(1+S&#x2F;N)（比特&#x2F;秒）<br>B:带宽     S&#x2F;N:信噪比</p></li></ol><h1 id="引导性传输介质"><a href="#引导性传输介质" class="headerlink" title="引导性传输介质"></a>引导性传输介质</h1><p>物理层的作用是将比特从一台机器传输到另一台机器。实际传输所用的物理介质大致上可以分为引导性介质（也称为有线介质，比如铜线和光纤）和非引导性介质（也称为无线介质，比如地面无线电、卫星和激光）两大类。这里探讨引导性传输介质，在下节探讨非引导性传输介质。</p><h2 id="磁介质"><a href="#磁介质" class="headerlink" title="磁介质"></a>磁介质</h2><ul><li>磁介质是将数据写到磁带或其他可擦写介质上（例如可刻录DVD)，然后用物理的方法将磁带或者磁盘运送到目标机器，再将数据从磁带或磁盘里读出来。</li><li>特点：有良好的带宽，但是延迟高。</li></ul><h2 id="双绞线（twisted-pair）"><a href="#双绞线（twisted-pair）" class="headerlink" title="双绞线（twisted pair）"></a>双绞线（twisted pair）</h2><ul><li><p>原理：两根线绞在一起，噪音对他们的干扰是一样的，所以他们的电压差不会改变，通过电压差来表示信号。</p></li><li><p>类型：</p><p>双绞线可以分成几大类。部署在许多办公大楼内的称为5 类线（Category 5) 或“猫5”(Cat 5)。5 类双绞线由两根绝缘导线轻轻地扭在一起，4 对这样的双绞线被套在一个塑料保护套内。塑料外套既保护了双绞线又把多根导线捆在一起，如图2-3 所示。</p><p>5 类线取代了早期的3 类线，每米内的双绞线扭得更紧了，可以导致更少的串扰，而且在长距离传输过程中还能使信号质量更好。</p><p>新双绞线很有可能是6 类甚至是7 类线。这些类别的双绞线具有更严格的规范来处理高带宽信号。某些6 类和更髙类的双绞线信号速率高于500 MHz, 可以支撑10 Gbps 的链路。这些双绞线将很快得到部署。</p></li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/11/30/65686338195a1.png" alt="2-3.png"></p><ul><li><p>概念：</p><p>全双工链路（full-duplex）：可以双向同时用</p><p>半双工联路（half-duplex）：可以双向使用但每一时刻只允许使用一个方向</p><p>单工链路（simplex）：只允许一个方向传输</p></li></ul><h2 id="同轴电缆（coaxial-cable）"><a href="#同轴电缆（coaxial-cable）" class="headerlink" title="同轴电缆（coaxial cable）"></a>同轴电缆（coaxial cable）</h2><ul><li><p>结构：(自内到外)铜芯，绝缘材料，编织外层导体，保护塑料外套，如图2-4</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/11/30/65686524ac2ef.png" alt="2-4.png"></p></li><li><p>优点：很高的带宽，很好的抗噪性。</p></li></ul><h2 id="电力线"><a href="#电力线" class="headerlink" title="电力线"></a>电力线</h2><ul><li>用电力线组建网络十分便利性，只需简单地把电视机和接收器插入墙上的电源插座，它们就可以通过电线发送和接收电影了，如图2-5 所示。</li></ul><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/11/30/656865f42c3db.png" alt="2-5.png"></p><ul><li>家庭网络使用电力线的困难在于电线是专为分发电源信号而设计的。分发电能与分发数据信号是两项完全不同的工作，电信号以50~60 Hz频率发送，高速率数据通信所需的更高频率（MHz）在电线上会产生严重的衰减，因此家庭布线是一项很可怕的工作。</li></ul><h2 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h2><ul><li><p>光纤主要用于网络骨干的长途传输、高速局域网以及高速Internet 接入。光纤传输系统由三个关键部件构成：光源、传输介质和探测器。光探测器探测到光时产生一个电脉冲。在光纤两端分别接上光源和探测器，我们就有了一个单向数据传输系统。该系统接收电子信号，将其转换成光脉冲并传输出去，然后在另一端把光脉冲转换回电子信号输出给接收端。</p></li><li><p>分类：单模光纤、多模光纤。</p></li></ul><h1 id="无线传输"><a href="#无线传输" class="headerlink" title="无线传输"></a>无线传输</h1><p>无线通信除了为用户提供进行Web冲浪的连接外还有许多其他重要的应用，在某些情况下无线具有的优势甚至超过了固定设备的优势。例如，由于地形（山区、丛林、沼泽等）等陆地原因造成把光纤拉到一座建筑物非常困难时，无线或许是更好地选择。</p><p><strong>下面列出了无线传输的五种方式，仅供了解，具体可看原书。</strong></p><h2 id="电磁频谱"><a href="#电磁频谱" class="headerlink" title="电磁频谱"></a>电磁频谱</h2><h2 id="无线电传输"><a href="#无线电传输" class="headerlink" title="无线电传输"></a>无线电传输</h2><h2 id="微波传输"><a href="#微波传输" class="headerlink" title="微波传输"></a>微波传输</h2><h2 id="红外传输"><a href="#红外传输" class="headerlink" title="红外传输"></a>红外传输</h2><h2 id="光通信"><a href="#光通信" class="headerlink" title="光通信"></a>光通信</h2><h1 id="通信卫星"><a href="#通信卫星" class="headerlink" title="通信卫星"></a>通信卫星</h1><p>早在20 世纪50 年代和60 年代初期，人们尝试着利用金属化的气象气球对信号的反射作用来建立通信系统。不幸的是，由于接收到的信号强度太弱，根本没有任何实际价值。后来，美国海军注意到空中存在一个永久性的气象气球——月球，它们通过月球对信号的反射作用建立了一个可实际运行的船-岸通信系统。</p><p>直到第一颗通信卫星发射上天，天体通信领域才有了进一步发展。人造卫星和真实卫星之间的关键区别在于人造卫星把信号送回来之前先对它们进行了放大处理。由此，人类的好奇心促成了一种强大通信系统的诞生。</p><p>通信卫星有一些令人感兴趣的特性，这些特性对于许多应用具有很大的吸引力。按照最简单的方式理解，可以把一个通信卫星想象成天空中的一个大型微波中器。它包含几个转发器，每个转发器侦听频谱中的某一部分，对入境信号进行放大；然后在另一个频率上将放大后的信号重新广播出去；出境信号釆用不同的频率可避免与入境信号相互干扰。这种操作模式称为弯管。还可以将数字化处理添加到分别处理数据，或者把数据流重定向到整个波段，甚至在卫星接收数字信息后再重新广播。以这种方式重新生成的信号相比弯管性能更好，因为卫星没有将上行信号中的噪声放大。下行波束可以很宽，覆盖地球表面相当大的一部分；也可以很窄，仅仅覆盖几百千米直径的区域。</p><p><strong>下面列出四种通信卫星，仅供了解，具体可看原书。</strong></p><h2 id="地球同步卫星"><a href="#地球同步卫星" class="headerlink" title="地球同步卫星"></a>地球同步卫星</h2><h2 id="中地球轨道卫星"><a href="#中地球轨道卫星" class="headerlink" title="中地球轨道卫星"></a>中地球轨道卫星</h2><h2 id="低地球轨道卫星"><a href="#低地球轨道卫星" class="headerlink" title="低地球轨道卫星"></a>低地球轨道卫星</h2><h2 id="卫星与光纤"><a href="#卫星与光纤" class="headerlink" title="卫星与光纤"></a>卫星与光纤</h2>]]></content>
      
      
      <categories>
          
          <category> 大学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络引言</title>
      <link href="/2023/11/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BC%95%E8%A8%80/"/>
      <url>/2023/11/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%BC%95%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<blockquote><p>计网是四大件之一，在计算机基础中占重要地位，对于相关学习者来说是绕不开的一部分。</p><p>以此系列博客记录一下我大三上学期计网的学习过程，期间用到的教材是第五版龙书，有需要电子版的朋友可以联系我。（因为是由英文原书翻译过来的，有些看起来荒谬冗长的语句需要大家联想纠正）</p><p>博客内容主要是考试重点，有很多不完整的部分建议看原书。</p></blockquote><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/11/30/6568496982610.jpg"></p><p>上图为本章考试重点，非原书知识结构，仅供参考。</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ol><li><p>计算机网络(computer networks)：表示一组通过单一技术相互连接起来的自主计算机集合。</p></li><li><p>分布式系统（distributed system）：分布式系统是建立在网络之上的软件系统，有高度的内聚性和透明性。<br>内聚性：每一个数据库分布节点高度自治，有本地数据库管理系统<br>透明性：每个数据库分布节点对用户应用来说是透明的，用户感觉不到数据是分布的</p><p>Internet 是最著名的计算机网络，万维网是最著名的分布式系统，万维网（软件）运行于Internet（硬件）上</p></li><li><p>虚拟专用网络(VPN,virtual private networks)：一种可以将不同地点的单个网络联结成一个扩展网络的技术。</p></li><li><p>P2P 与CS(client-server)<br>CS：由高性能计算机服务器和普通计算机客户机组成，服务器负责存储数据并处理客户请求，而客户机可远程访问服务器<br>P2P：对等模型（又称工作组），各台计算机具有相同功能，一台计算机可作为服务器设定共享资源供网络中其他计算机使用，又可作为工作站。没有专用的服务器或工作站。</p></li></ol><h1 id="网络分类"><a href="#网络分类" class="headerlink" title="网络分类"></a>网络分类</h1><h2 id="依据传输模式划分网络"><a href="#依据传输模式划分网络" class="headerlink" title="依据传输模式划分网络"></a>依据传输模式划分网络</h2><ul><li><strong>单播</strong>(unicasting)：只有一个发送方和一个接收方的点到点传输，也叫点到点链路(point-to-potint)</li><li><strong>广播</strong>(boradcasting)：任何一台机器发出的数据包能被其他人任何机器收到。每个数据包的地址字段指定了预期的接收方，只有预期的接收方会做出应答，其他的机器会忽略这个数据包。</li><li><strong>多播&#x2F;组播</strong>(mutilcasting)：将数据包发给一组机器，即所有机器的一个子集。广播可以看成是一种特殊的组播形式。</li></ul><h2 id="依据网络尺度划分网络"><a href="#依据网络尺度划分网络" class="headerlink" title="依据网络尺度划分网络"></a>依据网络尺度划分网络</h2><ol><li><p>个域网(PAN,Personal Area Network)：允许设备围绕一个人进行通信。一个常见的例子是计算机通过无线网络与其外围设备链接。突出的技术就是蓝牙(bluetooth)。</p></li><li><p>局域网(LAN,Local Area Network)：一种局部地区的私有网络，一般在一座建筑物内或是建筑物附近，比如家庭、办公室或工程。具体分为有线和无线两种。</p><ul><li><p>局域网特点：①距离短；②传输速率高；③错误率低。</p></li><li><p>无线LAN：每台计算机都有一个无线调制解调器和一个天线，用来和其他计算机通信。大多数情况下是和一个设备通信，这个设备称为接入点(AP,Access Point)、无线路由器或者基站。这个设备主要负责中继无线计算机之间的数据包，还负责中继无线计算机和Internet 之间的数据包。代表技术就是WIFI。</p></li><li><p>有线LAN：大多使用铜线作为传输介质，也有一些使用光纤。许多有线局域网的拓扑结构是以点到点链路为基础的，俗称以太网的IEEE 802.3 是迄今为止最常见的一种有线局域网。每台计算机按照以太网协议规定的方式运行，通过一条点到点链路链接到一个盒子，这个盒子称为交换机(switch)，一台交换机有多个端口，每个端口连接一台计算机。交换机的工作是中继与之连接的计算机之间的数据包，根据数据包中的地址来确定这个数据包要发<br>送给哪台计算机。</p></li></ul></li></ol><ul><li>有线局域网在性能的所有方面都超过了无线局域网，因为通过电线或通过光纤发送信号比通过空气发送信号更容易。</li></ul><ol start="3"><li><p>城域网(MAN,Metropolitan Area Network)：范围覆盖一个城市。最著名的城域网例子是许多城市都有的有线电视网。</p></li><li><p>广域网(WAN,Wide Area Network)：范围很大，它跨越很大的地理区域，通常是一个国家、地区或者一个大陆。</p><p>通信子网(subnet):我们按照传统的说法把机器叫做主机，把链接这些主机的网络其余部分称为通信子网，或简称子网。</p></li></ol><p>子网的工作是把信息从一个主机携带到另一个主机。</p><p>子网由两个不同部分组成：传输线路和交换元素。</p><p>传输线路负责在机器之间移动比特，它们可以是铜线、光纤、甚至无线链路。</p><p>交换元素或简称交换机是专用的计算机，负责链接两条或两条以上的传输线路。现在一般称为路由器(Router)</p><ol start="5"><li>互联网：一组相互连接起来的网络。</li></ol><h1 id="服务、接口与协议"><a href="#服务、接口与协议" class="headerlink" title="服务、接口与协议"></a>服务、接口与协议</h1><h2 id="协议层次结构"><a href="#协议层次结构" class="headerlink" title="协议层次结构"></a>协议层次结构</h2><ul><li><strong>协议</strong>(protocol)：是指通信双方就如何进行通信的一种约定。</li><li><strong>接口</strong>(interface)：定义了下层向上层提供哪些原语操作和服务。（它告诉上面的进程如何访问本层，规定了有哪些参数以及结果是什么，但并未说明工作过程和服务方式。）</li><li><strong>服务</strong>是由一组原语(primitive)正式说明，用户可以通过这些原语来访问该服务。协议栈：一个特定的系统所使用的一组协议。</li><li>协议栈：一个特定的系统所使用的一组协议。</li><li><strong>对等体</strong>(peer)：不同机器上构成相应层次的实体称为对等体。</li><li>网络体系机构(network architecture)：层和协议的集合。</li></ul><h2 id="服务和协议的关系"><a href="#服务和协议的关系" class="headerlink" title="服务和协议的关系"></a>服务和协议的关系</h2><ol><li><p>服务是指某一层向它上一层提供的一组原语操作，服务定义了该层打算代表其用户执行哪些操作，但是他不涉及如何实现这些操作，服务也会涉及到两层之间的接口，其中底层是服务提供者，而上层是服务的用户。(上下层之间的联系)</p></li><li><p>协议是一组规则，用来规定同一层上的对等体之间所交换的消息或者分组的格式和含义。这些实体利用协议来实现他们的服务定义，他们可以自由的改变协议而不影响它提供给上层的服务(对等体之间的规范)。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/11/30/6568496a76a6b.jpg" alt="服务和协议的关系.jpg"></p></li></ol><h2 id="面向连接与无连接的服务"><a href="#面向连接与无连接的服务" class="headerlink" title="面向连接与无连接的服务"></a>面向连接与无连接的服务</h2><ul><li>面向对象的连接的服务(connection-oriented service)：是按照电话系统建模的。服务用户首先必须建立一个连接，然后使用连接传输数据，最后释放连接。本质上像一个管道。</li><li>无连接的服务(connectionless service)：是按照邮政系统建模的。每一个报文都携带者完整的目的地址，每个报文都由系统中的中间节点路由，并且独立于后续的报文。</li><li>区别：<ol><li>面向连接的要求建立连接，因而没有传输的数据没有必要再标明传输的目的地址；而无连接的则对每个报文都由独立的目标地址。</li><li>一般来说，面向连接的可靠性较高，协议相对复杂，传输的数据按照发送顺序到达；而无连接的可靠性较差，协议相对简单，常出现乱序，重复和丢失现象。</li></ol></li></ul><h2 id="可靠和不可靠的服务"><a href="#可靠和不可靠的服务" class="headerlink" title="可靠和不可靠的服务"></a>可靠和不可靠的服务</h2><ol><li><p>可靠服务：即从来不丢失数据的一种服务。一般情况下，可靠服务都要求接收方向发送方确认收到的每个报文。</p></li><li><p>不可靠的服务：不会给发送方反馈任何确认消息，不保证数据不丢失。</p></li><li><p>可靠与不可靠服务同时存在的原因：</p></li></ol><p>  在给定的层次可靠通信并不总是可以使用的。</p><p>  为了提高可靠服务而导致的固有延迟可能是不可接受的。</p><ol start="4"><li>例题：面向连接的服务是可靠的吗？<br> 面向连接的服务只是在发送发和接收方之间建立连接，它并不能保证发送的数据流能准确无误的按序到达接收方。面向连接的服务同样分为可靠的面向连接服务和不可靠的面向连接服务。其中，前者主要包括报文序列、字节流，后者如数字化语音。</li></ol><h1 id="参考模型"><a href="#参考模型" class="headerlink" title="参考模型"></a>参考模型</h1><h2 id="OSI-模型"><a href="#OSI-模型" class="headerlink" title="OSI 模型"></a>OSI 模型</h2><p>Open Systems Interconnection具体分为七层，由低到高分别为：物理层，数据链路层，网络层，传输层，会话层，表示层，应用层。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/11/30/6568496a64508.jpg" alt="OSI模型.jpg"></p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/11/30/6568496c08b36.png" alt="OSI模型七层结构.png"></p><p>可以看到，第n 层的问题若第n 层无法完全解决，那么需要依靠其上一层。如物理层实现了点到点的传输，而链路层使此传输变得可靠；网络层确定了传输路径，而传输层使此传输变得可靠。</p><h2 id="TCP-IP-模型"><a href="#TCP-IP-模型" class="headerlink" title="TCP&#x2F;IP 模型"></a>TCP&#x2F;IP 模型</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/11/30/6568496976fdd.jpg" alt="TCP/IP模型.jpg"></p><p>由低到高具体包括：链路层，互联网层，传输层，应用层。<br>本书使用了混合模型，包括五层：物理层，数据链路层，网络层，传输层，应用层。</p><h2 id="OSI-模型和TCP-IP-模型的比较"><a href="#OSI-模型和TCP-IP-模型的比较" class="headerlink" title="OSI 模型和TCP&#x2F;IP 模型的比较"></a>OSI 模型和TCP&#x2F;IP 模型的比较</h2><ul><li>相同点：两者都是建立在协议栈概念上的，并且协议栈中的协议彼此相互独立。同时两个模型中各个层的功能也大致相似。</li><li>不同点：OSI 模型的实力在于模型本身，TCP&#x2F;IP 模型实力在于协议。</li><li>OSI 模型分为7 层，明确区分了服务、接口和协议。OSI 模型中的协议具有更好的隐蔽性，也更加的通用。这个模型是在协议之前产生的，它的网络层同时支持无连接和面向连接的通信，但是传输层只支持面向连接的通信。</li><li>TCP&#x2F;IP 模型分为4 层，没有明确区分服务、接口和协议。通用性差，不适合描述非TCP&#x2F;IP 网络。TCP&#x2F;IP 模型是先有的协议后有的模型，协议和模型切合度高。TCP&#x2F;IP 模型的网络层只支持无连接的通信，但是传输层同时支持两种。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 大学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CDN浅析及在butterfly的应用</title>
      <link href="/2023/11/25/CDN%E6%B5%85%E6%9E%90%E5%8F%8A%E5%9C%A8butterfly%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2023/11/25/CDN%E6%B5%85%E6%9E%90%E5%8F%8A%E5%9C%A8butterfly%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>博客加载速度一直较慢，在查阅了配置文件之后发现可以用CDN提升加载速度，于是乎了解了一下CDN并运用到自己的配置中。</p></blockquote><h1 id="CDN是什么"><a href="#CDN是什么" class="headerlink" title="CDN是什么"></a>CDN是什么</h1><p>CDN英文全称<code>Content Delivery Network</code>，中文翻译为内容分发网络。它是建立并覆盖在承载网之上，由分布在不同区域的边缘节点服务器群组成的分布式网络。CDN应用广泛，支持多种行业、多种场景内容加速，例如：图片小文件、大文件下载、视音频点播、直播流媒体、全站加速、安全加速。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/11/29/6566f6f4db178.png" alt="阿里云官网的例子.png"></p><p>借用上图阿里云官网的例子，来简单介绍CDN的工作原理。假设通过CDN加速的域名为<code>www.a.com</code>，接入CDN网络，开始使用加速服务后，当终端用户（北京）发起HTTP请求时，处理流程如下：</p><ol><li>当终端用户（北京）向<code>www.a.com</code>下的指定资源发起请求时，首先向LDNS（本地DNS）发起域名解析请求。</li><li>LDNS检查缓存中是否有<code>www.a.com</code>的IP地址记录。如果有，则直接返回给终端用户；如果没有，则向授权DNS查询。</li><li>当授权DNS解析<code>www.a.com</code>时，返回域名CNAME  <a href="http://www.a.tbcdn.com对应ip地址./">www.a.tbcdn.com对应IP地址。</a></li><li>域名解析请求发送至阿里云DNS调度系统，并为请求分配最佳节点IP地址。</li><li>LDNS获取DNS返回的解析IP地址。</li><li>用户获取解析IP地址。</li><li>用户向获取的IP地址发起对该资源的访问请求。</li></ol><ul><li>如果该IP地址对应的节点已缓存该资源，则会将数据直接返回给用户，例如，图中步骤7和8，请求结束。</li><li>如果该IP地址对应的节点未缓存该资源，则节点向源站发起对该资源的请求。获取资源后，结合用户自定义配置的缓存策略，将资源缓存至节点，例如，图中的北京节点，并返回给用户，请求结束。</li></ul><p>从这个例子可以了解到：</p><ol><li>CDN的加速资源是跟域名绑定的。</li><li>通过域名访问资源，首先是通过DNS分查找离用户最近的CDN节点（边缘服务器）的IP</li><li>通过IP访问实际资源时，如果CDN上并没有缓存资源，则会到源站请求资源，并缓存到CDN节点上，这样，用户下一次访问时，该CDN节点就会有对应资源的缓存了。</li></ol><p>简单讲，CDN就是通过将站点内容发布至遍布全球的海量加速节点，使其用户可就近获取所需内容。</p><p>CDN主要解决这么些问题:</p><ul><li>物理距离远，多次网络转发，延时高不稳定;</li><li>所在运营商不同，需运营商之间转发绕行;</li><li>网络带宽处理能力有限，海量请求时，响应速度与可用性降低。</li></ul><h1 id="CDN工作原理及作用"><a href="#CDN工作原理及作用" class="headerlink" title="CDN工作原理及作用"></a>CDN工作原理及作用</h1><p>CDN的工作原理就是将源站的资源缓存到位于全国各地的CDN节点上，用户请求资源时，就近返回节点上缓存的资源，而不需要每个用户的请求都回您的源站获取，避免网络拥塞、分担源站压力，保证用户访问资源的速度和体验。 </p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/11/29/6566f6f5addb2.png" alt="CDN原理.png"></p><p><strong>为什么要用 CDN？</strong></p><p>如果你在经营一家网站，那你应该知道几点因素是你制胜的关键：</p><ul><li>内容有吸引力</li><li>访问速度快</li><li>支持频繁的用户互动</li><li>可以在各处浏览无障碍</li></ul><p>此外，你的网站必须能在复杂的网络环境下运行，考虑到全球的用户访问体验。你的网站也会随着使用越来越多的对象（如图片、帧、CSS及APIs）和形形色色的动作（分享、跟踪）而系统逐渐庞大。所以，系统变慢带来用户的流失。</p><p>Google及其它网站的研究表明，一个网站每慢一秒钟，就会丢失许多访客，甚至这些访客永远不会再次光顾这些网站。可以想像，如果网站是你的盈利渠道或是品牌窗口，那么网站速度慢将是一个致命的打击。</p><p>这就是你使用CDN的第一个也是最重要的原因：<strong>为了加速网站的访问</strong>。</p><p>除此之外，CDN还有一些作用：</p><p><strong>1.为了实现跨运营商、跨地域的全网覆盖</strong>**</p><p>互联不互通、区域ISP地域局限、出口带宽受限制等种种因素都造成了网站的区域性无法访问。CDN加速可以覆盖全球的线路，通过和运营商合作，部署IDC资源，在全国骨干节点商，合理部署CDN边缘分发存储节点，充分利用带宽资源，平衡源站流量。</p><p><strong>2. 为了保障你的网站安全</strong></p><p>CDN的负载均衡和分布式存储技术，可以加强网站的可靠性，相当无无形中给你的网站添加了一把保护伞，应对绝大部分的互联网攻击事件。防攻击系统也能避免网站遭到恶意攻击。</p><p><strong>3. 为了异地备援</strong></p><p>当某个服务器发生意外故障时，系统将会调用其他临近的健康服务器节点进行服务，进而提供接近100%的可靠性，这就让你的网站可以做到永不宕机。</p><p><strong>4. 为了节约成本投入</strong></p><p>使用CDN加速可以实现网站的全国铺设，你根据不用考虑购买服务器与后续的托管运维，服务器之间镜像同步，也不用为了管理维护技术人员而烦恼，节省了人力、精力和财力。</p><p><strong>5. 为了让你更专注业务本身</strong></p><p>CDN加速厂商一般都会提供一站式服务，业务不仅限于CDN，还有配套的云存储、大数据服务、视频云服务等，而且一般会提供7x24运维监控支持，保证网络随时畅通，你可以放心使用。并且将更多的精力投入到发展自身的核心业务之上。</p><h1 id="CDN应用场景"><a href="#CDN应用场景" class="headerlink" title="CDN应用场景"></a>CDN应用场景</h1><ol><li><strong>网站站点&#x2F;应用加速</strong></li></ol><p>站点或者应用中大量静态资源的加速分发，建议将站点内容进行动静分离，动态文件可以结合云服务器ECS，静态资源如各类型图片、html、css、js文件等，建议结合 对象存储OSS 存储海量静态资源，可以有效加速内容加载速度，轻松搞定网站图片、短视频等内容分发。</p><ol start="2"><li><strong>视音频点播&#x2F;大文件下载分发加速</strong></li></ol><p>支持各类文件的下载、分发，支持在线点播加速业务，如mp4、flv视频文件或者平均单个文件大小在20M以上，主要的业务场景是视音频点播、大文件下载（如安装包下载）等，建议搭配对象存储OSS使用，可提升回源速度，节约近2&#x2F;3回源带宽成本。</p><ol start="3"><li><strong>视频直播加速</strong></li></ol><p>视频流媒体直播服务，支持媒资存储、切片转码、访问鉴权、内容分发加速一体化解决方案。结合弹性伸缩服务，及时调整服务器带宽，应对突发访问流量；结合媒体转码服务，享受高速稳定的并行转码，且任务规模无缝扩展。</p><ol start="4"><li><strong>移动应用加速</strong></li></ol><p>移动APP更新文件（apk文件）分发，移动APP内图片、页面、短视频、UGC等内容的优化加速分发。提供httpDNS服务，避免DNS劫持并获得实时精确的DNS解析结果，有效缩短用户访问时间，提升用户体验。</p><h1 id="CDN在hexo-butterfly主题下的应用"><a href="#CDN在hexo-butterfly主题下的应用" class="headerlink" title="CDN在hexo butterfly主题下的应用"></a>CDN在hexo butterfly主题下的应用</h1><p>因为众所周知的原因，jsdelivr无法使用了，所以要找新的CDN进行替换。</p><h2 id="新版butterfly"><a href="#新版butterfly" class="headerlink" title="新版butterfly"></a>新版butterfly</h2><p>使用新版butterfly的用户可以切换成local或者custom模式，如下图。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/11/29/6566f6f463235.png" alt="新版butterfly的CDN配置.png"></p><ul><li><p>如果想配置为local模式，只需修改<code>third_party_provider</code>属性为local，并且按照注释进行插件安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-butterfly-extjs</span><br></pre></td></tr></table></figure></li><li><p>如果想配置为custom模式，需修改<code>third_party_provider</code>属性为custom，并且修改<code>custom_format</code>属性，在上图中我就是这么做的。</p><p><code>custom_format</code>属性可以使用给出的例子，或者参考<a href="%5BWeb%E5%89%8D%E7%AB%AF%E5%B8%B8%E7%94%A8CDN%E7%BD%91%E7%AB%99%E6%B1%87%E6%80%BB-CSDN%E5%8D%9A%E5%AE%A2%5D(https://blog.csdn.net/VariatioZbw/article/details/107822562)">这个链接</a>，给出了常用CDN汇总。</p></li></ul><h2 id="旧版butterfly"><a href="#旧版butterfly" class="headerlink" title="旧版butterfly"></a>旧版butterfly</h2><p>旧版butterfly用户或者新版想配置自定义CDN插件的用户就需要第三方CDN插件了。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/11/29/6566f6f43f2e4.png" alt="旧版butterfly配置CDN插件.png"></p><p>在上图的配置处进行逐个插件的配置，具体配置可以参考此博客，<a href="https://blog.zhheo.com/p/790087d9.html">Butterfly CDN链接更改指南，替换jsdelivr提升访问速度 | 张洪Heo (zhheo.com)</a>，如果找到更多CDN可以自己配置上。</p><p>CDN选择原则优先使用字节跳动的cdn，如果没有则使用elemecdn。</p>]]></content>
      
      
      <categories>
          
          <category> 技术浅谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网网络层-拥塞控制算法</title>
      <link href="/2023/11/25/%E8%AE%A1%E7%BD%91%E7%BD%91%E7%BB%9C%E5%B1%82-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95/"/>
      <url>/2023/11/25/%E8%AE%A1%E7%BD%91%E7%BD%91%E7%BB%9C%E5%B1%82-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>计网是四大件之一，在计算机基础中占重要地位，对于相关学习者来说是绕不开的一部分。以此系列博客记录一下我大三上学期计网的学习过程，期间用到的教材是第五版龙书，有需要电子版的朋友可以联系我。（因为是由英文原书翻译过来的，有些看起来荒谬冗长的语句需要大家联想纠正）</p></blockquote><blockquote><p>这里将网络层的拥塞控制这一章节详细展开讲述</p></blockquote><h1 id="拥塞的发生"><a href="#拥塞的发生" class="headerlink" title="拥塞的发生"></a>拥塞的发生</h1><p>网络中存在太多的数据包导致数据包被延迟和丢失，从而降低了传输性能，这种情况称为拥塞（congestion）。网络层和传输层共同承担着处理拥塞的责任，在这里，我们将着眼于拥塞控制在网络层方面的处理。</p><p>图5-21 描绘了拥塞的发生。当主机发送到网络的数据包数量在其承载能力范围之内时，送达的数据包数与发送的数据包数成正比例增长。如果发送量增加了两倍，则送达量也增长了两倍。然而，随着负载接近承载能力，偶尔突发的流量填满了路由器内部的缓冲区，因而某些数据包会被丢失。这些丢失的数据包消耗<br>了部分容量，因此，送达的数据包数量低于理想曲线。网络现在开始拥挤了。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/11/29/6566f58bf0add.png" alt="5-21.png"></p><h1 id="拥塞控制的途径"><a href="#拥塞控制的途径" class="headerlink" title="拥塞控制的途径"></a>拥塞控制的途径</h1><p>拥塞的出现意味着负载暂时大于资源可以处理的能力。很自然人们能想到两个解决方案：增加资源或减少负载。</p><p>如图5-22 所示，这些解决方案通常应用在不同的时间尺度上，要么预先避免拥塞，要么一旦发生拥塞随之做出反应。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/11/29/6566f58c9a56a.png" alt="5-22.png"></p><ul><li>避免拥塞的最基本方法是建立一个与流量匹配良好的网络。有时当出现严重拥塞时，可以动态增加网络资源。这就是所谓的<strong>供给</strong>（provisioning）在长期流量趋势推动下大约需要几个月的时间。</li><li>为了充分利用现有的网络容量，可以根据每天的流量模式度身定制路由，因为不同时区的网络用户每天醒来和睡觉的时间是不同的。例如，一些本地广播电台有直升机围绕着城市上空飞来飞去，及时报告城市道路拥堵情况，帮助它们的移动听众路由它们的数据包（汽车）绕开热点地区，这称为<strong>流量感知的路由</strong>（traffic-aware routing)。</li><li>然而，有的时候不可能增加容量。那么对抗拥塞的唯一的办法就是降低负载。在一个虚电路网络中，如果新的连接将导致网络变得拥挤不堪，那么就应该拒绝这种新连接的建立。这种控制称为<strong>准入控制</strong>（admission control）。</li><li>最后，当一切努力都失败，网络不得不丢弃它无法传递的数据包。这种方法的通用名称是<strong>负载脱落</strong>(load shedding)。一个选择丢弃哪些数据包的良好策略可以防止拥塞崩溃。</li></ul><h1 id="流量感知路由"><a href="#流量感知路由" class="headerlink" title="流量感知路由"></a>流量感知路由</h1><p>最直接的方式是把链路权重设置成一个（固定）链路带宽、传输延迟、（可变）测量负载或平均排队延迟的函数。’在所有其他条件都相同的情况下，最小权重的路径更青睐那些轻负载的路径。</p><p>早期Internet 使用的流量感知路由就是按照这个模型设计的。然而，这种路由存在一个危险。</p><p>考虑图5-23 所示的网络，这里网络被分为东部和西部，这两部分通过链路CF 和EI 相连。假设东西之间的大部分流量使用链路CF, 因此，这个链路负荷超重因而延迟增大。如果把排队延迟加入到计算最短路径的权重中，那么链路EI将变得更具吸引力。当新的路由表被安装好之后，大部分东西方的流量现在改走链路EI由此增加了此链路的负载。因此，在下一次路由更新时，CF 将成为最短路径。结果，路由表可能会剧烈地摇摆不定，从而导致不稳定的路由和许多潜在的问题。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/11/29/6566f58c137db.png" alt="5-23.png"></p><p>如果忽略负载，只考虑带宽和传输延迟，这个问题就不会发生。尝试在路由权重中包括负载但将其限定在一个狭窄的范围可减缓路由振荡。两种技术有助于获得成功的解决方案。首先是多路径路由，即从源到目的地可以存在多条路径。在我们的例子中，这意味着可以把整个流量分散到东部和西部的两条链路上。第二个技术是把流量慢慢迁移，足够慢到路由算法得到收敛。</p><p>由于存在这些困难，Internet 路由协议通常不依赖于负载来调整自己的路由。相反，在路由协议外部通过慢慢改变它的输入来调整路由。这种方法就是所谓的流量工程（traffic engineering )。</p><h1 id="准入控制"><a href="#准入控制" class="headerlink" title="准入控制"></a>准入控制</h1><p>一种广泛应用于虚电路网络，防止出现拥塞的技术是准入控制（admission control)。其基本思想非常简单：除非网络可以携带额外的流量而不会变得拥塞，否则不再建立新的虚电路。因此，任何建立新的虚电路的尝试或许会失败。</p><p>如果我们想要采用准入控制，必须归纳出虚电路的一些流量特性。流量往往用其速度和形状来描述。如何以一种简单而又有意义的方式来描述流量是困难的，因为流量呈现突发性平均速率只讲述了故事的一半。例如，浏览网页时的流量变化很大，比具有固定长期吞吐量的流式电影更难以处理，因为突发性的网页流量更容易<br>堵塞住网络中的路由器。捕获这个效果通常采用的描述符是漏桶（leaky bucket) 或令牌桶(token bucket)。一个漏桶有两个参数约束了平均速率和瞬时突发流量大小。我们将在服务质量这节仔细描述它。有了流量说明， 网络就能决定是否接受新的虚电路。</p><p>准入控制还可以和流量感知路由相结合，在虚电路建立过程中，考虑绕开流量热点区域的路由。例如，考虑图5-24 的网络，这里显示的两台路由器己经被堵塞。<br>假设一台连接到路由器A 的主机想要与另一台连接到路由器B 的主机建立一个连接。通常情况下，这个连接将会经过其中一台拥塞的路由器。为了避免这种情形，我们可以重画网络，如图5-24 (b) 所示，去掉拥塞的路由器和它们所有的线路。图中的虚线显示了条可能的虚电路路径，它避开了拥塞的路由器。（Shaikh 等，1999) 给出了这类负载敏感的路由方案设计。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/11/29/6566f58c618c0.png" alt="5-24.png"></p><h1 id="负载脱落"><a href="#负载脱落" class="headerlink" title="负载脱落"></a>负载脱落</h1><p>当以上任何一种方法都无法消除拥塞时，路由器可以亮出它的杀手锏，即负载脱落。负载脱落（load shedding） 是一种富有想象力的说法，它指当路由器因为来不及处理数据包而面临被这些数据包淹没的危险时，就将它们丢弃。</p><p>对于一个被数据包淹没的路由器来说，关键的问题是选择丢弃哪个数据包。首选的方案可能取决于使用网络的应用程序类型。对于文件传输，旧的数据包价值要高于新的数据包。相比之下，对于实时媒体流，新的数据包价值超过老的数据包。因为如果数据包被延迟并且错失了给用户的播放时间，那么该数据包就变得一无所用。</p><p>更智能的卸载方式需要发送方的合作。一个例子是携带路由信息的数据包。这些数据包比普通数据包要重要得多，因为它们是被用来建立的路由；如果丢失它们，或许就会丢失网络连接。为了实现智能丢弃政策，应用程序必须在它们的数据包上打上标记，指示网络它们有多重要。然后，当不得不丢弃数据包时，路由器可以首先丢弃重要性最轻一类数据包，然后是次重要一类数据包，以此类推。</p><h2 id="随机早期检测"><a href="#随机早期检测" class="headerlink" title="随机早期检测"></a>随机早期检测</h2><p>在拥塞刚出现苗头时就处理它比等拥塞形成之后再设法解决它更加有效。可以利用这种情形来帮助缓解拥塞。在局面变得毫无希望之前让路由器提前丢包，但这里有个时间点的确定问题，即发送方何时采取行动以免为时过晚。解决这个问题的一个流行算法称为随机早期检测（RED，Random Early Detection)。</p><p>为了确定何时开始丢弃数据包，路由器要维护一个运行队列长度的平均值。当某条链路上的平均队列长度超过某个阈值时，该链路就被认为即将拥塞，因此路由器随机丢弃一小部分数据包。随机选择丢弃的数据包使得快速发送方发现丢包的可能性更大；因为在数据报网络中，路由器不能分辨出哪个源引起了网络的最大麻烦，因此随机选择丢弃的数据包或许是最佳选择。当没有出现期待的确认信息时，受此影响的发送方就会发现丢包，然后传输协议将放慢速度。因此，丢失的数据包起到了传递抑制包的同样作用，但却是隐含的，无须路由器发送任何显式信号。</p><p>相比那些只在缓冲区溢出才丢包的路由器，RED 路由器能提高网络性能，虽然它们可能需要调整正常工作方式。举例来说，理想的丢包数量取决于有多少发送方必须得到拥塞通知。然而，如果ECN 可用，那么它就是首选的选项。它的工作方式几乎完全一样，但提供了一个显式拥塞信号而不是依据丢包来判断是否拥塞；RED 用在主机不能接收显式信号的环境里。</p>]]></content>
      
      
      <categories>
          
          <category> 大学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客迁移</title>
      <link href="/2023/11/24/Hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/"/>
      <url>/2023/11/24/Hexo%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在重装系统、换电脑等很多情况下需要对Hexo迁移，进行新部署。</p><p>这里有个前提，一定要把之前博客相关的本地文件夹保存起来，可以上传到git或者直接迁移。</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>主要有两个步骤，安装配置所需环境（1-3）和部署博客，如果已经安装了相应环境可以直接跳转。</p><h2 id="1-Git安装配置"><a href="#1-Git安装配置" class="headerlink" title="1.Git安装配置"></a>1.Git安装配置</h2><p>从官网<a href="https://link.zhihu.com/?target=https://git-scm.com/">Git</a>下载git，在新电脑上安装，因为https速度慢，而且每次都要输入口令，常用的是使用ssh。使用下面方法创建，也可以自己找教程：</p><ol><li><p>打开git bash，在用户主目录下运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;youremail@xxx.com&quot;</span></span><br></pre></td></tr></table></figure><p> 把其中的邮件地址换成自己的邮件地址，然后一路回车。</p></li><li><p>完成后，会在用户主目录下生成<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH key密钥对，<code>id_rsa</code>是私钥，千万不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p></li><li><p>登陆GitHub，打开<code>「Settings」</code>-&gt;<code>「SSH and GPG keys」</code>，然后点击<code>「new SSH key」</code>，填上任意Title，在Key文本框里粘贴公钥<code>id_rsa.pub</code>文件的内容（千万不要粘贴成私钥了！），最后点击<code>「Add SSH Key」</code>，你就应该看到已经添加的Key。</p></li></ol><p><strong>注意</strong>：不要在git版本库中运行ssh，然后又将它提交，这样就把密码泄露出去了。</p><h2 id="2-下载Node-js，并安装"><a href="#2-下载Node-js，并安装" class="headerlink" title="2. 下载Node.js，并安装"></a>2. 下载<a href="https://link.zhihu.com/?target=https://nodejs.org/">Node.js</a>，并安装</h2><h2 id="3-安装Hexo"><a href="#3-安装Hexo" class="headerlink" title="3.安装Hexo"></a>3.安装Hexo</h2><p> 打开git bash客户端，输入 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>，开始安装hexo。</p><h2 id="4-迁移原本的Hexo"><a href="#4-迁移原本的Hexo" class="headerlink" title="4.迁移原本的Hexo"></a>4.迁移原本的Hexo</h2><p>下面就将原来的文件拷贝到新电脑中，但是要注意哪些文件是必须的，哪些文件是可以删除的。</p><ul><li>讨论下哪些文件是必须拷贝的：首先是之前自己修改的文件，像站点配置<code>config.yml</code>，<code>theme</code>文件夹里面的主题，以及<code>source</code>里面自己写的博客文件，这些肯定要拷贝的。除此之外，还有三个文件需要有，就是<code>scaffolds</code>文件夹（文章的模板）、<code>package.json</code>（说明使用哪些包）和<code>.gitignore</code>（限定在提交的时候哪些文件可以忽略）。其实，这三个文件不是我们修改的，所以即使丢失了，也没有关系，我们可以建立一个新的文件夹，然后在里面执行<code>hexo init</code>，就会生成这三个文件，我们只需要将它们拷贝过来使用即可。</li></ul><p><strong>总结：</strong><code>config.yml</code>，<code>theme/</code>，<code>source/</code>，<code>scaffolds/</code>，<code>package.json</code>，<code>.gitignore</code>是需要拷贝的。</p><ul><li>再讨论下哪些文件是不必拷贝的，或者说可以删除的：首先是<code>.git</code>文件，无论是在站点根目录下，还是主题目录下的<code>.git</code>文件，都可以删掉。然后是文件夹<code>node_modules</code>（在用<code>npm install</code>会重新生成），<code>public</code>（这个在用<code>hexo g</code>时会重新生成），<code>.deploy_git</code>文件夹（在使用<code>hexo d</code>时也会重新生成），<code>db.json</code>文件。其实上面这些文件也就是<code>.gitignore</code>文件里面记载的可以忽略的内容。</li></ul><p><strong>总结：</strong><code>.git/</code>，<code>node_modules/</code>，<code>public/</code>，<code>.deploy_git/</code>，<code>db.json</code>文件需要删除。</p><h2 id="5-模块安装"><a href="#5-模块安装" class="headerlink" title="5.模块安装"></a>5.模块安装</h2><p>在<code>git bash</code>中切换目录到新拷贝的文件夹里，使用 <code>npm install</code> 命令，进行模块安装。很明显我们这里没用<code>hexo init</code>初始化，因为有的文件我们已经拷贝生成过来了，所以不必用<code>hexo init</code>去整体初始化，如果不慎在此时用了<code>hexo init</code>，则站点的配置文件<code>_config.yml</code>里面内容会被清空使用默认值，所以这一步一定要慎重，不要用<code>hexo init</code>。</p><h2 id="6-安装其他必要组件"><a href="#6-安装其他必要组件" class="headerlink" title="6.安装其他必要组件"></a>6.安装其他必要组件</h2><ol><li><p>为了使用<code>hexo d</code>来部署到git上，需要安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li><li><p>为了建立RSS订阅，需要安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure></li><li><p>为了建立站点地图，需要安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure></li></ol><p>插件安装后，有的需要对配置文件<code>_config.yml</code>进行配置，具体可以参考上面插件在github主页上的具体说明</p><h2 id="7-检验"><a href="#7-检验" class="headerlink" title="7.检验"></a>7.检验</h2><p>使用<code>hexo g</code>生成静态文件，然后使用<code>hexo d</code>进行部署，如果都没有出错，就转移成功了。</p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>简单来说，就是将整个hexo的文件夹打包发送，然后重新安装模块就可以了。但是切记一定要保存好自己博客的配置和资源文件，否则是无法迁移的。</p>]]></content>
      
      
      <categories>
          
          <category> 技术浅谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客搭建</title>
      <link href="/2023/05/27/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <url>/2023/05/27/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>突发奇想，想搭建一个自己的博客记录一下计算机的学习生涯，在查阅了一些资料后决定使用GitHub Pages来搭建 Hexo 静态博客网站，用的主题是hexo-theme-butterfly。</p><p>说干就干，折腾了半天之后终于搞定，这里要感谢<a href="https://fe32.top/">Ethan.Tzy</a>大佬提供的技术博客，步骤很明确，大家有兴趣的可以关注一下。</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>基本的博客搭建步骤在前言提到的技术博客中都可以找到，这里我记录一下几个没有提到的基本问题。</p><h2 id="博客的创建"><a href="#博客的创建" class="headerlink" title="博客的创建"></a>博客的创建</h2><p>文章可以手动创建，也可以通过<code>hexo new</code>命令创建。hexo官方建议的流程如下：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/11/29/6566f58d96223.png" alt="官方流程.png"></p><ol><li><p>首先确定layout模板，模板中定义的内容可以认为是一种公共内容的提取，模板的内容称为Front-matter，在创建文章时会自动添加到新文件中。hexo自带了三种模板(可按实际情况修改)：page、post、draft。</p><p>page：用于创建列表页;</p><p>post：用于创建具体的博客文章;</p><p>dratf：用于创建草稿(一般不太用)。</p></li><li><p>使用 <code>hexo new</code>命令创建文章。</p></li></ol><p>给出一个最简单的创建文章的例子（文章标题自拟）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new 文章标题</span><br></pre></td></tr></table></figure><h2 id="博客的更新"><a href="#博客的更新" class="headerlink" title="博客的更新"></a>博客的更新</h2><p>在本地对自己的博客进行了配置修改或者文章更新后，如何将其同步到网站上呢，下面会给出答案。</p><p>1.在本地的博客根目录下打开cmd控制台</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/11/29/6566f58c724a3.png" alt="根目录.png"></p><p>2.在控制台中依次输入下面三个命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><p>清除缓存文件 <code>db.json</code> 和已生成的静态文件 <code>public</code>。(网站显示异常时可以执行这条命令试试)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><p><code>hexo g</code> 是 <code>hexo generate</code> 的缩写，作用是生成网站静态文件到默认设置的 <code>public</code> 文件夹。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><p><code>hexo d</code> 是 <code>hexo deploy</code> 的缩写，作用是自动生成网站静态文件，并部署到设定的仓库。</p><p>3.完成上面步骤后，稍等片刻，再次打开博客页面，会发现已经更新完成。</p><h2 id="图片的插入"><a href="#图片的插入" class="headerlink" title="图片的插入"></a>图片的插入</h2><p>在配置和写文章的过程中，很多时候需要图片的插入，这就涉及到图片路径以及存储位置的问题，具体操作步骤如下。</p><h3 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h3><p>如果你有图床那再好不过了，这里推荐一个我正在用的付费图床[去不图床](<a href="https://7bu.top/">去不图床 - 杜老师说旗下付费图片外链平台 (7bu.top)</a>)。</p><h3 id="本地图片"><a href="#本地图片" class="headerlink" title="本地图片"></a>本地图片</h3><p>如果选择用本地图片的方式，需要在本地blog文件夹下创建<code>source\img</code>文件夹，将图片保存进去。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/11/29/6566f58c02024.png" alt="本地图片位置.png"></p><p>在引用时使用img\xxx.jpg的路径进行引用即可，给出一个例子，这里是头像的配置路径。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/11/29/6566f58c32c03.png" alt="图片路径.png"></p><h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>这里推荐以图床的方式进行图片存储，因为渲染速度会比本地的方式快一些。</p><hr><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>hexo的搭建方法很简单，网上的教程资料也很多，按照教程走可以很容易搭建出自己的博客。这里附上<a href="%5BHexo%5D(https://hexo.io/zh-cn/index.html)">hexo中文官方</a>的网址，有兴趣可以看看。</p><p>我的友链里关注的博主们基本都有关于hexo魔改的文章，对魔改有兴趣的读者可以关注下。</p><p>如果有问题欢迎在评论区留言或者加我联系方式一起讨论~</p>]]></content>
      
      
      <categories>
          
          <category> 技术浅谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
